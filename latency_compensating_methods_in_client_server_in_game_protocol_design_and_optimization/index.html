<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


  <meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">

<script>
    (function(){
        if(''){
            let localStoragePasswdKey = 'C/Sæ¸¸æˆæ¶æ„ä¸­å»¶è¿Ÿè¡¥å¿çš„è®¾è®¡å’Œä¼˜åŒ–æ–¹æ³•' + '_last_passwd';
            let tryCnt = 0;
            function checkPassword(password) {
                password = password == null ? null : password.trim();
                if (password !== '') {
                    if (password != null) {
                        // å¦‚æœç”¨æˆ·ç‚¹å‡»äº†ç¡®è®¤è€Œä¸”å¯†ç é”™è¯¯çš„æ—¶å€™, å› ä¸ºå½“password == nullçš„æ—¶å€™è¯´æ˜ç”¨æˆ·ç‚¹äº†å–æ¶ˆ
                        alert('Error!');
                        if (++tryCnt < 3) {
                            password = prompt('Open Sesame');
                            checkPassword(password);
                            return;
                        }
                    }

                    // if (history.length > 1) {
                    //     alert('back!');
                    //     history.back();
                    // } else {
                        // alert('blankkkk!');
                    //     window.location.href = "about:blank";
                    // }
                    if (document.referrer) {
                        window.location.href = document.referrer;
                    } else {
                        window.location.href = "about:blank";; // fallback if no referrer
                    }

                } else {
                    localStorage.setItem(localStoragePasswdKey, password);
                }
            }

            var password_verify_on_local = false;
            const hostname = window.location.hostname;
            if (password_verify_on_local || (!(hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1" || hostname.startsWith("192")))) {
                const lspk = localStorage.getItem(localStoragePasswdKey) || "";
                if (lspk !== '') {
                    var password = prompt('Open Sesame');
                    checkPassword(password);
                }
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">





















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Valve,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="è‡ªæˆ‘æ€»ç»“æ³¨ : Vç¤¾è¿™ç¯‡æ–‡ç« ç›¸å½“æœ‰ä»·å€¼, æ‰€ä»¥ä¼šæœ‰å°½å¯èƒ½è¯¦ç»†çš„æ³¨è§£ä»¥åŠå¯¹åŸè¯‘æ–‡å„ç§ç¿»è¯‘çº°æ¼çš„ä¿®æ­£. å¹¿ä¹‰çš„å»¶è¿Ÿè¡¥å¿ä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªæ–¹é¢ :  A å¦‚ä½•æ˜¾ç¤ºç›®æ ‡ a. å¯¹äºæœ¬ç©å®¶è‡ªå·± å®¢æˆ·ç«¯é¢„è¡¨ç°(æœ¬æ–‡ç¿»è¯‘ä¸ºâ€å®¢æˆ·ç«¯é¢„æµ‹â€) : æ¯”å¦‚å¯¹äºç©å®¶ç§»åŠ¨çš„é¢„æµ‹, å¯ä»¥æŠŠæœåŠ¡å™¨ç¡®è®¤è¿‡çš„movementä¿¡æ¯ä½œä¸ºå¼€å§‹, ç„¶åä½¿ç”¨è‡ªå·±æœ¬åœ°çš„movement inputæ¥è¿›è¡Œé¢„è¡¨ç°, æœåŠ¡å™¨è·Ÿå®¢æˆ·ç«¯å…±äº«åŒä¸€å¥—moveä»£ç ">
<meta name="keywords" content="Valve">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;Sæ¸¸æˆæ¶æ„ä¸­å»¶è¿Ÿè¡¥å¿çš„è®¾è®¡å’Œä¼˜åŒ–æ–¹æ³•">
<meta property="og:url" content="https://hulinhong.com/latency_compensating_methods_in_client_server_in_game_protocol_design_and_optimization/index.html">
<meta property="og:site_name" content="ğŸš™">
<meta property="og:description" content="è‡ªæˆ‘æ€»ç»“æ³¨ : Vç¤¾è¿™ç¯‡æ–‡ç« ç›¸å½“æœ‰ä»·å€¼, æ‰€ä»¥ä¼šæœ‰å°½å¯èƒ½è¯¦ç»†çš„æ³¨è§£ä»¥åŠå¯¹åŸè¯‘æ–‡å„ç§ç¿»è¯‘çº°æ¼çš„ä¿®æ­£. å¹¿ä¹‰çš„å»¶è¿Ÿè¡¥å¿ä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªæ–¹é¢ :  A å¦‚ä½•æ˜¾ç¤ºç›®æ ‡ a. å¯¹äºæœ¬ç©å®¶è‡ªå·± å®¢æˆ·ç«¯é¢„è¡¨ç°(æœ¬æ–‡ç¿»è¯‘ä¸ºâ€å®¢æˆ·ç«¯é¢„æµ‹â€) : æ¯”å¦‚å¯¹äºç©å®¶ç§»åŠ¨çš„é¢„æµ‹, å¯ä»¥æŠŠæœåŠ¡å™¨ç¡®è®¤è¿‡çš„movementä¿¡æ¯ä½œä¸ºå¼€å§‹, ç„¶åä½¿ç”¨è‡ªå·±æœ¬åœ°çš„movement inputæ¥è¿›è¡Œé¢„è¡¨ç°, æœåŠ¡å™¨è·Ÿå®¢æˆ·ç«¯å…±äº«åŒä¸€å¥—moveä»£ç ">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2025-12-17T18:31:29.654Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C&#x2F;Sæ¸¸æˆæ¶æ„ä¸­å»¶è¿Ÿè¡¥å¿çš„è®¾è®¡å’Œä¼˜åŒ–æ–¹æ³•">
<meta name="twitter:description" content="è‡ªæˆ‘æ€»ç»“æ³¨ : Vç¤¾è¿™ç¯‡æ–‡ç« ç›¸å½“æœ‰ä»·å€¼, æ‰€ä»¥ä¼šæœ‰å°½å¯èƒ½è¯¦ç»†çš„æ³¨è§£ä»¥åŠå¯¹åŸè¯‘æ–‡å„ç§ç¿»è¯‘çº°æ¼çš„ä¿®æ­£. å¹¿ä¹‰çš„å»¶è¿Ÿè¡¥å¿ä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªæ–¹é¢ :  A å¦‚ä½•æ˜¾ç¤ºç›®æ ‡ a. å¯¹äºæœ¬ç©å®¶è‡ªå·± å®¢æˆ·ç«¯é¢„è¡¨ç°(æœ¬æ–‡ç¿»è¯‘ä¸ºâ€å®¢æˆ·ç«¯é¢„æµ‹â€) : æ¯”å¦‚å¯¹äºç©å®¶ç§»åŠ¨çš„é¢„æµ‹, å¯ä»¥æŠŠæœåŠ¡å™¨ç¡®è®¤è¿‡çš„movementä¿¡æ¯ä½œä¸ºå¼€å§‹, ç„¶åä½¿ç”¨è‡ªå·±æœ¬åœ°çš„movement inputæ¥è¿›è¡Œé¢„è¡¨ç°, æœåŠ¡å™¨è·Ÿå®¢æˆ·ç«¯å…±äº«åŒä¸€å¥—moveä»£ç ">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: false,
    mediumzoom: true,
    darkmode_js: false,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":188,"transition":{"header":"fadeIn","menu":"fadeIn","logo":"fadeIn","post_block_else":"fadeIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"fadeIn","footer":"fadeIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>C/Sæ¸¸æˆæ¶æ„ä¸­å»¶è¿Ÿè¡¥å¿çš„è®¾è®¡å’Œä¼˜åŒ–æ–¹æ³• | ğŸš™</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ğŸš™</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">ğŸ’¨ ğŸ’¨ ğŸ’¨</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <div class="site-search-div">
    <button class="search-icon" id="search-button">
      <i class="fa fa-search"></i>
    </button>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">Ã—</i>
  </div>


<script type="text/javascript" id="local.search.active">
    {/* var inputArea       = document.querySelector("#local-search-input");
    inputArea.onclick   = function(){ getSearchFile(); this.focus(); }
    inputArea.onkeydown = function(){ if(event.keyCode == 13) return false } */}
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/latency_compensating_methods_in_client_server_in_game_protocol_design_and_optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ğŸš™">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C/Sæ¸¸æˆæ¶æ„ä¸­å»¶è¿Ÿè¡¥å¿çš„è®¾è®¡å’Œä¼˜åŒ–æ–¹æ³•</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-06T20:37:38+00:00">
                01-06-2016
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            <div class="post-tags">
              
                <a href="/tags/Valve/" rel="tag"><i class="fa fa-tag"></i> Valve</a>
              
            </div>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/cplusplus_confused_points_two/" rel="next" title="C++å¾ˆåŸºç¡€çš„æ˜“æ··æ·†ç‚¹äºŒ">
                <i class="fa fa-chevron-left"></i> 
                <p class="post-nav-pre-next-title">
                  C++å¾ˆåŸºç¡€çš„æ˜“æ··æ·†ç‚¹äºŒ
                </p> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Sourceå¼•æ“å¤šäººæ¸¸æˆç½‘ç»œè®¾è®¡/" rel="prev" title="Sourceå¼•æ“å¤šäººæ¸¸æˆç½‘ç»œè®¾è®¡">
              <p class="post-nav-pre-next-title">
                  Sourceå¼•æ“å¤šäººæ¸¸æˆç½‘ç»œè®¾è®¡
              </p> 
              <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

      
      

      
        <h1 id="è‡ªæˆ‘æ€»ç»“"><a href="#è‡ªæˆ‘æ€»ç»“" class="headerlink" title="è‡ªæˆ‘æ€»ç»“"></a>è‡ªæˆ‘æ€»ç»“</h1><p>æ³¨ : Vç¤¾è¿™ç¯‡æ–‡ç« ç›¸å½“æœ‰ä»·å€¼, æ‰€ä»¥ä¼šæœ‰å°½å¯èƒ½è¯¦ç»†çš„æ³¨è§£ä»¥åŠå¯¹åŸè¯‘æ–‡å„ç§ç¿»è¯‘çº°æ¼çš„ä¿®æ­£.</p>
<p>å¹¿ä¹‰çš„å»¶è¿Ÿè¡¥å¿ä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªæ–¹é¢ :</p>
<ul>
<li><strong>A å¦‚ä½•æ˜¾ç¤ºç›®æ ‡</strong><ul>
<li><strong>a. å¯¹äºæœ¬ç©å®¶è‡ªå·±</strong><ul>
<li><strong>å®¢æˆ·ç«¯é¢„è¡¨ç°</strong>(æœ¬æ–‡ç¿»è¯‘ä¸ºâ€å®¢æˆ·ç«¯é¢„æµ‹â€) : æ¯”å¦‚å¯¹äºç©å®¶ç§»åŠ¨çš„é¢„æµ‹, å¯ä»¥æŠŠæœåŠ¡å™¨ç¡®è®¤è¿‡çš„movementä¿¡æ¯ä½œä¸ºå¼€å§‹, ç„¶åä½¿ç”¨è‡ªå·±æœ¬åœ°çš„movement inputæ¥è¿›è¡Œé¢„è¡¨ç°, æœåŠ¡å™¨è·Ÿå®¢æˆ·ç«¯å…±äº«åŒä¸€å¥—moveä»£ç , å½“æœåŠ¡å™¨çš„ç¡®è®¤ä¿¡æ¯è¿‡æ¥ä¹‹åå°±ç›´æ¥ä½¿ç”¨æœåŠ¡å™¨å‘è¿‡æ¥çš„from stateè¿›è¡Œä¿®æ­£å¹¶ä»¥from stateä¸ºåŸºç¡€æ‰§è¡Œä¹‹åçš„é¢„æµ‹.</li>
</ul>
</li>
<li><strong>b. å¯¹äºå…¶ä»–ç©å®¶</strong><ul>
<li><strong>i. å¤–æ¨æ³•</strong> : å³èˆªä½æ¨æµ‹æ³•, å¤–æ¨æ³•æŠŠå…¶å®ƒç©å®¶/ç‰©ä½“çœ‹ä½œä¸€ä¸ªç‚¹ï¼Œè¿™ä¸ªç‚¹å¼€å§‹çš„ä½ç½®ã€æ–¹å‘ã€é€Ÿåº¦å·²çŸ¥ï¼Œæ²¿ç€è‡ªå·±çš„å¼¹é“å‘å‰ç§»åŠ¨ã€‚å› æ­¤ï¼Œå‡è®¾å»¶æ—¶æ˜¯100msï¼Œæœ€æ–°çš„åè®®é€šçŸ¥å®¢æˆ·ç«¯è¿™ä¸ªç©å®¶å¥”è·‘é€Ÿåº¦æ˜¯500å•ä½æ¯ç§’ï¼Œæ–¹å‘å‚ç›´äºç©å®¶è§†çº¿ï¼Œå®¢æˆ·ç«¯å°±å¯ä»¥å‡è®¾äº‹å®ä¸Šè¿™ä¸ªç©å®¶å½“å‰å®é™…çš„ä½ç½®å·²ç»å‘å‰ç§»åŠ¨äº†50ä¸ªå•ä½ã€‚å®¢æˆ·ç«¯å¯ä»¥åœ¨è¿™ä¸ªå¤–æ¨çš„ä½ç½®æ¸²æŸ“è¿™ä¸ªç©å®¶. è¿™ä¸ªæ–¹æ³•ä¸é€‚ç”¨äºFPSæ¸¸æˆ, å› ä¸ºå¤§éƒ¨åˆ†FPSæ¸¸æˆé‡‡ç”¨éç°å®çš„ç©å®¶ç³»ç»Ÿï¼Œç©å®¶å¯ä»¥éšæ—¶è½¬å¼¯ï¼Œå¯ä»¥åœ¨ä»»æ„è§’åº¦ä½œç”¨ä¸ç°å®çš„åŠ é€Ÿåº¦ï¼Œå› æ­¤å¤–æ¨æ³•å¾—åˆ°çš„ç»“æœç»å¸¸æ˜¯é”™è¯¯åœ°</li>
<li><strong>ii. å†…æ¨æ³•</strong> : å³å½±å­è·Ÿéšæ³•, è¿™ç§æ–¹æ³•æ˜¯ç”¨å»¶æ—¶æ¥æ¢å–å¹³æ»‘, å®¢æˆ·ç«¯ç‰©ä½“å®é™…ç§»åŠ¨ä½ç½®æ€»æ˜¯æ»åä¸€æ®µæ—¶é—´ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœæœåŠ¡å™¨æ¯ç§’åŒæ­¥10æ¬¡ä¸–ç•Œä¿¡æ¯ï¼Œå®¢æˆ·ç«¯æ¸²æŸ“çš„æ—¶å€™ä¼šæœ‰100msæ»åã€‚è¿™æ ·ï¼Œæ¯ä¸€å¸§æ¸²æŸ“çš„æ—¶å€™ï¼Œæˆ‘ä»¬é€šè¿‡æœ€æ–°æ”¶åˆ°çš„ä½ç½®ä¿¡æ¯å’Œå‰100msçš„ä½ç½®ä¿¡æ¯ï¼ˆæˆ–è€…ä¸Šä¸€å¸§æ¸²æŸ“ä½ç½®ï¼‰è¿›è¡Œå·®å€¼å¾—åˆ°ç»“æœ.<ul>
<li><strong>å¦‚æœä¸€ä¸ªæ›´æ–°åŒ…æ²¡æœ‰æ”¶åˆ°ï¼Œæœ‰2ç§å¤„ç†æ–¹æ³•</strong> : <ul>
<li>ç”¨ä¸Šé¢ä»‹ç»çš„å¤–æ¨æ³•ï¼ˆæœ‰å¯èƒ½äº§ç”Ÿè¾ƒå¤§è¯¯å·®ï¼‰ï¼›</li>
<li>ä¿æŒç©å®¶ä½äºå½“å‰ä½ç½®ç›´åˆ°æ”¶åˆ°ä¸‹ä¸€ä¸ªæ›´æ–°åŒ…(ä¼šå¯¼è‡´ç©å®¶ç§»åŠ¨é¡¿æŒ«)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>B. å»¶è¿Ÿè¡¥å¿</strong>, æ­¥éª¤å¦‚ä¸‹ : </p>
<ol>
<li>ä¸ºç©å®¶è®¡ç®—ä¸€ä¸ªç›¸å½“ç²¾ç¡®çš„å»¶è¿Ÿæ—¶é—´</li>
<li>å¯¹æ¯ä¸ªç©å®¶ï¼Œä»æœåŠ¡å™¨å†å²ä¿¡æ¯ä¸­æ‰¾ä¸€ä¸ªå·²å‘é€ç»™è¿™ä¸ªç©å®¶å¹¶ä¸”è¿™ä¸ªç©å®¶å·²æ”¶åˆ°çš„çš„world update, è¿™ä¸ªworld updateæ˜¯åœ¨è¿™ä¸ªç©å®¶å°†è¦æ‰§è¡Œè¿™ä¸ªmovement commandä¹‹å‰çš„world update</li>
<li>å¯¹äºæ¯ä¸€ä¸ªç©å®¶ï¼Œå°†å…¶ä»ä¸Šè¿°çš„world updateå¤„æ‹‰å›åˆ°è¿™ä¸ªç©å®¶ç”Ÿæˆæ­¤user commandçš„æ›´æ–°æ—¶é—´ä¸­æ‰§è¡Œç”¨æˆ·å‘½ä»¤ã€‚è¿™ä¸ªå›é€€æ—¶é—´éœ€è¦è€ƒè™‘åˆ°å‘½ä»¤æ‰§è¡Œçš„æ—¶å€™çš„ç½‘ç»œå»¶æ—¶å’Œæ’å€¼é‡</li>
<li>æ‰§è¡Œç©å®¶å‘½ä»¤ï¼ˆåŒ…æ‹¬æ­¦å™¨å¼€ç«ç­‰ã€‚ï¼‰</li>
<li>å°†æ‰€æœ‰ç§»åŠ¨çš„ã€é”™ä½çš„ç©å®¶ç§»åŠ¨åˆ°ä»–ä»¬å½“å‰æ­£ç¡®ä½ç½®</li>
</ol>
</li>
</ul>
<h1 id="åŸæ–‡"><a href="#åŸæ–‡" class="headerlink" title="åŸæ–‡"></a>åŸæ–‡</h1><p><a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization" target="_blank" rel="noopener">åŸæ–‡å‡ºå¤„</a></p>
<p>åŸæ–‡æ ‡é¢˜ : <strong>Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</strong></p>
<hr>
<div id="toc" class="toc" style="display:none"><br>    <div id="toctitle"><br>        <h2 id="Contents">Contents</h2><br>    </div><br>    <ul><br>        <li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li><br>        <li class="toclevel-1 tocsection-2"><a href="#Basic_Architecture_of_a_Client_.2F_Server_Game"><span class="tocnumber">2</span> <span class="toctext">Basic Architecture of a Client / Server Game</span></a></li><br>        <li class="toclevel-1 tocsection-3"><a href="#Contents_of_the_User_Input_messages"><span class="tocnumber">3</span> <span class="toctext">Contents of the User Input messages</span></a></li><br>        <li class="toclevel-1 tocsection-4"><a href="#Client_Side_Prediction"><span class="tocnumber">4</span> <span class="toctext">Client Side Prediction</span></a></li><br>        <li class="toclevel-1 tocsection-5"><a href="#Client-Side_Prediction_of_Weapon_Firing"><span class="tocnumber">5</span> <span class="toctext">Client-Side Prediction of Weapon Firing</span></a></li><br>        <li class="toclevel-1 tocsection-6"><a href="#Umm.2C_This_is_a_Lot_of_Work"><span class="tocnumber">6</span> <span class="toctext">Umm, This is a Lot of Work</span></a></li><br>        <li class="toclevel-1 tocsection-7"><a href="#Display_of_Targets"><span class="tocnumber">7</span> <span class="toctext">Display of Targets</span></a></li><br>        <li class="toclevel-1 tocsection-8"><a href="#Lag_Compensation"><span class="tocnumber">8</span> <span class="toctext">Lag Compensation</span></a></li><br>        <li class="toclevel-1 tocsection-9"><a href="#Game_Design_Implications_of_Lag_Compensation"><span class="tocnumber">9</span> <span class="toctext">Game Design Implications of Lag Compensation</span></a></li><br>        <li class="toclevel-1 tocsection-10"><a href="#Conclusion"><span class="tocnumber">10</span> <span class="toctext">Conclusion</span></a></li><br>        <li class="toclevel-1 tocsection-11"><a href="#Footnotes"><span class="tocnumber">11</span> <span class="toctext">Footnotes</span></a></li><br>    </ul><br></div>

<p></p><h2 id="Overview">Overview</h2><p></p>
<p>Dsigning first-person action games for Internet play is a challenging process. Having robust on-line gameplay in your action title, however, is becoming essential to the success and longevity of the title. In addition, the PC space is well known for requiring developers to support a wide variety of customer setups. Often, customers are running on less than state-of-the-art hardware. The same holds true for their network connections.<br></p><p>While broadband has been held out as a panacea for all of the current woes of on-line gaming, broadband is not a simple solution allowing developers to ignore the implications of latency and other network factors in game designs. It will be some time before broadband truly becomes adopted in the United States, and much longer before it can be assumed to exist for your clients in the rest of the world. In addition, there are a lot of poor broadband solutions, where users may occasionally have high bandwidth, but more often than not also have significant latency and packet loss in their connections.<br></p><p>Your game must behave well in this world. This discussion will give you a sense of some of the tradeoffs required to deliver a cutting-edge action experience on the Internet. The discussion will provide some background on how client / server architectures work in many on-line action games. In addition, the discussion will show how predictive modeling can be used to mask the effects of latency. Finally, the discussion will describe a specific mechanism, lag compensation, for allowing the game to compensate for connection quality.<br></p>

<p><strong>. . .</strong><a id="more"></a></p>
<p></p><h2 id="Basic_Architecture_of_a_Client_.2F_Server_Game">Basic Architecture of a Client / Server Game</h2><p></p>
<p>Most action games played on the net today are modified client / server games. Games such as Half-Life, including its mods such as Counter-Strike and Team Fortress Classic, operate on such a system, as do games based on the Quake3 engine and the Unreal Tournament engine. In these games, there is a single, authoritative server that is responsible for running the main game logic. To this are connected one or more â€œdumbâ€ clients. These clients, initially, were nothing more than a way for the user input to be sampled and forwarded to the server for execution. The server would execute the input commands, move around other objects, and then send back to the client a list of objects to render. Of course, the real world system has more components to it, but the simplified breakdown is useful for thinking about prediction and lag compensation.<br></p><p>With this in mind, the typical client / server game engine architecture generally looks like this:<br></p><p><br><br></p>


<p><br><br>For this discussion, all of the messaging and coordination needed to start up the connection between client and server is omitted. The clientâ€™s frame loop looks something like the following:<br></p><br><ol><br><li>Sample clock to find start time<br></li><br><li>Sample user input (mouse, keyboard, joystick)<br></li><br><li>Package up and send movement command using simulation time<br></li><br><li>Read any packets from the server from the network system<br></li><br><li>Use packets to determine visible objects and their state<br></li><br><li>Render Scene<br></li><br><li>Sample clock to find end time<br></li><br><li>End time minus start time is the simulation time for the next frame<br></li><br></ol><br><p>Each time the client makes a full pass through this loop, the â€œframetimeâ€ is used for determining how much simulation is needed on the next frame. If your framerate is totally constant then frametime will be a correct measure. Otherwise, the frametimes will be incorrect, but there isnâ€™t really a solution to this (unless you could deterministically figure out exactly how long it was going to take to run the next frame loop iteration before running itâ€¦).<br></p><p>The server has a somewhat similar loop:<br></p><br><ol><br><li>Sample clock to find start time<br></li><br><li>Read client user input messages from network<br></li><br><li>Execute client user input messages<br></li><br><li>Simulate server-controlled objects using simulation time from last full pass<br></li><br><li>For each connected client, package up visible objects/world state and send to client<br></li><br><li>Sample clock to find end time<br></li><br><li>End time minus start time is the simulation time for the next frame<br></li><br></ol><br><p>In this model, non-player objects run purely on the server, while player objects drive their movements based on incoming packets. Of course, this is not the only possible way to accomplish this task, but it does make sense.<br></p><br><h2 id="Contents_of_the_User_Input_messages">Contents of the User Input messages</h2><br><p>In Half-Life engine games, the user input message format is quite simple and is encapsulated in a data structure containing just a few essential fields:<br></p><br><div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">typedef</span> <span class="kw4">struct</span> usercmd_s<br><span class="br0">&#123;</span><br>    <span class="co1">// Interpolation time on client</span><br>    <span class="kw4">short</span>        lerp_msec<span class="sy4">;</span><br>    <span class="co1">// Duration in ms of command</span><br>    byte        msec<span class="sy4">;</span><br>    <span class="co1">// Command view angles.</span><br>    vec3_t    viewangles<span class="sy4">;</span><br>    <span class="co1">// intended velocities</span><br>    <span class="co1">// Forward velocity.</span><br>    <span class="kw4">float</span>        forwardmove<span class="sy4">;</span><br>    <span class="co1">// Sideways velocity.</span><br>    <span class="kw4">float</span>        sidemove<span class="sy4">;</span><br>    <span class="co1">// Upward velocity.</span><br>    <span class="kw4">float</span>        upmove<span class="sy4">;</span><br>    <span class="co1">// Attack buttons</span><br>    <span class="kw4">unsigned</span> <span class="kw4">short</span> buttons<span class="sy4">;</span><br>    <span class="co1">//</span><br>    <span class="co1">// Additional fields omittedâ€¦</span><br>    <span class="co1">//</span><br><span class="br0">&#125;</span> usercmd_t<span class="sy4">;</span></pre></div></div><br><p>The critical fields here are the msec, viewangles, forward, side, and upmove, and buttons fields. The msec field corresponds to the number of milliseconds of simulation that the command corresponds to (itâ€™s the frametime). The viewangles field is a vector representing the direction the player was looking during the frame. The forward, side, and upmove fields are the impulses determined by examining the keyboard, mouse, and joystick to see if any movement keys were held down. Finally, the buttons field is just a bit field with one or more bits set for each button that is being held down.<br></p><p>Using the above data structures and client / server architecture, the core of the simulation is as follows. First, the client creates and sends a user command to the server. The server then executes the user command and sends updated positions of everything back to client. Finally, the client renders the scene with all of these objects. This core, though quite simple, does not react well under real world situations, where users can experience significant amounts of latency in their Internet connections. The main problem is that the client truly is â€œdumbâ€ and all it does is the simple task of sampling movement inputs and waiting for the server to tell it the results. If the client has 500 milliseconds of latency in its connection to the server, then it will take 500 milliseconds for any client actions to be acknowledged by the server and for the results to be perceptible on the client. While this round trip delay may be acceptable on a Local Area Network (LAN), it is not acceptable on the Internet.<br></p><br><h2 id="Client_Side_Prediction">Client Side Prediction</h2><br><p>One method for ameliorating this problem is to perform the clientâ€™s movement locally and just assume, temporarily, that the server will accept and acknowledge the client commands directly. This method is labeled as client-side prediction.<br></p><p>Client-side prediction of movements requires us to let go of the â€œdumbâ€ or minimal client principle. Thatâ€™s not to say that the client is fully in control of its simulation, as in a peer-to-peer game with no central server. There still is an authoritative server running the simulation just as noted above. Having an authoritative server means that even if the client simulates different results than the server, the serverâ€™s results will eventually correct the clientâ€™s incorrect simulation. Because of the latency in the connection, the correction might not occur until a full round tripâ€™s worth of time has passed. The downside is that this can cause a very perceptible shift in the playerâ€™s position due to the fixing up of the prediction error that occurred in the past.<br></p><p>To implement client-side prediction of movement, the following general procedure is used. As before, client inputs are sampled and a user command is generated. Also as before, this user command is sent off to the server. However, each user command (and the exact time it was generated) is stored on the client. The prediction algorithm uses these stored commands.<br></p><p>For prediction, the last acknowledged movement from the server is used as a starting point. The acknowledgement indicates which user command was last acted upon by the server and also tells us the exact position (and other state data) of the player after that movement command was simulated on the server. The last acknowledged command will be somewhere in the past if there is any lag in the connection. For instance, if the client is running at 50 frames per second (fps) and has 100 milliseconds of latency (roundtrip), then the client will have stored up five user commands ahead of the last one acknowledged by the server. These five user commands are simulated on the client as a part of client-side prediction. Assuming full prediction<sup id="fnote1"><a href="#Footnotes">1</a></sup>, the client will want to start with the latest data from the server, and then run the five user commands through â€œsimilar logicâ€ to what the server uses for simulation of client movement. Running these commands should produce an accurate final state on the client (final player position is most important) that can be used to determine from what position to render the scene during the current frame.<br></p><p>In Half-Life, minimizing discrepancies between client and server in the prediction logic is accomplished by sharing the identical movement code for players in both the server-side game code and the client-side game code. These are the routines in the <code>pm_shared/</code> (which stands for â€œplayer movement sharedâ€) folder of the <a rel="noopener" class="external text" href="http://download.cnet.com/downloads/0-10045-100-3422497.html" target="_blank">HL SDK</a>. The input to the shared routines is encapsulated by the user command and a â€œfromâ€ player state. The output is the new player state after issuing the user command. The general algorithm on the client is as follows:<br></p><br><pre>â€œfrom stateâ€ &lt;- state after last user command acknowledged by the server;<br><br>â€œcommandâ€ &lt;- first command after last user command acknowledged by server;<br><br>while (true)<br>{<br>    run â€œcommandâ€ on â€œfrom stateâ€ to generate â€œto stateâ€;<br>    if (this was the most up to date â€œcommandâ€)<br>        break;<br><br>    â€œfrom stateâ€ = â€œto stateâ€;<br>    â€œcommandâ€ = next â€œcommandâ€;<br>};<br></pre><br><p>The origin and other state info in the final â€œto stateâ€ is the prediction result and is used for rendering the scene that frame. The portion where the command is run is simply the portion where all of the player state data is copied into the shared data structure, the user command is processed (by executing the common code in the pm_shared routines in Half-Lifeâ€™s case), and the resulting data is copied back out to the â€œto stateâ€.<br></p><p>There are a few important caveats to this system. First, youâ€™ll notice that, depending upon the clientâ€™s latency and how fast the client is generating user commands (i.e., the clientâ€™s framerate), the client will most often end up running the same commands over and over again until they are finally acknowledged by the server and dropped from the list (a sliding window in Half-Lifeâ€™s case) of commands yet to be acknowledged. The first consideration is how to handle any sound effects and visual effects that are created in the shared code. Because commands can be run over and over again, itâ€™s important not to create footstep sounds, etc. multiple times as the old commands are re-run to update the predicted position. In addition, itâ€™s important for the server not to send the client effects that are already being predicted on the client. However, the client still must re-run the old commands or else there will be no way for the server to correct any erroneous prediction by the client. The solution to this problem is easy: the client just marks those commands which have not been predicted yet on the client and only plays effects if the user command is being run for the first time on the client.<br></p><p>The other caveat is with respect to state data that exists solely on the client and is not part of the authoritative update data from the server. If you donâ€™t have any of this type of data, then you can simply use the last acknowledged state from the server as a starting point, and run the prediction user commands â€œin-placeâ€ on that data to arrive at a final state (which includes your position for rendering). In this case, you donâ€™t need to keep all of the intermediate results along the route for predicting from the last acknowledged state to the current time. However, if you are doing any logic totally client side (this logic could include functionality such as determining where the eye position is when you are in the process of crouchingâ€”and itâ€™s not really totally client side since the server still simulates this data also) that affects fields that are not replicated from the server to the client by the networking layer handling the playerâ€™s state info, then you will need to store the intermediate results of prediction. This can be done with a sliding window, where the â€œfrom stateâ€ is at the start and then each time you run a user command through prediction, you fill in the next state in the window. When the server finally acknowledges receiving one or more commands that had been predicted, it is a simple matter of looking up which state the server is acknowledging and copying over the data that is totally client side to the new starting or â€œfrom stateâ€.<br></p><p>So far, the above procedure describes how to accomplish client side prediction of movements. This system is similar to the system used in <a href="/wiki/QuakeWorld" title="QuakeWorld">QuakeWorld</a><sup id="fnote2"><a href="#Footnotes">2</a></sup>.<br></p><br><h2 id="Client-Side_Prediction_of_Weapon_Firing">Client-Side Prediction of Weapon Firing</h2><br><p>Layering prediction of the firing effects of weapons onto the above system is straightforward. Additional state information is needed for the local player on the client, of course, including which weapons are being held, which one is active, and how much ammo each of these weapons has remaining. With this information, the firing logic can be layered on top of the movement logic because, once again, the state of the firing buttons is included in the user command data structure that is shared between the client and the server. Of course, this can get complicated if the actual weapon logic is different between client and server. In Half-Life, we chose to avoid this complication by moving the implementation of a weaponâ€™s firing logic into â€œshared codeâ€ just like the player movement code. All of the variables that contribute to determining weapon state (e.g., ammo, when the next firing of the weapon can occur, what weapon animation is playing, etc.), are then part of the authoritative server state and are replicated to the client-side so there, they can be used for prediction of weapon state.<br></p><p>Predicting weapon firing on the client will likely lead to the decision also to predict weapon switching, deployment, and holstering. In this fashion, the user feels that the game is 100% responsive to his or her movement and weapon activation activities. This goes a long way toward reducing the feeling of latency that many players have come to endure with todayâ€™s Internet-enabled action experiences.<br></p><br><h2 id="Umm.2C_This_is_a_Lot_of_Work">Umm, This is a Lot of Work</h2><br><p>Replicating the necessary fields to the client and handling all of the intermediate state is a fair amount of work. At this point, you may be asking, why not eliminate all of the server stuff and just have the client report where s/he is after each movement? In other words, why not ditch the server stuff and just run the movement and weapons purely on the client-side? Then, the client would just send results to the server along the lines of, â€œIâ€™m now at position x and, by the way, I just shot player 2 in the head.â€ This is fine if you can trust the client. This is how a lot of the military simulation systems work (i.e., they are a closed system and they trust all of the clients). This is how peer-to-peer games generally work. For Half-Life, this mechanism is unworkable because of realistic concerns about cheating. If we encapsulated absolute state data in this fashion, weâ€™d raise the motivation to hack the client even higher than it already is<sup id="fnote3"><a href="#Footnotes">3</a></sup>. For our games, this risk is too high and we fall back to requiring an authoritative server.<br></p><p>A system where movements and weapon effects are predicted client-side is a very workable system. For instance, this is the system that the Quake3 engine supports. One of the problems with this system is that you still have to have a feel for your latency to determine how to lead your targets (for instant hit weapons). In other words, although you get to hear the weapons firing immediately, and your position is totally up-to-date, the results of your shots are still subject to latency. For example, if you are aiming at a player running perpendicular to your view and you have 100 milliseconds of latency and the player is running at 500 units per second, then youâ€™ll need to aim 50 units in front of the target to hit the target with an instant hit weapon. The greater the latency, the greater the lead targeting needed. Getting a â€œfeelâ€ for your latency is difficult. Quake3 attempted to mitigate this by playing a brief tone whenever you received confirmation of your hits. That way, you could figure out how far to lead by firing your weapons in rapid succession and adjusting your leading amount until you started to hear a steady stream of tones. Obviously, with sufficient latency and an opponent who is actively dodging, it is quite difficult to get enough feedback to focus in on the opponent in a consistent fashion. If your latency is fluctuating, it can be even harder.<br></p><br><h2 id="Display_of_Targets">Display of Targets</h2><br><p>Another important aspect influencing how a user perceives the responsiveness of the world is the mechanism for determining, on the client, where to render the other players. The two most basic mechanisms for determining where to display objects are extrapolation and interpolation<sup id="fnote4"><a href="#Footnotes">4</a></sup>.<br></p><p>For extrapolation, the other player/object is simulated forward in time from the last known spot, direction, and velocity in more or less a ballistic manner. Thus, if you are 100 milliseconds lagged, and the last update you received was that (as above) the other player was running 500 units per second perpendicular to your view, then the client could assume that in â€œreal timeâ€ the player has moved 50 units straight ahead from that last known position. The client could then just draw the player at that extrapolated position and the local player could still more or less aim right at the other player.<br></p><p>The biggest drawback of using extrapolation is that playerâ€™s movements are not very ballistic, but instead are very non-deterministic and subject to high jerk<sup id="fnote5"><a href="#Footnotes">5</a></sup>. Layer on top of this the unrealistic player physics models that most FPS games use, where playerâ€™s can turn instantaneously and apply unrealistic forces to create huge accelerations at arbitrary angles and youâ€™ll see that the extrapolation is quite often incorrect. The developer can mitigate the error by limiting the extrapolation time to a reasonable value (QuakeWorld, for instance, limited extrapolation to 100 milliseconds). This limitation helps because, once the true player position is finally received, there will be a limited amount of corrective warping. In a world where most players still have greater than 150 milliseconds of latency, the player must still lead other players in order to hit them. If those players are â€œwarpingâ€ to new spots because of extrapolation errors, then the gameplay suffers nonetheless.<br></p><p>The other method for determining where to display objects and players is interpolation. Interpolation can be viewed as always moving objects somewhat in the past with respect to the last valid position received for the object. For instance, if the server is sending 10 updates per second (exactly) of the world state, then we might impose 100 milliseconds of interpolation delay in our rendering. Then, as we render frames, we interpolate the position of the object between the last updated position and the position one update before that (alternatively, the last render position) over that 100 milliseconds. As the object just gets to the last updated position, we receive a new update from the server (since 10 updates per second means that the updates come in every 100 milliseconds) we can start moving toward this new position over the next 100 milliseconds.<br></p><p>If one of the update packets fails to arrive, then there are two choices: We can start extrapolating the player position as noted above (with the large potential errors noted) or we can simply have the player rest at the position in the last update until a new update arrives (causing the playerâ€™s movement to stutter).<br></p><p>The general algorithm for this type of interpolation is as follows:<br></p><br><ol><br><li>Each update contains the server time stamp for when it was generated<sup id="fnote6"><a href="#Footnotes">6</a></sup><br></li><br><li>From the current client time, the client computes a target time by subtracting the interpolation time delta (100 ms)<br></li><br><li>If the target time is in between the timestamp of the last update and the one before that, then those timestamps determine what fraction of the time gap has passed.<br></li><br><li>This fraction is used to interpolate any values (e.g., position and angles).<br></li><br></ol><br><p>In essence, you can think of interpolation, in the above example, as buffering an additional 100 milliseconds of data on the client. The other players, therefore, are drawn where they were at a point in the past that is equal to your exact latency plus the amount of time over which you are interpolating. To deal with the occasional dropped packet, we could set the interpolation time as 200 milliseconds instead of 100 milliseconds. This would (again assuming 10 updates per second from the server) allow us to entirely miss one update and still have the player interpolating toward a valid position, often moving through this interpolation without a hitch. Of course, interpolating for more time is a tradeoff, because it is trading additional latency (making the interpolated player harder to hit) for visual smoothness.<br></p><p>In addition, the above type of interpolation (where the client tracks only the last two updates and is always moving directly toward the most recent update) requires a fixed time interval between server updates. The method also suffers from visual quality issues that are difficult to resolve. The visual quality issue is as follows. Imagine that the object being interpolated is a bouncing ball (which actually accurately describes some of our players). At the extremes, the ball is either high in the air or hitting the pavement. However, on average, the ball is somewhere in between. If we only interpolate to the last position, it is very likely that this position is not on the ground or at the high point. The bounciness of the ball is â€œflattenedâ€ out and it never seems to hit the ground. This is a classical sampling problem and can be alleviated by sampling the world state more frequently. However, we are still quite likely never actually to have an interpolation target state be at the ground or at the high point and this will still flatten out the positions.<br></p><p>In addition, because different users have different connections, forcing updates to occur at a lockstep like 10 updates per second is forcing a lowest common denominator on users unnecessarily. In Half-Life, we allow the user to ask for as many updates per second as he or she wants (within limit). Thus, a user with a fast connection could receive 50 updates per second if the user wanted. By default, Half-Life sends 20 updates per second to each player the Half-Life client interpolates players (and many other objects) over a period of 100 milliseconds.<sup id="fnote7"><a href="#Footnotes">7</a></sup><br></p><p>To avoid the flattening of the bouncing ball problem, we employ a different algorithm for interpolation. In this method, we keep a more complete â€œposition historyâ€ for each object that might be interpolated.<br></p><p>The position history is the timestamp and origin and angles (and could include any other data we want to interpolate) for the object. Each update we receive from the server creates a new position history entry, including timestamp and origin/angles for that timestamp. To interpolate, we compute the target time as above, but then we search backward through the history of positions looking for a pair of updates that straddle the target time. We then use these to interpolate and compute the final position for that frame. This allows us to smoothly follow the curve that completely includes all of our sample points. If we are running at a higher framerate than the incoming update rate, we are almost assured of smoothly moving through the sample points, thereby minimizing (but not eliminating, of course, since the pure sampling rate of the world updates is the limiting factor) the flattening problem described above.<br></p><p>The only consideration we have to layer on top of either interpolation scheme is some way to determine that an object has been forcibly teleported, rather than just moving really quickly. Otherwise we might â€œsmoothlyâ€ move the object over great distances, causing the object to look like itâ€™s traveling way too fast. We can either set a flag in the update that says, â€œdonâ€™t interpolateâ€ or â€œclear out the position history,â€ or we can determine if the distance between the origin and one update and another is too big, and thereby presumed to be a teleportation/warp. In that case, the solution is probably to just move the object to the latest know position and start interpolating from there.<br></p><br><h2 id="Lag_Compensation">Lag Compensation</h2><br><p>Understanding interpolation is important in designing for lag compensation because interpolation is another type of latency in a userâ€™s experience. To the extent that a player is looking at other objects that have been interpolated, then the amount of interpolation must be taken into consideration in computing, on the server, whether the playerâ€™s aim was true.<br></p><p>Lag compensation is a method of normalizing server-side the state of the world for each player as that playerâ€™s user commands are executed. You can think of lag compensation as taking a step back in time, on the server, and looking at the state of the world at the exact instant that the user performed some action. The algorithm works as follows:<br></p><br><ol><br><li>Before executing a playerâ€™s current user command, the server:<br><ol><br><li>Computes a fairly accurate latency for the player<br></li><br><li>Searches the server history (for the current player) for the world update that was sent to the player and received by the player just before the player would have issued the movement command<br></li><br><li>From that update (and the one following it based on the exact target time being used), for each player in the update, move the other players backwards in time to exactly where they were when the current playerâ€™s user command was created. This moving backwards must account for both connection latency and the interpolation amount<sup id="fnote8"><a href="#Footnotes">8</a></sup> the client was using that frame.<br></li><br></ol><br></li><br><li>Allow the user command to execute (including any weapon firing commands, etc., that will run ray casts against all of the other players in their â€œoldâ€ positions).<br></li><br><li>Move all of the moved/time-warped players back to their correct/current positions<br></li><br></ol><br><p>Note that in the step where we move the player backwards in time, this might actually require forcing additional state info backwards, too (for instance, whether the player was alive or dead or whether the player was ducking). The end result of lag compensation is that each local client is able to directly aim at other players without having to worry about leading his or her target in order to score a hit. Of course, this behavior is a game design tradeoff.<br></p><br><h2 id="Game_Design_Implications_of_Lag_Compensation">Game Design Implications of Lag Compensation</h2><br><p>The introduction of lag compensation allows for each player to run on his or her own clock with no apparent latency. In this respect, it is important to understand that certain paradoxes or inconsistencies can occur. Of course, the old system with the authoritative server and â€œdumbâ€ or simple clients had itâ€™s own paradoxes. In the end, making this tradeoff is a game design decision. For Half-Life, we believe deciding in favor of lag compensation was a justified game design decision.<br></p><p>The first problem of the old system was that you had to lead your target by some amount that was related to your latency to the server. Aiming directly at another player and pressing the fire button was almost assured to miss that player. The inconsistency here is that aiming is just not realistic and that the player controls have non-predictable responsiveness.<br></p><p>With lag compensation, the inconsistencies are different. For most players, all they have to do is acquire some aiming skill and they can become proficient (you still have to be able to aim). Lag compensation allows the player to aim directly at his or her target and press the fire button (for instant hit weapons<sup id="fnote9"><a href="#Footnotes">9</a></sup>). The inconsistencies that sometimes occur, however, are from the points of view of the players being fired upon.<br></p><p>For instance, if a highly lagged player shoots at a less lagged player and scores a hit, it can appear to the less lagged player that the lagged player has somehow â€œshot around a cornerâ€<sup id="fnote10"><a href="#Footnotes">10</a></sup>. In this case, the lower lag player may have darted around a corner. But the lagged player is seeing everything in the past. To the lagged player, s/he has a direct line of sight to the other player. The player lines up the crosshairs and presses the fire button. In the meantime, the low lag player has run around a corner and maybe even crouched behind a crate. If the high lag player is sufficiently lagged, say 500 milliseconds or so, this scenario is quite possible. Then, when the lagged playerâ€™s user command arrives at the server, the hiding player is transported backward in time and is hit. This is the extreme case, and in this case, the low ping player says that s/he was shot from around the corner. However, from the lagged playerâ€™s point of view, they lined up their crosshairs on the other player and fired a direct hit. From a game design point of view, the decision for us was easy: let each individual player have completely responsive interaction with the world and his or her weapons.<br></p><p>In addition, the inconsistency described above is much less pronounced in normal combat situations. For first-person shooters, there are two more typical cases. First, consider two players running straight at each other pressing the fire button. In this case, itâ€™s quite likely that lag compensation will just move the other player backwards along the same line as his or her movement. The person being shot will be looking straight at his attacker and no â€œbullets bending around cornersâ€ feeling will be present.<br></p><p>The next example is two players, one aiming at the other while the other dashes in front perpendicular to the first player. In this case, the paradox is minimized for a wholly different reason. The player who is dashing across the line of sight of the shooter probably has (in first-person shooters at least) a field of view of 90 degrees or less. In essence, the runner canâ€™t see where the other player is aiming. Therefore, getting shot isnâ€™t going to be surprising or feel wrong (you get what you deserve for running around in the open like a maniac). Of course, if you have a tank game, or a game where the player can run one direction, and look another, then this scenario is less clear-cut, since you might see the other player aiming in a slightly incorrect direction.<br></p><br><h2 id="Conclusion">Conclusion</h2><br><p>Lag compensation is a tool to ameliorate the effects of latency on todayâ€™s action games. The decision of whether to implement such a system rests with the game designer since the decision directly changes the feel of the game. For Half-Life, Team Fortress and Counter Strike, the benefits of lag compensation easily outweighed the inconsistencies noted above.<br></p><br><h2 id="Footnotes">Footnotes</h2><br><ol><br><li> In the Half-Life engine, it is possible to ask the client-side prediction algorithm to account for some, but not all, of the latency in performing prediction. The user could control the amount of prediction by changing the value of the â€œpushlatencyâ€ console variable to the engine. This variable is a negative number indicating the maximum number of milliseconds of prediction to perform. If the number is greater (in the negative) than the userâ€™s current latency, then full prediction up to the current time occurs. In this case, the user feels zero latency in his or her movements.  Based upon some erroneous superstition in the community, many users insisted that setting pushlatency to minus one-half of the current average latency was the proper setting. Of course, this would still leave the playerâ€™s movements lagged (often described as if you are moving around on ice skates) by half of the userâ€™s latency. All of this confusion has brought us to the conclusion that full prediction should occur all of the time and that the pushlatency variable should be removed from the Half-Life engine. <a href="#fnote1">(Return)</a><br></li><br><li> <a rel="noopener" class="external free" href="http://www.quakeforge.net/files/q1source.zip" target="_blank">http://www.quakeforge.net/files/q1source.zip</a> <a href="#fnote2">(Return)</a><br></li><br><li> A discussion of cheating and what developers can do to deter it is beyond the scope of this paper. <a href="#fnote3">(Return)</a><br></li><br><li> Though hybrids and corrective methods are also possible. <a href="#fnote4">(Return)</a><br></li><br><li> â€œJerkâ€ is a measure of how fast accelerative forces are changing. <a href="#fnote5">(Return)</a><br></li><br><li> It is assumed in this paper that the client clock is directly synchronized to the server clock modulo the latency of the connection. In other words, the server sends the client, in each update, the value of the serverâ€™s clock and the client adopts that value as its clock. Thus, the server and client clocks will always be matched, with the client running the same timing somewhat in the past (the amount in the past is equal to the clientâ€™s current latency). Smoothing out discrepancies in the client clock can be solved in various ways. <a href="#fnote6">(Return)</a><br></li><br><li> The time spacing of these updates is not necessarily fixed. The reason why is that during high activity periods of the game (especially for users with lower bandwidth connections), itâ€™s quite possible that the game will want to send you more data than your connection can accommodate. If we were on a fixed update interval, then you might have to wait an entire additional interval before the next packet would be sent to the client. However, this doesnâ€™t match available bandwidth effectively. Instead, the server, after sending every packet to a player, determines when the next packet can be sent. This is a function of the userâ€™s bandwidth or â€œrateâ€ setting and the number of updates requested per second. If the user asks for 20 updates per second, then it will be at least 50 milliseconds before the next update packet can be sent. If the bandwidth choke is active (and the server is sufficiently high framerate), it could be 61, etc., milliseconds before the next packet gets sent.  Thus, Half-Life packets can be somewhat arbitrarily spaced. The simple move to latest goal interpolation schemes donâ€™t behave as well (think of the old anchor point for movement as being variable) under these conditions as the position history interpolation method (described below). <a href="#fnote7">(Return)</a><br></li><br><li> Which Half-Life encodes in the lerp_msec field of the usercmd_t structure described previously. <a href="#fnote8">(Return)</a><br></li><br><li> For weapons that fire projectiles, lag compensation is more problematic. For instance, if the projectile lives autonomously on the server, then what time space should the projectile live in? Does every other player need to be â€œmoved backwardâ€ every time the projectile is ready to be simulated and moved by the server? If so, how far backward in time should the other players be moved? These are interesting questions to consider. In Half-Life, we avoided them; we simply donâ€™t lag compensate projectile objects (thatâ€™s not to say that we donâ€™t predict the sound of you firing the projectile on the client, just that the actual projectile is not lag compensated in any way).  <a href="#fnote9">(Return)</a><br></li><br><li> This is the phrase our user community has adopted to describe this inconsistency. <a href="#fnote10">(Return)</a><br></li><br></ol><br><br><br><h1 id="ä¸­è‹±å¯¹ç…§">ä¸­è‹±å¯¹ç…§</h1><br><br><a href="http://blog.csdn.net/buck84/article/details/8235159" target="_blank" rel="noopener">è¯‘æ–‡å‡ºå¤„</a><br><br><br><span style="font-size:18px">Overview<br><br></span><p></p><br><h2 id="ç»¼è¿°">ç»¼è¿°</h2><br><br><br>Designing first-person action games for Internet play is a challenging process. Having robust on-line gameplay in your action title, however, is becoming essential to the success and longevity of the title. In addition, the PC space is well known for requiring<br> developers to support a wide variety of customer setups. Often, customers are running on less than state-of-the-art hardware. The same holds true for their network connections.<br><p></p><br><p><strong>ç¬¬ä¸€äººç§°è§’è‰²ç½‘ç»œæ¸¸æˆçš„è®¾è®¡æ˜¯ä¸€é¡¹å¾ˆæœ‰æŒ‘æˆ˜æ€§çš„å·¥ä½œã€‚ç½‘ç»œç¯å¢ƒä¸‹çš„å¥å£®æ€§ï¼Œæ˜¯åŠ¨ä½œæ¸¸æˆèƒ½å¦æˆåŠŸçš„ä¸€ä¸ªé‡è¦å› ç´ ã€‚å¦å¤–ï¼ŒPCä¸Šé¢çš„å¼€å‘è€…éœ€è¦è€ƒè™‘åˆ°ç©å®¶å±‚æ¬¡ä¸é½çš„æœºå™¨é…ç½®ä»¥åŠç½‘ç»œçŠ¶å†µï¼Œå¾ˆå¤šç”¨æˆ·çš„ç¡¬ä»¶é…ç½®è·Ÿç½‘ç»œè·Ÿå½“å‰æœ€å¥½çš„é…ç½®è·Ÿç½‘ç»œæœ‰ä¸€å®šå·®è·ã€‚</strong></p><br><p><br><br>While broadband has been held out as a panacea for all of the current woes of on-line gaming, broadband is not a simple solution allowing developers to ignore the implications of latency and other network factors in game designs. It will be some time before<br> broadband truly becomes adopted the United States, and much longer before it can be assumed to exist for your clients in the rest of the world. In addition, there are a lot of poor broadband solutions, where users may occasionally have high bandwidth, but<br> more often than not also have significant latency and packet loss in their connections.</p><br><p><strong>å®½å¸¦ç½‘ç»œçš„å‡ºç°æœ‰åˆ©äºåœ¨çº¿æ¸¸æˆå¼€å‘ï¼Œä½†æ˜¯å¼€å‘è€…è¿˜æ˜¯éœ€è¦è€ƒè™‘ç½‘ç»œå»¶è¿Ÿå’Œå…¶å®ƒç½‘ç»œç‰¹æ€§ã€‚è€Œä¸”å®½å¸¦ç½‘ç»œåœ¨ç¾å›½è¢«å¹¿æ³›é‡‡ç”¨è¿˜éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œåœ¨ä¸–ç•Œä¸Šå…¶å®ƒå›½å®¶å¯èƒ½éœ€è¦æ›´é•¿çš„ä¸€æ®µæ—¶é—´ã€‚å¦å¤–ï¼Œå¾ˆå¤šå®½å¸¦ç½‘ç»œè´¨é‡å¾ˆå·®ï¼Œç”¨æˆ·è™½ç„¶å¶å°”èƒ½å¤Ÿäº«å—åˆ°é«˜å¸¦å®½ï¼Œä½†æ›´å¤šçš„æ—¶å€™ä»–ä»¬ä¸å¾—ä¸é¢å¯¹é«˜å»¶è¿Ÿå’Œé«˜ä¸¢åŒ…ç‡ã€‚</strong><br><br></p><br><p><br><br>Your game must behave well in this world. This discussion will give you a sense of some of the tradeoffs required to deliver a cutting-edge action experience on the Internet. The discussion will provide some background on how client / server architectures work<br> in many on-line action games. In addition, the discussion will show how predictive modeling can be used to mask the effects of latency. Finally, the discussion will describe a specific mechanism, lag compensation, for allowing the game to compensate for connection<br> quality.</p><br><p><strong>æˆ‘ä»¬åº”è¯¥æä¾›ç»™ç©å®¶è‰¯å¥½çš„æ¸¸æˆã€‚æœ¬ç¯‡æ–‡ç« è®¨è®ºäº†å¦‚ä½•æä¾›ç»™ç©å®¶é¡¶å°–çš„æ“ä½œä½“éªŒï¼›ä»‹ç»äº†å¾ˆå¤šåœ¨çº¿åŠ¨ä½œæ¸¸æˆä¸­é‡‡ç”¨çš„C/Sæ¶æ„èƒŒæ™¯ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜è®¨è®ºäº†å¦‚ä½•é€šè¿‡ä¸€ä¸ªé¢„æµ‹æ¨¡å‹æ¥æ©é¥°å»¶è¿Ÿå¸¦æ¥çš„å½±å“ã€‚æ–‡ç« çš„æœ€åæè¿°äº†ä¸€ä¸ªå«åšå»¶è¿Ÿè¡¥å¿çš„æœºåˆ¶ï¼Œå¼¥è¡¥äº†å› ä¸ºç½‘ç»œè´¨é‡ä¸å¥½å¸¦æ¥çš„è´Ÿé¢å½±å“</strong><br><br></p><br><p><br><br><span style="font-size:18px">Basic Architecture of a Client / Server Game</span></p><br><h2 id="C/Sæ¸¸æˆçš„åŸºæœ¬æ¶æ„">C/Sæ¸¸æˆçš„åŸºæœ¬æ¶æ„</h2><br><p><br><br><br><br>Most action games played on the net today are modified client / server games. Games such as Half-Life, including its mods such as Counter-Strike and Team Fortress Classic, operate on such a system, as do games based on the Quake3 engine and the Unreal Tournament<br> engine. In these games, there is a single, authoritative server that is responsible for running the main game logic. To this are connected one or more &quot;dumb&quot; clients. These clients, initially, were nothing more than a way for the user input to be sampled and<br> forwarded to the server for execution. The server would execute the input commands, move around other objects, and then send back to the client a list of objects to render. Of course, the real world system has more components to it, but the simplified breakdown<br> is useful for thinking about prediction and lag compensation.</p><br><p><strong>ç½‘ç»œä¸Šå¯ç©çš„å¤§éƒ¨åˆ†åŠ¨ä½œæ¸¸æˆéƒ½æ˜¯C/Sç»“æ„æ¸¸æˆåŸºç¡€ä¸Šä¿®æ”¹å®Œæˆçš„ï¼Œæ¯”å¦‚åŠæ¡å‘½ä»¥åŠå…¶ä¿®æ”¹ç‰ˆåæç²¾è‹±ã€å†›å›¢è¦å¡ï¼Œä»¥åŠä¸€äº›åŸºäºquake3å¼•æ“å’Œè™šå¹»å¼•æ“çš„æ¸¸æˆã€‚è¿™ç±»æ¸¸æˆéƒ½æœ‰ä¸€ä¸ªç”¨æ¥æ‰§è¡Œæ¸¸æˆé€»è¾‘çš„æœåŠ¡å™¨ä»¥åŠè¿æ¥åˆ°è¿™ä¸ªæœåŠ¡å™¨çš„å¤šä¸ªå®¢æˆ·ç«¯ã€‚å®¢æˆ·ç«¯ä»…ä»…æ˜¯ç”¨æ¥æ¥æ”¶ç©å®¶çš„æ“ä½œå¹¶å‘ç»™æœåŠ¡å™¨ï¼ŒæœåŠ¡å™¨å¯¹è¿™äº›æ“ä½œä½œå‡ºå“åº”ï¼Œç§»åŠ¨ç©å®¶å‘¨å›´ç‰©ä½“ï¼Œå¹¶å°†æ¸¸æˆä¸–ç•Œçš„ä¿¡æ¯å‘ç»™å®¢æˆ·ç«¯æ˜¾ç¤ºå‡ºæ¥ã€‚å½“ç„¶ä¸–ç•Œçš„æ¸¸æˆç³»ç»Ÿæœ‰æ›´å¤šç»„ä»¶ï¼Œæˆ‘ä»¬è¿™æ ·ç®€åŒ–æœ‰åˆ©äºåˆ†æé¢„æµ‹å’Œå»¶è¿Ÿè¡¥å¿ã€‚</strong><br><br>With this in mind, the typical client / server game engine architecture generally looks like this:</p><br><p><strong>åŸºäºè¿™ç§è€ƒè™‘ï¼Œå…¸å‹çš„C/Sæ¸¸æˆå¼•æ“é€šå¸¸çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„</strong><br><br><br><br>For this discussion, all of the messaging and coordination needed to start up the connection between client and server is omitted. The clientâ€™s frame loop looks something like the following:</p><br><p><strong>ä¸ºäº†ä¾¿äºè®¨è®ºï¼Œæˆ‘ä»¬å‡å®šå®¢æˆ·ç«¯è·ŸæœåŠ¡å™¨ä¹‹é—´å·²ç»å»ºç«‹è¿æ¥ï¼›å®¢æˆ·ç«¯çš„æ¯ä¸€å¸§å¾ªç¯å¦‚ä¸‹ï¼š</strong><br><br>1.Sample clock to find start time</p><br><p><strong>1.è·å–å¸§å¼€å§‹æ—¶é—´</strong></p><br><p>2.Sample user input (mouse, keyboard, joystick)</p><br><p><strong>2.é‡‡é›†ç”¨æˆ·è¾“å…¥</strong><br><br>3.Package up and send movement command using simulation time</p><br><p><strong>3.æ ¹æ®æ¨¡æ‹Ÿæ—¶é—´å°†ç§»åŠ¨å‘½ä»¤æ‰“åŒ…å‘é€ç»™æœåŠ¡å™¨</strong><br><br>4.Read any packets from the server from the network system</p><br><p><strong>4.è·å–å¤„ç†æœåŠ¡å™¨ä¼ è¿‡æ¥çš„æ•°æ®åŒ…</strong><br><br>5.Use packets to determine visible objects and their state</p><br><p><strong>5.æ ¹æ®æœåŠ¡å™¨æ•°æ®åŒ…çš„å†…å®¹å†³å®šå¯è§ç‰©ä½“åŠå…¶çŠ¶æ€</strong><br><br>6.Render Scene</p><br><p><strong>6.æ¸²æŸ“åœºæ™¯</strong><br><br>7.Sample clock to find end time</p><br><p><strong>7.è·å–å¸§ç»“æŸæ—¶é—´</strong><br><br>8.End time minus start time is the simulation time for the next frame</p><br><p><strong>8.ç»“æŸæ—¶é—´å‡å»å¼€å§‹æ—¶é—´å°±æ˜¯ä¸‹ä¸€å¸§çš„æ¨¡æ‹Ÿæ—¶é—´</strong><br><br>Each time the client makes a full pass through this loop, the &quot;frametime&quot; is used for determining how much simulation is needed on the next frame. If your framerate is totally constant then frametime will be a correct measure. Otherwise, the frametimes will<br> be incorrect, but there isnâ€™t really a solution to this (unless you could deterministically figure out exactly how long it was going to take to run the next frame loop iteration before running itâ€¦).</p><br><p><strong>å®¢æˆ·ç«¯æ¯å®Œæˆä¸€ä¸ªå¸§å¾ªç¯ï¼Œå°±ç”¨â€œframetimeâ€æ¥å†³å®šä¸‹ä¸€å¸§éœ€è¦å¤šå°‘æ—¶é—´ï¼Œå¦‚æœå¸§ç‡æ’å®šï¼Œâ€œframetimeâ€å°±æ˜¯å‡†ç¡®çš„ï¼Œå¦åˆ™å°±æ²¡åŠæ³•è·å¾—å‡†ç¡®çš„â€œframetimeâ€ï¼ˆå› ä¸ºåœ¨æ¯ä¸€å¸§å¼€å§‹ä¹‹å‰ä½ ä¸å¯èƒ½çŸ¥é“è¿™ä¸€å¸§éœ€è¦å¤šé•¿æ—¶é—´ï¼‰</strong><br><br></p><br><p><br><br>The server has a somewhat similar loop:</p><br><p><strong>æœåŠ¡å™¨çš„å¾ªç¯å¤§åŒå°å¼‚ï¼š</strong><br><br>1.Sample clock to find start time<br><br><span style="font-weight:bold">1.è·å–å¸§å¼€å§‹æ—¶é—´</span><br><br>2.Read client user input messages from network</p><br><p><strong>2.è¯»å–å®¢æˆ·ç«¯å‘è¿‡æ¥çš„æ“ä½œä¿¡æ¯</strong><br><br>3.Execute client user input messages</p><br><p><strong>3.æ ¹æ®å®¢æˆ·ç«¯æ“ä½œæ‰§è¡Œé€»è¾‘è¿ç®—</strong><br><br>4.Simulate server-controlled objects using simulation time from last full pass</p><br><p><strong>4.é‡‡ç”¨ä¸Šä¸€ä¸ªå¾ªç¯å¾—åˆ°çš„æ¨¡æ‹Ÿæ—¶é—´æ¥æ¨¡æ‹ŸæœåŠ¡å™¨æ§åˆ¶çš„ç‰©ä½“ç§»åŠ¨çŠ¶æ€</strong><br><br>5.For each connected client, package up visible objects/world state and send to client</p><br><p><strong>5.å¯¹æ¯ä¸€ä¸ªè¿æ¥çš„å®¢æˆ·ç«¯ï¼Œå‘é€æ‰“åŒ…ç›¸åº”çš„ç‰©ä½“/ä¸–ç•ŒçŠ¶æ€</strong><br><br>6.Sample clock to find end time</p><br><p><span style="font-weight:bold">6.è·å–å¸§ç»“æŸæ—¶é—´</span><br><br>7.End time minus start time is the simulation time for the next frame</p><br><p><span style="font-weight:bold">7.ç»“æŸæ—¶é—´å‡å»å¼€å§‹æ—¶é—´å°±æ˜¯ä¸‹ä¸€å¸§çš„æ¨¡æ‹Ÿæ—¶é—´</span><br><br>In this model, non-player objects run purely on the server, while player objects drive their movements based on incoming packets. Of course, this is not the only possible way to accomplish this task, but it does make sense.</p><br><p><strong>åœ¨è¿™ä¸ªæ¨¡å‹ä¸­ï¼Œéç©å®¶ç‰©ä½“å®Œå…¨ç”±æœåŠ¡å™¨æ§åˆ¶å…¶çŠ¶æ€ï¼Œæ¯ä¸ªç©å®¶æ ¹æ®æœåŠ¡å™¨å‘è¿‡æ¥çš„æ•°æ®åŒ…æ§åˆ¶è‡ªå·±çš„ç§»åŠ¨ã€‚è¿™æ˜¯ä¸€ç§å¾ˆè‡ªç„¶çš„æ–¹æ³•ï¼Œå½“ç„¶è¿˜æœ‰å…¶å®ƒçš„æ–¹æ³•ä¹Ÿå¯ä»¥å®Œæˆè¿™ä¸ªåŠŸèƒ½ã€‚</strong></p><br><p><strong><br><br></strong></p><br><p><strong><br><br></strong>Contents of the User Input messages</p><br><p></p><br><h2 id="ç”¨æˆ·æ¶ˆæ¯çš„å†…å®¹">ç”¨æˆ·æ¶ˆæ¯çš„å†…å®¹</h2><br>In Half-Life engine games, the user input message format is quite simple and is encapsulated in a data structure containing just a few essential fields:<br><p></p><br><p><strong>åŸºäºhalf-lifeå¼•æ“çš„æ¸¸æˆç”¨æˆ·æ¶ˆæ¯éƒ½å¾ˆç®€å•ï¼Œåªéœ€è¦å°è£…åœ¨ä¸€ä¸ªåŒ…å«å‡ ä¸ªå…³é”®æˆå‘˜çš„ç»“æ„ä¸­ï¼š</strong></p><br><p>typedef struct usercmd_s<br><br>{<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// Interpolation time on client<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>short<span style="white-space:pre"></span>lerp_msec; &nbsp;&nbsp;<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// Duration in ms of command<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>byte<span style="white-space:pre"></span>msec; &nbsp; &nbsp; &nbsp;<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// Command view angles.<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>vec3_t<span style="white-space:pre"></span>viewangles; &nbsp;&nbsp;<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// intended velocities<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// Forward velocity.<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>float<span style="white-space:pre"></span>forwardmove; &nbsp;<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// Sideways velocity.<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>float<span style="white-space:pre"></span>sidemove; &nbsp; &nbsp;<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// Upward velocity.<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>float<span style="white-space:pre"></span>upmove; &nbsp;&nbsp;<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// Attack buttons<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>unsigned short buttons;&nbsp;<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>//<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>// Additional fields omittedâ€¦<br><br><span style="white-space:pre"></span><span style="white-space:pre"></span>//<br><br>} usercmd_t;<br><br>The critical fields here are the msec, viewangles, forward, side, and upmove, and buttons fields. The msec field corresponds to the number of milliseconds of simulation that the command corresponds to (itâ€™s the frametime). The viewangles field is a vector representing<br> the direction the player was looking during the frame. The forward, side, and upmove fields are the impulses determined by examining the keyboard, mouse, and joystick to see if any movement keys were held down. Finally, the buttons field is just a bit field<br> with one or more bits set for each button that is being held down.</p><br><p><strong>ç»“æ„ä¸­æœ€å…³é”®çš„å˜é‡æ—¶msec,viewangles,forward,side,upmoveå’Œbuttonsã€‚msecè¡¨ç¤ºè¿™ä¸ªå‘½ä»¤æ‰§è¡Œå¯¹åº”çš„æ¯«ç§’æ•°ï¼ˆä¹Ÿå°±æ˜¯ä¸Šé¢æåˆ°çš„â€œframetimeâ€ï¼‰ã€‚viewanglesæ˜¯ä¸€ä¸ªä¸‰ç»´å‘é‡ï¼Œè¡¨ç¤ºç©å®¶çš„æœå‘ã€‚forward,sideå’Œupmoveè¡¨ç¤ºç©å®¶æ˜¯å¦é€šè¿‡é”®ç›˜ã€é¼ æ ‡æˆ–æ§åˆ¶æ†æ§åˆ¶ç§»åŠ¨ã€‚æœ€åï¼Œbuttonsè¿™ä¸ªå­—æ®µåŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªæ¯”ç‰¹ï¼Œæ ‡å¿—ç©å®¶æ˜¯å¦æŒ‰ç€æŸäº›æŒ‰é”®ã€‚</strong></p><br><p><strong><br><br></strong>Using the above data structures and client / server architecture, the core of the simulation is as follows. First, the client creates and sends a user command to the server. The server then executes the user command and sends updated positions of everything<br> back to client. Finally, the client renders the scene with all of these objects. This core, though quite simple, does not react well under real world situations, where users can experience significant amounts of latency in their Internet connections. The main<br> problem is that the client truly is &quot;dumb&quot; and all it does is the simple task of sampling movement inputs and waiting for the server to tell it the results. If the client has 500 milliseconds of latency in its connection to the server, then it will take 500<br> milliseconds for any client actions to be acknowledged by the server and for the results to be perceptible on the client. While this round trip delay may be acceptable on a Local Area Network (LAN), it is not acceptable on the Internet.</p><br><p><strong>åŸºäºC/Sæ¶æ„çš„æ¸¸æˆé‡‡ç”¨ä»¥ä¸Šæ•°æ®ç»“æ„è¿è¡Œå¦‚ä¸‹ï¼šå®¢æˆ·ç«¯åˆ›å»ºå‘½ä»¤å¹¶å‘é€åˆ°æœåŠ¡å™¨ï¼ŒæœåŠ¡å™¨å“åº”è¿™äº›å‘½ä»¤å¹¶æŠŠæ›´æ–°äº†çš„ä¸–ç•Œå’Œç‰©ä½“ä½ç½®ä¿¡æ¯å‘å›å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯æ”¶åˆ°ä»¥åè¿›è¡Œæ¸²æŸ“ã€‚è¿™ç§æ–¹å¼éå¸¸ç®€å•ï¼Œä½†æ˜¯åœ¨å®é™…åº”ç”¨ä¸­æ•ˆæœå·®å¼ºäººæ„ï¼Œç”¨æˆ·ä¼šæ„Ÿè§‰åˆ°ç½‘ç»œè¿æ¥å¸¦æ¥çš„æ˜æ˜¾å»¶è¿Ÿã€‚è¿™ä¸»è¦æ˜¯ç”±äºå®¢æˆ·ç«¯å®Œå…¨æ²¡æœ‰é€»è¾‘æ“ä½œï¼Œå‘å‡ºæ¶ˆæ¯ä»¥åå°±ç­‰å¾…æœåŠ¡å™¨å“åº”ã€‚å¦‚æœå®¢æˆ·ç«¯è·ŸæœåŠ¡å™¨æœ‰500msçš„å»¶è¿Ÿï¼Œå®¢æˆ·ç«¯æ‰§è¡Œäº†æ“ä½œåˆ°çœ‹åˆ°æ“ä½œçš„ç»“æœå°±éœ€è¦500msï¼Œè¿™ç§å»¶è¿Ÿåœ¨å±€åŸŸç½‘é€šå¸¸å¯ä»¥æ¥å—ï¼ˆå› ä¸ºé€šå¸¸å»¶è¿Ÿæ¯”è¾ƒå°ï¼‰ï¼Œä½†åœ¨å› ç‰¹ç½‘ä¸Šæ˜¯æ²¡æ³•æ¥å—çš„</strong></p><br><p><br><br>Client Side Prediction</p><br><p></p><br><h2 id="å®¢æˆ·ç«¯é¢„æµ‹">å®¢æˆ·ç«¯é¢„æµ‹</h2><br><br><br>One method for ameliorating this problem is to perform the clientâ€™s movement locally and just assume, temporarily, that the server will accept and acknowledge the client commands directly. This method is labeled as client-side prediction.<br><p></p><br><p><strong>æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥æ”¹å–„è¿™ç§æƒ…å†µï¼šå®¢æˆ·ç«¯æœ¬åœ°å³æ—¶æ‰§è¡Œç§»åŠ¨æ“ä½œï¼Œå‡å®šæœåŠ¡å™¨å³æ—¶é€šçŸ¥å®¢æˆ·ç«¯å¯ä»¥æ‰§è¡Œæ“ä½œï¼Œè¿™ç§æ–¹æ³•å¯ä»¥ç§°ä¸ºå®¢æˆ·ç«¯é¢„æµ‹ã€‚</strong></p><br><p><strong><br><br></strong>Client-side prediction of movements requires us to let go of the &quot;dumb&quot; or minimal client principle. Thatâ€™s not to say that the client is fully in control of its simulation, as in a peer-to-peer game with no central server. There still is an authoritative<br> server running the simulation just as noted above. Having an authoritative server means that even if the client simulates different results than the server, the serverâ€™s results will eventually correct the clientâ€™s incorrect simulation. Because of the latency<br> in the connection, the correction might not occur until a full round tripâ€™s worth of time has passed. The downside is that this can cause a very perceptible shift in the playerâ€™s position due to the fixing up of the prediction error that occurred in the past.</p><br><p><strong>é‡‡ç”¨å®¢æˆ·ç«¯è¿åŠ¨é¢„æµ‹ä»¥åï¼Œå®¢æˆ·ç«¯å°±ä¸å†æ˜¯ä¸€ä¸ªâ€œå°å‹å®¢æˆ·ç«¯â€ï¼Œä¸å†å•å•å“åº”æœåŠ¡å™¨å‘½ä»¤ï¼›ä½†ä¹Ÿä¸æ˜¯è¯´å®¢æˆ·ç«¯å¯ä»¥åƒæ²¡æœ‰ä¸­å¤®æœåŠ¡å™¨çš„p2pæ¸¸æˆå®Œå…¨è‡ªæ²»ã€‚æœåŠ¡å™¨ä»ç„¶åœ¨è¿è¡Œå¹¶ä¿è¯åœ¨å®¢æˆ·ç«¯è·ŸæœåŠ¡å™¨è¿è¡Œç»“æœä¸ä¸€è‡´çš„æƒ…å†µä¸‹çº æ­£å®¢æˆ·ç«¯é”™è¯¯çš„æ¨¡æ‹Ÿã€‚ç”±äºç½‘ç»œå»¶è¿Ÿï¼Œä¿®æ­£åœ¨ä¸€ä¸ªç½‘ç»œä¼ è¾“å‘¨æœŸä»¥åæ‰ä¼šæ‰§è¡Œï¼Œè¿™ä¸ªæ—¶å€™çº æ­£ä¿¡æ¯é€šå¸¸å·²ç»è¿‡æœŸï¼Œè¿™æ ·ä¼šå¯¼è‡´æ˜æ˜¾çš„ä½ç½®æ¼‚ç§»ï¼Œå› ä¸ºå®¢æˆ·ç«¯æ”¶åˆ°çš„ä¿®æ­£ä¿¡æ¯æ˜¯è¿‡å»æŸä¸ªæ—¶é—´çš„ã€‚</strong></p><br><p><br><br>To implement client-side prediction of movement, the following general procedure is used. As before, client inputs are sampled and a user command is generated. Also as before, this user command is sent off to the server. However, each user command (and the<br> exact time it was generated) is stored on the client. The prediction algorithm uses these stored commands.</p><br><p><span style="font-weight:bold">ä¸ºäº†ä½¿å®¢æˆ·ç«¯è¿åŠ¨é¢„æµ‹æœ‰æ•ˆï¼Œæˆ‘ä»¬é‡‡ç”¨ä»¥ä¸‹æ–¹æ³•ï¼šè¿˜æ˜¯å®¢æˆ·ç«¯é‡‡æ ·å¹¶ç”Ÿæˆå‘½ä»¤å‘é€åˆ°æœåŠ¡å™¨ï¼Œä½†æ˜¯æ¯ä¸ªåŒ…å«ç”Ÿæˆæ—¶é—´çš„å‘½ä»¤åœ¨å®¢æˆ·ç«¯æœ¬åœ°å­˜èµ·æ¥å¹¶åœ¨é¢„æµ‹ç®—æ³•ä¸­ä½¿ç”¨ã€‚</span><br><br>For prediction, the last acknowledged movement from the server is used as a starting point. The acknowledgement indicates which user command was last acted upon by the server and also tells us the exact position (and other state data) of the player after that<br> movement command was simulated on the server. The last acknowledged command will be somewhere in the past if there is any lag in the connection. For instance, if the client is running at 50 frames per second (fps) and has 100 milliseconds of latency (roundtrip),<br> then the client will have stored up five user commands ahead of the last one acknowledged by the server. These five user commands are simulated on the client as a part of client-side prediction. Assuming full prediction[1], the client will want to start with<br> the latest data from the server, and then run the five user commands through &quot;similar logic&quot; to what the server uses for simulation of client movement. Running these commands should produce an accurate final state on the client (final player position is most<br> important) that can be used to determine from what position to render the scene during the current frame.</p><br><p><strong>é¢„æµ‹çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬æŠŠæœåŠ¡å™¨ç¡®è®¤çš„ç§»åŠ¨ä¿¡æ¯ä½œä¸ºå¼€å§‹ï¼Œè¿™æ ·å®¢æˆ·ç«¯å°±å¯ä»¥ç¡®å®šæœåŠ¡å™¨æ‰§è¡Œä¸Šæ¬¡å‘½ä»¤ä»¥åæ¸¸æˆä¸­ç©å®¶çš„å‡†ç¡®ä¿¡æ¯ï¼ˆæ¯”å¦‚ä½ç½®ï¼‰ã€‚å¦‚æœç½‘ç»œæœ‰å»¶è¿Ÿï¼Œè¿™ä¸ªç¡®è®¤å‘½ä»¤ä¹Ÿä¼šæœ‰ä¸€å®šå»¶è¿Ÿã€‚å‡è®¾å®¢æˆ·ç«¯è¿è¡Œå¸§ç‡ä¸º50fpsï¼Œç½‘ç»œå»¶æ—¶ä¸º100msï¼Œè¿™æ ·åœ¨å®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡å™¨çš„ç¡®è®¤å‘½ä»¤çš„æ—¶å€™ï¼Œæœ¬åœ°å‘½ä»¤é˜Ÿåˆ—ä¸­å·²ç»æœ‰5æ¡ä¿¡æ¯ï¼Œè¿™5æ¡ä¿¡æ¯è¢«ç”¨æ¥æ‰§è¡Œå®¢æˆ·ç«¯é¢„æµ‹ã€‚å‡è®¾æ‰§è¡Œå®Œå…¨é¢„æµ‹ã€1ã€‘å®¢æˆ·ç«¯åœ¨æ”¶åˆ°æ¥è‡ªæœåŠ¡å™¨çš„æœ€æ–°ä¿¡æ¯åï¼Œå°±å¼€å§‹æŒ‰ç…§ä¸æœåŠ¡å™¨ç›¸åŒçš„é€»è¾‘æ‰§è¡Œæœ¬åœ°æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„5ä¸ªå‘½ä»¤ã€‚è¿™äº›å‘½ä»¤æ‰§è¡Œä»¥åå¾—åˆ°å½“å‰çŠ¶æ€ï¼ˆæœ€é‡è¦çš„æ˜¯ç©å®¶æœ€åçš„ä½ç½®ï¼‰ï¼Œç„¶åæ ¹æ®ç©å®¶çš„çŠ¶æ€ä¿¡æ¯æ¸²æŸ“å½“å‰å¸§ã€‚</strong><br><br>In Half-Life, minimizing discrepancies between client and server in the prediction logic is accomplished by sharing the identical movement code for players in both the server-side game code and the client-side game code. These are the routines in the pm_shared/<br> (which stands for &quot;player movement shared&quot;) folder of the HL SDK. The input to the shared routines is encapsulated by the user command and a &quot;from&quot; player state. The output is the new player state after issuing the user command. The general algorithm on the<br> client is as follows:</p><br><p><strong>åœ¨åŠæ¡å‘½è¿™ä¸ªæ¸¸æˆä¸­ï¼Œå®¢æˆ·ç«¯è·ŸæœåŠ¡å™¨é‡‡ç”¨ç›¸åŒçš„ä»£ç æ¥è®¡ç®—ç§»åŠ¨ï¼Œè¿™æ ·å¯ä»¥å‡å°å®¢æˆ·ç«¯é¢„æµ‹è·ŸæœåŠ¡å™¨ä¹‹é—´çš„è¯¯å·®ã€‚è¿™äº›ä»£ç ä½äºHLSDKä¸­çš„pm_shared/ï¼ˆæ„æ€æ˜¯â€œplayer movement sharedâ€ï¼‰ã€‚è¿™æ®µä»£ç çš„è¾“å…¥æ˜¯ç©å®¶æ“ä½œå’Œå®¢æˆ·ç«¯çš„åˆå§‹çŠ¶æ€ï¼Œè¾“å‡ºæ˜¯ç©å®¶æ“ä½œä»¥åçš„çŠ¶æ€ã€‚å®¢æˆ·ç«¯ç®—æ³•å¤§è‡´å¦‚ä¸‹ï¼š</strong></p>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">â€œfrom stateâ€ &lt;- state after last user command acknowledged by the server;</span><br><span class="line"></span><br><span class="line">â€œcommandâ€ &lt;- first command after last user command acknowledged by server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    run â€œcommandâ€ on â€œfrom stateâ€ to generate â€œto stateâ€;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> was the most up to date â€œcommandâ€)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    â€œfrom stateâ€ = â€œto stateâ€;</span><br><span class="line">    â€œcommandâ€ = next â€œcommandâ€;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">â€œåˆå§‹çŠ¶æ€â€ &lt;- ä¸Šä¸€æ¡å·²è¢«æœåŠ¡å™¨ç¡®è®¤è¿‡çš„ç©å®¶commandä¹‹åçš„state</span><br><span class="line"><span class="string">"å‘½ä»¤"</span> &lt;- ä¸Šä¸€æ¡å·²è¢«æœåŠ¡å™¨ç¡®è®¤è¿‡çš„ç©å®¶commandä¹‹åçš„command</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	ä»¥<span class="string">"from state"</span> ä¸ºåŸºç¡€æ‰§è¡Œ<span class="string">"command"</span>å¾—åˆ° <span class="string">"to state"</span>;</span><br><span class="line">	<span class="keyword">if</span> (è¿™æ˜¯æœ€æ–°çš„ <span class="string">"command"</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="string">"from state"</span> = <span class="string">"to state"</span>;</span><br><span class="line">	<span class="string">"command"</span> = next <span class="string">"command"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The origin and other state info in the final &quot;to state&quot; is the prediction result and is used for rendering the scene that frame. The portion where the command is run is simply the portion where all of the player state data is copied into the shared data<br> structure, the user command is processed (by executing the common code in the pm_shared routines in Half-Lifeâ€™s case), and the resulting data is copied back out to the &quot;to state&quot;.</p><br><p><strong>ç©å®¶çš„åˆå§‹çŠ¶æ€å’Œé¢„æµ‹ç»“æœç”¨æ¥æ¸²æŸ“åœºæ™¯ã€‚å‘½ä»¤çš„æ‰§è¡Œè¿‡ç¨‹å°±æ˜¯ï¼šå°†ç©å®¶çŠ¶æ€å¤åˆ¶åˆ°å…±äº«æ•°æ®ç»“æ„ä¸­ï¼Œæ‰§è¡Œç©å®¶æ“ä½œï¼ˆæ‰§è¡Œhlsdkä¸­pm_sharedä¸­çš„å…±ç”¨ä»£ç ï¼‰ï¼Œç„¶åå°†ç»“æœå¤åˆ¶åˆ°ç›®æ ‡çŠ¶æ€ï¼ˆto stateï¼‰</strong></p><br><p>There are a few important caveats to this system. First, youâ€™ll notice that, depending upon the clientâ€™s latency and how fast the client is generating user commands (i.e., the clientâ€™s framerate), the client will most often end up running the same commands<br> over and over again until they are finally acknowledged by the server and dropped from the list (a sliding window in Half-Lifeâ€™s case) of commands yet to be acknowledged. The first consideration is how to handle any sound effects and visual effects that are<br> created in the shared code. Because commands can be run over and over again, itâ€™s important not to create footstep sounds, etc. multiple times as the old commands are re-run to update the predicted position. In addition, itâ€™s important for the server not to<br> send the client effects that are already being predicted on the client. However, the client still must re-run the old commands or else there will be no way for the server to correct any erroneous prediction by the client. The solution to this problem is easy:<br> the client just marks those commands which have not been predicted yet on the client and only plays effects if the user command is being run for the first time on the client.</p><br><p><strong>è¿™ä¸ªç³»ç»Ÿä¸­æœ‰å‡ ä¸ªéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼Œé¦–å…ˆï¼Œç”±äºç½‘ç»œå»¶è¿Ÿï¼Œå®¢æˆ·ç«¯åˆåœ¨ä¸åœåœ°ä»¥ä¸€å®šé€Ÿåº¦ï¼ˆå®¢æˆ·ç«¯å¸§ç‡ï¼‰ç”Ÿæˆå‘½ä»¤ï¼Œä¸€ä¸ªå‘½ä»¤é€šå¸¸ä¼šè¢«å®¢æˆ·ç«¯åå¤æ‰§è¡Œï¼Œç›´åˆ°å¾—åˆ°æœåŠ¡å™¨çš„ç¡®è®¤ä»¥åæ‰å°†å…¶ä»å‘½ä»¤åˆ—è¡¨ä¸­åˆ é™¤ï¼ˆè¿™å°±æ˜¯åŠæ¡å‘½ä¸­çš„æ»‘åŠ¨çª—å£ï¼‰ã€‚é¦–å…ˆè¦è€ƒè™‘çš„æ˜¯å¦‚ä½•å¤„ç†å…±äº«ä»£ç ä¸­ç”Ÿæˆçš„å£°æ•ˆå’ŒåŠ¨ç”»æ•ˆæœã€‚å› ä¸ºå‘½ä»¤å¯èƒ½ä¼šè¢«å¤šæ¬¡æ‰§è¡Œï¼Œé¢„æµ‹ä½ç½®çš„è¿‡ç¨‹è¢«å¤šæ¬¡æ‰§è¡Œçš„æ—¶å€™è¦æ³¨æ„é¿å…é‡å£°ç­‰ä¸æ­£ç¡®çš„æ•ˆæœã€‚å¦å¤–ï¼ŒæœåŠ¡å™¨ä¹Ÿè¦é¿å…å®¢æˆ·ç«¯æ„è§é¢„æµ‹çš„æ•ˆæœã€‚ç„¶è€Œï¼Œå®¢æˆ·ç«¯å¿…é¡»é‡æ–°è¿è¡Œæ—§çš„å‘½ä»¤ï¼Œå¦åˆ™å°±æ²¡æ³•æ ¹æ®æœåŠ¡å™¨æ¥çº æ­£å®¢æˆ·ç«¯çš„é¢„æµ‹é”™è¯¯ã€‚è§£å†³æ–¹æ³•å¾ˆç®€å•ï¼šå®¢æˆ·ç«¯å°†æ²¡æœ‰æ‰§è¡Œçš„å®¢æˆ·ç«¯å‘½ä»¤è¿›è¡Œæ ‡è®°ï¼Œå¦‚æœè¿™äº›å‘½ä»¤åœ¨å®¢æˆ·ç«¯ç¬¬ä¸€æ¬¡æ‰§è¡Œï¼Œåˆ™æ’­æ”¾ç›¸åº”çš„æ•ˆæœã€‚</strong><br><br>The other caveat is with respect to state data that exists solely on the client and is not part of the authoritative update data from the server. If you donâ€™t have any of this type of data, then you can simply use the last acknowledged state from the server<br> as a starting point, and run the prediction user commands &quot;quot;in-place&quot; on that data to arrive at a final state (which includes your position for rendering). In this case, you donâ€™t need to keep all of the intermediate results along the route for predicting from<br> the last acknowledged state to the current time. However, if you are doing any logic totally client side (this logic could include functionality such as determining where the eye position is when you are in the process of crouchingâ€”and itâ€™s not really totally<br> client side since the server still simulates this data also) that affects fields that are not replicated from the server to the client by the networking layer handling the playerâ€™s state info, then you will need to store the intermediate results of prediction.<br> This can be done with a sliding window, where the &quot;from state&quot; is at the start and then each time you run a user command through prediction, you fill in the next state in the window. When the server finally acknowledges receiving one or more commands that<br> had been predicted, it is a simple matter of looking up which state the server is acknowledging and copying over the data that is totally client side to the new starting or &quot;from state&quot;.</p><br><p><strong>å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯æœåŠ¡å™¨ä¸å¤„ç†ï¼Œåªæœ‰å®¢æˆ·ç«¯æ‰æœ‰çš„ä¸€äº›æ•°æ®ï¼›å¦‚æœæ²¡æœ‰è¿™ç§ç±»å‹çš„æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥å¦‚ä¸Šé¢æ‰€è¿°ï¼Œä»¥æœåŠ¡å™¨ç¬¬ä¸€æ¡æ¶ˆæ¯ä½œä¸ºèµ·ç‚¹è¿›è¡Œé¢„æµ‹å¾—åˆ°ä¸‹ä¸€å¸§çŠ¶æ€ï¼ˆåŒ…æ‹¬ç”¨æ¥æ¸²æŸ“çš„ä½ç½®ä¿¡æ¯ï¼‰ã€‚ç„¶è€Œï¼Œå¦‚æœæœ‰äº›é€»è¾‘æ˜¯çº¯å®¢æˆ·ç«¯çš„ï¼ŒæœåŠ¡å™¨ä¸ä¼šå¤„ç†ï¼ˆæ¯”å¦‚ç©å®¶è¹²ä¸‹æ¥&#30524;ç›çš„ä½ç½®-ç„¶è€Œè¿™ä¹Ÿä¸æ˜¯çº¯å®¢æˆ·ç«¯ä¿¡æ¯ï¼Œå› ä¸ºæœåŠ¡å™¨ä¹Ÿä¼šå¤„ç†è¿™ä¸ªæ•°æ®ï¼‰ï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦å°†é¢„æµ‹çš„ä¸­é—´ç»“æœå­˜èµ·æ¥ã€‚å¯ä»¥ç”¨ä¸€ä¸ªæ»‘åŠ¨çª—å£å®Œæˆè¿™é¡¹å·¥ä½œï¼Œå…¶ä¸­â€œå¼€å§‹çŠ¶æ€â€æ˜¯å¼€å§‹ï¼Œä»¥åæ¯æ¬¡æ‰§è¡Œä¸€ä¸ªç©å®¶å‘½ä»¤é¢„æµ‹å®Œæˆåï¼Œå¡«å†™çª—å£ä¸­çš„ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼›å½“æœåŠ¡å™¨é€šçŸ¥æŸä¸ªå‘½ä»¤è¢«æ¥å—å¹¶æ‰§è¡Œä»¥åï¼Œä»çª—å£ä¸­æŸ¥æ‰¾æœåŠ¡å™¨å¤„ç†çš„æ˜¯å“ªæ¡å‘½ä»¤å¹¶å°†ç›¸åº”çš„æ•°æ®ä¼ åˆ°ä¸‹ä¸€ä¸ªå¸§çš„â€œèµ·å§‹çŠ¶æ€â€</strong><br><br>So far, the above procedure describes how to accomplish client side prediction of movements. This system is similar to the system used in QuakeWorld2.</p><br><p><strong>åˆ°æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬æè¿°äº†å®¢æˆ·ç«¯çš„è¿åŠ¨é¢„æµ‹ã€‚quakeworld2ä¸­é‡‡ç”¨äº†è¿™ç§ç±»å‹çš„é¢„æµ‹</strong></p><br><p><br><br><span style="font-size:18px">Client-Side Prediction of Weapon Firing</span></p><br><p></p><br><h2 id="å¼€ç«è¿‡ç¨‹ä¸­çš„å®¢æˆ·ç«¯é¢„æµ‹">å¼€ç«è¿‡ç¨‹ä¸­çš„å®¢æˆ·ç«¯é¢„æµ‹</h2><br><br><br>Layering prediction of the firing effects of weapons onto the above system is straightforward. Additional state information is needed for the local player on the client, of course, including which weapons are being held, which one is active, and how much ammo<br> each of these weapons has remaining. With this information, the firing logic can be layered on top of the movement logic because, once again, the state of the firing buttons is included in the user command data structure that is shared between the client and<br> the server. Of course, this can get complicated if the actual weapon logic is different between client and server. In Half-Life, we chose to avoid this complication by moving the implementation of a weaponâ€™s firing logic into &quot;shared code&quot; just like the player<br> movement code. All of the variables that contribute to determining weapon state (e.g., ammo, when the next firing of the weapon can occur, what weapon animation is playing, etc.), are then part of the authoritative server state and are replicated to the client<br> so that they can be used on the client for prediction of weapon state there.<br><p></p><br><p><strong>ä¸Šé¢æè¿°çš„ç³»ç»Ÿå¯ä»¥å¾ˆè‡ªç„¶åœ°ç”¨äºæ­¦å™¨å¼€ç«æ•ˆæœé¢„æµ‹ã€‚å®¢æˆ·ç«¯ç©å®¶éœ€è¦è®°å½•ä¸€äº›çŠ¶æ€ï¼Œæ¯”å¦‚èº«ä¸Šæœ‰å“ªäº›æ­¦å™¨ï¼Œæ­£åœ¨ä½¿ç”¨çš„æ˜¯å“ªä¸€ä¸ªï¼Œæ¯æŠŠæ­¦å™¨éƒ½è¿˜å‰©å¤šå°‘å¼¹è¯ã€‚æœ‰äº†è¿™äº›ä¿¡æ¯ï¼Œå¼€ç«é€»è¾‘å¯ä»¥å»ºç«‹åœ¨è¿åŠ¨é€»è¾‘ä¸Šé¢ï¼Œåªéœ€è¦åœ¨å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä½¿ç”¨çš„å‘½ä»¤é‡Œé¢åŠ ä¸Šç©å®¶å¼€ç«çš„æŒ‰é”®ä¿¡æ¯ã€‚åœ¨åŠæ¡å‘½ä¸­ï¼Œä¸ºäº†ç®€å•ï¼Œæ­¦å™¨å¼€ç«é€»è¾‘ä»£ç ä¹Ÿè·Ÿè¿åŠ¨ä»£ç ä¸€æ ·ä¹Ÿä½œä¸ºâ€œå…±äº«ä»£ç â€ã€‚æ‰€æœ‰ä¼šå½±å“åˆ°æ­¦å™¨çŠ¶æ€çš„å˜é‡ï¼Œæ¯”å¦‚å¼¹è¯ã€ä¸‹æ¬¡å¯å¼€ç«æ—¶é—´ã€æ­£åœ¨æ’­æ”¾é‚£ä¸ªæ­¦å™¨åŠ¨ç”»ï¼Œéƒ½ä½œä¸ºæœåŠ¡å™¨çš„çŠ¶æ€ï¼Œè¿™äº›çŠ¶æ€ä¼šé€šçŸ¥ç»™å®¢æˆ·ç«¯ç”¨æ¥é¢„æµ‹æ­¦å™¨çŠ¶æ€ã€‚</strong><br><br>Predicting weapon firing on the client will likely lead to the decision also to predict weapon switching, deployment, and holstering. In this fashion, the user feels that the game is 100% responsive to his or her movement and weapon activation activities. This<br> goes a long way toward reducing the feeling of latency that many players have come to endure with todayâ€™s Internet-enabled action experiences.</p><br><p><strong>å®¢æˆ·ç«¯æ­¦å™¨å¼€ç«é¢„æµ‹åŒ…æ‹¬é¢„æµ‹æ­¦å™¨åˆ‡æ¢ã€éƒ¨ç½²ã€æ‰‹æªçš®å¥—ã€‚è¿™æ ·ï¼Œç©å®¶ä¼šæ„Ÿè§‰æ¸¸æˆä¸­çš„ç§»åŠ¨å’Œæ­¦å™¨çŠ¶æ€100%å—ä»–æ§åˆ¶ã€‚è¿™åœ¨å‡å°ç½‘ç»œå»¶è¿Ÿç»™ç©å®¶å¸¦æ¥çš„ä¸çˆ½ä¸Šé¢è¿ˆå‡ºäº†ä¸€å¤§æ­¥ã€‚</strong></p><br><p><strong><br><br></strong><span style="font-size:18px">Umm, This is a Lot of Work</span></p><br><p></p><br><h2 id="ä¸€äº›å·¥ä½œ">ä¸€äº›å·¥ä½œ</h2><br><br><br>Replicating the necessary fields to the client and handling all of the intermediate state is a fair amount of work. At this point, you may be asking, why not eliminate all of the server stuff and just have the client report where s/he is after each movement?<br> In other words, why not ditch the server stuff and just run the movement and weapons purely on the client-side? Then, the client would just send results to the server along the lines of, &quot;Iâ€™m now at position x and, by the way, I just shot player 2 in the head.&quot;<br> This is fine if you can trust the client. This is how a lot of the military simulation systems work (i.e., they are a closed system and they trust all of the clients). This is how peer-to-peer games generally work. For Half-Life, this mechanism is unworkable<br> because of realistic concerns about cheating. If we encapsulated absolute state data in this fashion, weâ€™d raise the motivation to hack the client even higher than it already is3. For our games, this risk is too high and we fall back to requiring an authoritative<br> server.<br><p></p><br><p><strong>æœåŠ¡å™¨éœ€è¦å°†å¿…è¦çš„å­—æ®µå‘ç»™å®¢æˆ·ç«¯ï¼Œå¹¶ä¸”å¤„ç†å¾ˆå¤šä¸­é—´çŠ¶æ€ï¼Œæœ‰äººå¯èƒ½æœ‰è¿™æ ·çš„ç–‘é—®ï¼Œä¸ºä»€ä¹ˆä¸æŠŠæœåŠ¡å™¨é€»è¾‘å–æ¶ˆï¼Œè®©å®¢æˆ·ç«¯å¹¿æ’­è‡ªå·±çš„ä½ç½®ï¼Œä¹Ÿå°±æ˜¯å°†æ‰€æœ‰çš„ç§»åŠ¨ã€å¼€ç«é€»è¾‘æ”¾åœ¨å®¢æˆ·ç«¯ã€‚è¿™æ ·ï¼Œå®¢æˆ·ç«¯å°±ä¼šç»™æœåŠ¡å™¨å‘é€ç±»&#20284;è¿™æ ·çš„ç»“æœæŠ¥å‘Šï¼šâ€œæˆ‘åœ¨Xä½ç½®ï¼Œæˆ‘çˆ†äº†ç©å®¶2çš„è„‘è¢‹â€ã€‚å¦‚æœå®¢æˆ·ç«¯å¯ä¿¡çš„è¯ï¼Œè¿™æ ·åšæ˜¯å¯ä»¥çš„ï¼Œå¾ˆå¤šå†›æ–¹ä»¿çœŸç³»ç»Ÿå°±æ˜¯è¿™æ ·åšçš„ï¼ˆä»–ä»¬æ˜¯ä¸€ä¸ªå°é—­ç³»ç»Ÿï¼Œæ‰€æœ‰å®¢æˆ·ç«¯éƒ½å¯ä¿¡ï¼‰ã€‚ç‚¹å¯¹ç‚¹çš„æ¸¸æˆä¹Ÿæ˜¯è¿™ä¹ˆåšçš„ã€‚å¯¹äºåŠæ¡å‘½æ¥è¯´ä¸å¯ä»¥è¿™æ ·åšï¼Œå› ä¸ºå®¢æˆ·ç«¯å¯èƒ½â€œæ¬ºéª—â€æœåŠ¡å™¨ã€‚å¦‚æœæˆ‘ä»¬ä»¥è¿™ç§æ–¹æ³•å°è£…çŠ¶æ€æ•°æ®ï¼Œå°±ä¼šè¯±å¯¼ç©å®¶ç ´è§£å®¢æˆ·ç«¯ã€3ã€‘ã€‚å¯¹äºæˆ‘ä»¬çš„æ¸¸æˆæ¥è¯´è¿™æ ·åšé£é™©å¤ªå¤§ï¼Œæˆ‘ä»¬è¿˜æ˜¯é€‰æ‹©é‡‡ç”¨æœåŠ¡å™¨æ¨¡å¼æ¥åšæ ¡éªŒã€‚</strong><br><br>A system where movements and weapon effects are predicted client-side is a very workable system. For instance, this is the system that the Quake3 engine supports. One of the problems with this system is that you still have to have a feel for your latency to<br> determine how to lead your targets (for instant hit weapons). In other words, although you get to hear the weapons firing immediately, and your position is totally up-to-date, the results of your shots are still subject to latency. For example, if you are<br> aiming at a player running perpendicular to your view and you have 100 milliseconds of latency and the player is running at 500 units per second, then youâ€™ll need to aim 50 units in front of the target to hit the target with an instant hit weapon. The greater<br> the latency, the greater the lead targeting needed. Getting a &quot;feel&quot; for your latency is difficult. Quake3 attempted to mitigate this by playing a brief tone whenever you received confirmation of your hits. That way, you could figure out how far to lead by<br> firing your weapons in rapid succession and adjusting your leading amount until you started to hear a steady stream of tones. Obviously, with sufficient latency and an opponent who is actively dodging, it is quite difficult to get enough feedback to focus<br> in on the opponent in a consistent fashion. If your latency is fluctuating, it can be even harder.</p><br><p><strong>å®¢æˆ·ç«¯è¿›è¡Œè¿åŠ¨å’Œæ­¦å™¨æ•ˆæœé¢„æµ‹æ˜¯éå¸¸å¯è¡Œçš„ã€‚ä¾‹å¦‚quake3å°±æ”¯æŒè¿™æ ·çš„é¢„æµ‹ã€‚è¿™ä¸ªç³»ç»Ÿéœ€è¦æ³¨æ„ä¸€ç‚¹ï¼Œåœ¨åˆ¤æ–­ç›®æ ‡çš„æ—¶å€™éœ€è¦è€ƒè™‘åˆ°å»¶è¿Ÿï¼ˆæ¯”å¦‚å³æ—¶å°„å‡»æ­¦å™¨ï¼‰ã€‚æ¢å¥è¯è¯´ï¼Œè™½ç„¶ä½ çœ‹åˆ°è‡ªå·±ç”¨<strong>å³æ—¶</strong>æ­¦å™¨è¿›è¡Œäº†å°„å‡»ï¼Œä½ è‡ªå·±çš„ä½ç½®ä¹Ÿæ˜¯æœ€æ–°çš„ï¼Œå°„å‡»ç»“æœä»ç„¶è·Ÿå»¶è¿Ÿæœ‰å…³ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ å°„å‡»ä¸€ä¸ªç©å®¶ï¼Œè¿™ä¸ªç©å®¶æ²¿ä¸ä½ å®ç°å‚ç›´çš„æ–¹å‘å¥”è·‘ï¼Œå‡è®¾ä½ å®¢æˆ·ç«¯å»¶è¿Ÿä¸º100msï¼Œç©å®¶å¥”è·‘é€Ÿåº¦æ˜¯500å•ä½æ¯ç§’ï¼Œè¿™æ ·ä½ éœ€è¦ç„å‡†ç©å®¶å‰æ–¹50å•ä½æ‰èƒ½å‡†ç¡®å‡»ä¸­ã€‚å»¶è¿Ÿè¶Šå¤§ï¼Œå°±éœ€è¦æ›´å¤§çš„æå‰é‡ã€‚é æ„Ÿè§‰å¼¥è¡¥å»¶è¿Ÿå¤ªå›°éš¾äº†ã€‚ä¸ºäº†å‡è½»è¿™ç§æ•ˆæœï¼Œquake3å¯¹ä½ çš„å°„å‡»æ’­æ”¾ä¸€ä¸ªçŸ­éŸ³æ¥è¿›è¡Œç¡®å®šã€‚è¿™æ ·ï¼Œç©å®¶å¯ä»¥ç®—å‡ºå¿«é€Ÿå‘å°„æ­¦å™¨çš„æ—¶å€™éœ€è¦å¤šå¤§çš„æå‰é‡ï¼ŒåŒæ—¶è°ƒæ•´æå‰é‡ç›´åˆ°å¬åˆ°ç¨³å®šçš„éŸ³è°ƒä¸²ã€‚å¦‚æœå»¶è¿Ÿæ¯”è¾ƒå¤§ï¼Œè€Œä½ çš„å¯¹æ‰‹åˆåœ¨ä¸æ–­èº²é¿ï¼Œå°±å¾ˆéš¾è·å¾—è¶³å¤Ÿçš„åé¦ˆåˆ¤æ–­ã€‚å¦‚æœå»¶è¿Ÿä¹Ÿä¸æ–­å˜åŒ–ï¼Œå°±æ›´éš¾äº†ã€‚</strong></p><br><p><span style="font-size:18px">Display of Targets<br><br></span></p><br><h2 id="ç›®æ ‡çš„æ˜¾ç¤º">ç›®æ ‡çš„æ˜¾ç¤º</h2><br><br><br>Another important aspect influencing how a user perceives the responsiveness of the world is the mechanism for determining, on the client, where to render the other players. The two most basic mechanisms for determining where to display objects are extrapolation<br> and interpolation[4].<br><p></p><br><p><strong>å½±å“ç©å®¶æ¸¸æˆä½“éªŒçš„å¦ä¸€ä¸ªé‡è¦æ–¹é¢æ˜¯å®¢æˆ·ç«¯å¦‚ä½•æ¸²æŸ“å…¶å®ƒç©å®¶ã€‚ä¸¤ç§åŸºæœ¬çš„åˆ¤æ–­æœºåˆ¶æ˜¯ï¼šå¤–æ¨æ³•å’Œå†…æ’æ³•ã€4ã€‘</strong><br><br>For extrapolation, the other player/object is simulated forward in time from the last known spot, direction, and velocity in more or less a ballistic manner. Thus, if you are 100 milliseconds lagged, and the last update you received was that (as above) the<br> other player was running 500 units per second perpendicular to your view, then the client could assume that in &quot;real time&quot; the player has moved 50 units straight ahead from that last known position. The client could then just draw the player at that extrapolated<br> position and the local player could still more or less aim right at the other player.</p><br><p><strong>å¤–æ¨æ³•æŠŠå…¶å®ƒç©å®¶/ç‰©ä½“çœ‹ä½œä¸€ä¸ªç‚¹ï¼Œè¿™ä¸ªç‚¹å¼€å§‹çš„ä½ç½®ã€æ–¹å‘ã€é€Ÿåº¦å·²çŸ¥ï¼Œæ²¿ç€è‡ªå·±çš„å¼¹é“å‘å‰ç§»åŠ¨ã€‚å› æ­¤ï¼Œå‡è®¾å»¶æ—¶æ˜¯100msï¼Œæœ€æ–°çš„åè®®é€šçŸ¥å®¢æˆ·ç«¯è¿™ä¸ªç©å®¶å¥”è·‘é€Ÿåº¦æ˜¯500å•ä½æ¯ç§’ï¼Œæ–¹å‘å‚ç›´äºç©å®¶è§†çº¿ï¼Œå®¢æˆ·ç«¯å°±å¯ä»¥å‡è®¾äº‹å®ä¸Šè¿™ä¸ªç©å®¶å½“å‰å®é™…çš„ä½ç½®å·²ç»å‘å‰ç§»åŠ¨äº†50ä¸ªå•ä½ã€‚å®¢æˆ·ç«¯å¯ä»¥åœ¨è¿™ä¸ªå¤–æ¨çš„ä½ç½®æ¸²æŸ“è¿™ä¸ªç©å®¶ï¼Œè¿™æ ·æœ¬åœ°ç©å®¶å°±å·®ä¸å¤šå¯ä»¥æ­£ç¡®ç„å‡†ã€‚</strong></p><br><p><br><br>The biggest drawback of using extrapolation is that playerâ€™s movements are not very ballistic, but instead are very non-deterministic and subject to high jerk[5]. Layer on top of this the unrealistic player physics models that most FPS games use, where playerâ€™s<br> can turn instantaneously and apply unrealistic forces to create huge accelerations at arbitrary angles and youâ€™ll see that the extrapolation is quite often incorrect. The developer can mitigate the error by limiting the extrapolation time to a reasonable value<br> (QuakeWorld, for instance, limited extrapolation to 100 milliseconds). This limitation helps because, once the true player position is finally received, there will be a limited amount of corrective warping. In a world where most players still have greater<br> than 150 milliseconds of latency, the player must still lead other players in order to hit them. If those players are &quot;warping&quot; to new spots because of extrapolation errors, then the gameplay suffers nonetheless.</p><br><p><strong>å¤–æ¨æ³•çš„æœ€å¤§ç¼ºç‚¹æ˜¯ç©å®¶çš„ç§»åŠ¨å¹¶ä¸æ˜¯å®Œå…¨å¼¹é“çš„ï¼Œè€Œæ˜¯ä¸ç¡®å®šçš„å¹¶ä¸”é«˜&quot;jerk&quot;ã€5ã€‘ã€‚å¤§éƒ¨åˆ†FPSæ¸¸æˆé‡‡ç”¨éç°å®çš„ç©å®¶ç³»ç»Ÿï¼Œç©å®¶å¯ä»¥éšæ—¶è½¬å¼¯ï¼Œå¯ä»¥åœ¨ä»»æ„è§’åº¦ä½œç”¨ä¸ç°å®çš„åŠ é€Ÿåº¦ï¼Œå› æ­¤å¤–æ¨æ³•å¾—åˆ°çš„ç»“æœç»å¸¸æ˜¯é”™è¯¯åœ°ã€‚å¼€å‘è€…å¯ä»¥é€šè¿‡é™åˆ¶å¤–æ¨æ—¶é—´æ¥å‡è½»å¤–æ¨è¯¯å·®ï¼ˆæ¯”å¦‚quakeé™åˆ¶ä¸èƒ½è¶…è¿‡100msï¼‰ã€‚è¿™ç§é™åˆ¶ä½¿å¾—åœ¨å®¢æˆ·ç«¯æ”¶åˆ°ç©å®¶æ­£ç¡®ä½ç½®ä»¥åï¼Œçº é”™ä¸è‡³äºå¤ªå¤§ã€‚å½“å‰å¤§éƒ¨åˆ†ç©å®¶çš„ç½‘ç»œå»¶è¿Ÿé«˜äº150msï¼Œç©å®¶å¿…é¡»å¯¹æ¸¸æˆä¸­çš„å…¶ä»–ç©å®¶è¿›è¡Œå¤–æ¨ä»¥ä¾¿æ­£ç¡®å‡»ä¸­ã€‚å¦‚æœåˆ«çš„ç©å®¶å› ä¸ºå¤–æ¨é”™è¯¯ï¼Œè¢«æœåŠ¡å™¨æ‹‰å›ï¼Œæ¸¸æˆä½“éªŒå°†éå¸¸å·®ã€‚</strong></p><br><p>The other method for determining where to display objects and players is interpolation. Interpolation can be viewed as always moving objects somewhat in the past with respect to the last valid position received for the object. For instance, if the server<br> is sending 10 updates per second (exactly) of the world state, then we might impose 100 milliseconds of interpolation delay in our rendering. Then, as we render frames, we interpolate the position of the object between the last updated position and the position<br> one update before that (alternatively, the last render position) over that 100 milliseconds. As the object just gets to the last updated position, we receive a new update from the server (since 10 updates per second means that the updates come in every 100<br> milliseconds) we can start moving toward this new position over the next 100 milliseconds.</p><br><p><strong>å¦ä¸€ç§æ–¹æ³•å«æ’&#20540;æ³•ã€‚æ’&#20540;æ³•å¯ä»¥è¿™æ ·ç†è§£ï¼šå®¢æˆ·ç«¯ç‰©ä½“å®é™…ç§»åŠ¨ä½ç½®æ€»æ˜¯æ»åä¸€æ®µæ—¶é—´ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœæœåŠ¡å™¨æ¯ç§’åŒæ­¥10æ¬¡ä¸–ç•Œä¿¡æ¯ï¼Œå®¢æˆ·ç«¯æ¸²æŸ“çš„æ—¶å€™ä¼šæœ‰100msæ»åã€‚è¿™æ ·ï¼Œæ¯ä¸€å¸§æ¸²æŸ“çš„æ—¶å€™ï¼Œæˆ‘ä»¬é€šè¿‡æœ€æ–°æ”¶åˆ°çš„ä½ç½®ä¿¡æ¯å’Œå‰100msçš„ä½ç½®ä¿¡æ¯ï¼ˆæˆ–è€…ä¸Šä¸€å¸§æ¸²æŸ“ä½ç½®ï¼‰è¿›è¡Œå·®&#20540;å¾—åˆ°ç»“æœã€‚æˆ‘ä»¬æ¯æ”¶åˆ°ä¸€ä¸ªç‰©ä½“ä½ç½®çš„æ›´æ–°ä¿¡æ¯ï¼Œï¼ˆæ¯ç§’10ä¸ªæ›´æ–°æ„å‘³ç€æ¯100msæ”¶åˆ°ä¸€ä¸ªæ›´æ–°ï¼‰æ¥ä¸‹æ¥çš„100msæˆ‘ä»¬å°±å¯ä»¥æœè¿™ä¸ªæ–°çš„ä½ç½®ç§»åŠ¨ã€‚</strong></p><br><p><br><br>If one of the update packets fails to arrive, then there are two choices: We can start extrapolating the player position as noted above (with the large potential errors noted) or we can simply have the player rest at the position in the last update until a<br> new update arrives (causing the playerâ€™s movement to stutter).</p><br><p><strong>å¦‚æœä¸€ä¸ªæ›´æ–°åŒ…æ²¡æœ‰æ”¶åˆ°ï¼Œæœ‰2ç§å¤„ç†æ–¹æ³•ï¼šç¬¬ä¸€ã€ç”¨ä¸Šé¢ä»‹ç»çš„å¤–æ¨æ³•ï¼ˆæœ‰å¯èƒ½äº§ç”Ÿè¾ƒå¤§è¯¯å·®ï¼‰ï¼›ç¬¬äºŒã€ä¿æŒç©å®¶ä½äºå½“å‰ä½ç½®ç›´åˆ°æ”¶åˆ°ä¸‹ä¸€ä¸ªæ›´æ–°åŒ…ï¼ˆä¼šå¯¼è‡´ç©å®¶ç§»åŠ¨é¡¿æŒ«ï¼‰</strong><br><br>The general algorithm for this type of interpolation is as follows:</p><br><p><strong>å†…æ’æ³•çš„å¤§è‡´è¿‡ç¨‹å¦‚ä¸‹ï¼š</strong><br><br>1.Each update contains the server time stamp for when it was generated[6]</p><br><p><strong>1.æ¯ä¸ªæ›´æ–°åŒ…åŒ…å«ç”Ÿæˆçš„æœåŠ¡å™¨æ—¶é—´æˆ³ã€6ã€‘</strong><br><br>2.From the current client time, the client computes a target time by subtracting the interpolation time delta (100 ms)</p><br><p><strong>2.æ ¹æ®å®¢æˆ·ç«¯å½“å‰æ—¶é—´ï¼Œå®¢æˆ·ç«¯é€šè¿‡å‡å»æ—¶é—´å·®ï¼ˆ100msï¼‰è®¡ç®— ä¸€ä¸ªç›®æ ‡æ—¶é—´</strong><br><br>3.If the target time is in between the timestamp of the last update and the one before that, then those timestamps determine what fraction of the time gap has passed.</p><br><p><strong>3.å¦‚æœè®¡ç®—å¾—åˆ°çš„ç›®æ ‡æ—¶é—´åœ¨ä¸Šä¸€ä¸ªæ›´æ–°æ—¶é—´å’Œä¸Šä¸Šä¸ªæ›´æ–°æ—¶é—´ä¹‹é—´ï¼Œè¿™äº›æ—¶é—´æˆ³å¯ä»¥å†³å®šç›®æ ‡æ—¶é—´åœ¨è¿‡å»çš„æ—¶é—´é—´éš™ä¸­çš„æƒ…å†µ</strong><br><br>4.This fraction is used to interpolate any values (e.g., position and angles).</p><br><p><strong>4.ç›®æ ‡æ—¶é—´æƒ…å†µç”¨æ¥é€šè¿‡æ’&#20540;è®¡ç®—ç»“æœï¼ˆå¦‚ä½ç½®ã€è§’åº¦ï¼‰</strong><br><br>In essence, you can think of interpolation, in the above example, as buffering an additional 100 milliseconds of data on the client. The other players, therefore, are drawn where they were at a point in the past that is equal to your exact latency plus the<br> amount of time over which you are interpolating. To deal with the occasional dropped packet, we could set the interpolation time as 200 milliseconds instead of 100 milliseconds. This would (again assuming 10 updates per second from the server) allow us to<br> entirely miss one update and still have the player interpolating toward a valid position, often moving through this interpolation without a hitch. Of course, interpolating for more time is a tradeoff, because it is trading additional latency (making the interpolated<br> player harder to hit) for visual smoothness.</p><br><p><strong>ä¸Šé¢æåˆ°çš„æ’&#20540;æ³•ï¼Œæœ¬è´¨ä¸Šæ˜¯å®¢æˆ·ç«¯ç¼“å­˜äº†æ¥ä¸‹æ¥100msçš„æ•°æ®ã€‚å¯¹äºæ¯ä¸€ä¸ªå‘¨å›´çš„ç©å®¶ï¼Œä»–ä»¬éƒ½ä½äºè¿‡å»æŸä¸ªæ—¶é—´çš„ä½ç½®ï¼Œæ ¹æ®æ¯ä¸€ä¸ªå…·ä½“çš„æ—¶é—´ç‚¹è¿›è¡Œæ’&#20540;ã€‚å¦‚æœå¶å°”å‘ç”Ÿä¸¢åŒ…ï¼Œæˆ‘ä»¬å°±å°†æ’&#20540;æ—¶é—´å»¶é•¿åˆ°200msã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¿½ç•¥ä¸€æ¬¡æ›´æ–°ï¼ˆå‡è®¾åŒæ­¥é¢‘ç‡è¿˜æ˜¯10æ¬¡æ¯ç§’ï¼‰ï¼Œç©å®¶è¿˜å¯ä»¥ç§»åŠ¨åˆ°åˆç†çš„ç›®æ ‡ä½ç½®ï¼Œè¿™æ ·è¿›è¡Œæ’&#20540;é€šå¸¸ä¸ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ã€‚å½“ç„¶ï¼Œæ’&#20540;å¤šå°‘æ—¶é—´éœ€è¦æƒè¡¡ï¼Œå› ä¸ºè¿™ç§æ–¹æ³•æ˜¯ç”¨å»¶æ—¶ï¼ˆç©å®¶æ›´éš¾å‡»ä¸­ï¼‰æ¥æ¢å–å¹³æ»‘ã€‚</strong><br><br>In addition, the above type of interpolation (where the client tracks only the last two updates and is always moving directly toward the most recent update) requires a fixed time interval between server updates. The method also suffers from visual quality issues<br> that are difficult to resolve. The visual quality issue is as follows. Imagine that the object being interpolated is a bouncing ball (which actually accurately describes some of our players). At the extremes, the ball is either high in the air or hitting the<br> pavement. However, on average, the ball is somewhere in between. If we only interpolate to the last position, it is very likely that this position is not on the ground or at the high point. The bounciness of the ball is &quot;flattened&quot; out and it never seems to<br> hit the ground. This is a classical sampling problem and can be alleviated by sampling the world state more frequently. However, we are still quite likely never actually to have an interpolation target state be at the ground or at the high point and this will<br> still flatten out the positions.</p><br><p><strong>å¦å¤–ï¼Œä¸Šè¿°æ’&#20540;æ–¹æ³•ï¼ˆå®¢æˆ·ç«¯é€šè¿‡2ä¸ªæ›´æ–°ä¿¡æ¯æ’&#20540;å¹¶ä¸”æœæœ€æ–°æ›´æ–°ä½ç½®ç§»åŠ¨ï¼‰éœ€è¦æœåŠ¡å™¨æ›´æ–°ä¿¡æ¯é—´éš”å›ºå®šã€‚å¯¹äºæ‰€è°“çš„â€œè§†è§‰æ•ˆæœå› ç´ â€ï¼Œè¿™ç§æ–¹å¼å¾ˆéš¾å¤„ç†ï¼Œâ€œè§†è§‰æ•ˆæœå› ç´ â€æ˜¯è¿™æ ·çš„ï¼šå‡è®¾æˆ‘ä»¬æ’&#20540;çš„ç‰©ä½“æ˜¯å¼¹çƒï¼ˆè¿™ç§æ¨¡å‹å¯ä»¥å‡†ç¡®æè¿°æŸäº›ç©å®¶ï¼‰ã€‚æç«¯æƒ…å†µä¸‹ï¼Œçƒæˆ–è€…åœ¨ç©ºä¸­ï¼Œæˆ–è€…æ­£åœ¨ç¢°åœ°æ¿ã€‚ç„¶è€Œï¼Œé€šå¸¸æƒ…å†µä¸‹çƒåœ¨è¿™ä¸¤ç§çŠ¶æ€ä¹‹é—´ã€‚å¦‚æœæˆ‘ä»¬åªæ’&#20540;ä¸Šä¸€ä¸ªä½ç½®ï¼Œè¿™ä¸ªä½ç½®å¯èƒ½æ—¢ä¸åœ¨åœ°é¢ä¸Šï¼Œä¹Ÿä¸æ˜¯æœ€é«˜ç‚¹ï¼Œè¿™æ ·ï¼Œå¼¹çƒå¼¹çš„æ•ˆæœå°±è¢«å¹³æ»‘æ‰äº†ï¼Œå¥½åƒæ°¸è¿œæ²¡æœ‰å¼¹åˆ°åœ°é¢ä¸€æ ·ã€‚è¿™æ˜¯ä¸€ä¸ªç»å…¸é—®é¢˜ï¼Œå¢åŠ é‡‡æ ·ç‡å¯ä»¥å‡è½»è¿™ç§å½±å“ï¼Œä½†æ˜¯ä»ç„¶æœ‰å¯èƒ½æˆ‘ä»¬é‡‡æ ·ä¸åˆ°çƒåœ¨åœ°é¢çš„ç‚¹è·Ÿæœ€é«˜ç‚¹ï¼Œè¿™äº›ç‚¹ä¼šç»™å¹³æ»‘æ‰ã€‚</strong><br><br>In addition, because different users have different connections, forcing updates to occur at a lockstep like 10 updates per second is forcing a lowest common denominator on users unnecessarily. In Half-Life, we allow the user to ask for as many updates per<br> second as he or she wants (within limit). Thus, a user with a fast connection could receive 50 updates per second if the user wanted. By default, Half-Life sends 20 updates per second to each player the Half-Life client interpolates players (and many other<br> objects) over a period of 100 milliseconds.[7]</p><br><p><strong>å¦å¤–ï¼Œä¸åŒç”¨æˆ·ç½‘ç»œçŠ¶å†µä¸åŒï¼Œå¼ºè¿«æ¯ä¸ªç”¨æˆ·éƒ½ä»¥å›ºå®šé€Ÿåº¦æ›´æ–°ï¼ˆæ¯”å¦‚æ¯ç§’10æ¬¡ï¼‰æ•ˆæœä¸æ˜¯å¾ˆå¥½ï¼Œåœ¨åŠæ¡å‘½ä¸­ï¼Œç”¨æˆ·æ¯ç§’å¯ä»¥è¯·æ±‚ä»»æ„æ•°é‡çš„æ›´æ–°åŒ…ï¼ˆæ²¡æœ‰é™åˆ¶ï¼‰ã€‚è¿™æ ·ï¼Œé«˜é€Ÿç½‘ç»œç”¨æˆ·å¯ä»¥æ¯ç§’æ›´æ–°50æ¬¡ï¼Œåªè¦ç”¨æˆ·æ„¿æ„ã€‚åŠæ¡å‘½çš„é»˜è®¤è®¾ç½®æ˜¯æ¯ç§’æ¯ä¸ªç”¨æˆ·ï¼ˆä»¥åŠæ¸¸æˆä¸­å…¶å®ƒç‰©ä½“ï¼‰å‘é€20æ¬¡æ›´æ–°ï¼Œä»¥100msä¸ºæ—¶é—´çª—å£è¿›è¡Œæ’&#20540;ã€‚ã€7ã€‘</strong></p><br><p>To avoid the flattening of the bouncing ball problem, we employ a different algorithm for interpolation. In this method, we keep a more complete &quot;position history&quot; for each object that might be interpolated.</p><br><p><strong>ä¸ºäº†é¿å…â€œåå¼¹çƒ&quot;å¹³æ»‘é—®é¢˜ï¼Œæˆ‘ä»¬åœ¨æ’&#20540;çš„è¿‡ç¨‹ä¸­é‡‡ç”¨äº†ä¸€ä¸ªä¸åŒçš„ç®—æ³•ï¼Œè¿™ç§ç®—æ³•ä¸­æˆ‘ä»¬å¯¹æ¯ä¸€ä¸ªå¯èƒ½æ’&#20540;çš„ç‰©ä½“è®°å½•äº†ä¸€ä¸ªå®Œæ•´çš„â€œå†å²ä½ç½®â€ä¿¡æ¯ã€‚</strong><br><br>The position history is the timestamp and origin and angles (and could include any other data we want to interpolate) for the object. Each update we receive from the server creates a new position history entry, including timestamp and origin/angles for that<br> timestamp. To interpolate, we compute the target time as above, but then we search backward through the history of positions looking for a pair of updates that straddle the target time. We then use these to interpolate and compute the final position for that<br> frame. This allows us to smoothly follow the curve that completely includes all of our sample points. If we are running at a higher framerate than the incoming update rate, we are almost assured of smoothly moving through the sample points, thereby minimizing<br> (but not eliminating, of course, since the pure sampling rate of the world updates is the limiting factor) the flattening problem described above.</p><br><p><strong>å†å²ä½ç½®ä¿¡æ¯è®°å½•äº†ç‰©ä½“çš„æ—¶é—´æˆ³ã€è¿œç‚¹ã€è§’åº¦ï¼ˆä»¥åŠå…¶å®ƒæˆ‘ä»¬éœ€è¦æ’&#20540;è®¡ç®—çš„æ•°æ®ï¼‰ã€‚æˆ‘ä»¬æ¯æ”¶åˆ°ä¸€ä¸ªæœåŠ¡å™¨çš„æ›´æ–°ï¼Œæˆ‘ä»¬å°±åˆ›å»ºä¸€æ¡åŒ…å«æ—¶é—´æˆ³çš„è®°å½•ï¼Œå…¶ä¸­åŒ…å«åŸå§‹ä½ç½®ã€è§’åº¦ä¿¡æ¯ã€‚åœ¨æ’&#20540;è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ç”¨ä¸Šé¢çš„æ–¹æ³•è®¡ç®—ç›®æ ‡æ—¶é—´ï¼Œç„¶åæœç´¢ä½ç½®å†å²ä¿¡æ¯ï¼Œæ‰¾åˆ°åŒ…å«ç›®æ ‡æ—¶é—´çš„è®°å½•åŒºé—´ã€‚ç„¶åç”¨æ‰¾åˆ°çš„ä¿¡æ¯æ’&#20540;è®¡ç®—å½“å‰å¸§çš„ä½ç½®ã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¹³æ»‘è·Ÿè¸ªåˆ°åŒ…å«æ‰€æœ‰é‡‡æ ·ç‚¹çš„æ›²çº¿ã€‚å¦‚æœå®¢æˆ·ç«¯å¸§ç‡æ¯”æœåŠ¡å™¨æ›´æ–°é¢‘ç‡å¤§ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†é‡‡æ ·ç‚¹å¹³æ»‘å¤„ç†ï¼Œå‡å°ä¸Šé¢æåˆ°çš„å¹³æ»‘å¤„ç†å¸¦æ¥çš„é—®é¢˜ï¼ˆå½“ç„¶æ²¡æ³•é¿å…ï¼Œå› ä¸ºé‡‡ç”¨é¢‘ç‡é™åˆ¶ï¼Œè€Œä¸–ç•Œæœ¬èº«æ˜¯è¿ç»­çš„ï¼‰ã€‚</strong><br><br>The only consideration we have to layer on top of either interpolation scheme is some way to determine that an object has been forcibly teleported, rather than just moving really quickly. Otherwise we might &quot;smoothly&quot; move the object over great distances, causing<br> the object to look like itâ€™s traveling way too fast. We can either set a flag in the update that says, &quot;donâ€™t interpolate&quot; or &quot;clear out the position history,&quot; or we can determine if the distance between the origin and one update and another is too big, and<br> thereby presumed to be a teleportation/warp. In that case, the solution is probably to just move the object to the latest know position and start interpolating from there.</p><br><p><strong>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸Šé¢æåˆ°çš„æ’&#20540;æ–¹æ³•ä½¿ç”¨çš„æ—¶å€™ï¼Œç‰©ä½“æœ‰æ—¶å€™ä¼šè¢«æœåŠ¡å™¨æ‹‰å›ï¼Œè€Œä¸æ˜¯å¿«é€Ÿç§»åŠ¨ã€‚å½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥å¹³æ»‘åœ°å°†ç‰©ä½“ç§»åŠ¨ä¸€æ®µè¾ƒé•¿çš„è·ç¦»ï¼Œè¿™æ ·çœ‹èµ·æ¥ç‰©ä½“ç§»åŠ¨å¾ˆå¿«ã€‚æ›´æ–°çš„è¿‡ç¨‹ä¸­æˆ‘ä»¬å¯ä»¥è®¾ä¸€ä¸ªæ ‡å¿—è¡¨ç¤ºä¸æ’&#20540;æˆ–æ¸…é™¤å†å²è®°å½•ï¼Œæˆ–è€…å¦‚æœèµ·å§‹ç‚¹ä¸ç›®æ ‡ç‚¹è·ç¦»è¿‡é•¿ï¼Œæˆ‘ä»¬å°±è®¤ä¸ºæ•°æ®ä¸æ­£å¸¸ã€‚è¿™ç§æƒ…å†µæˆ‘ä»¬å°±å°†ç‰©ä½“ç›´æ¥æ‹‰è¿‡å»ã€‚å¹¶ä»¥è¿™ä¸ªä½ç½®ä¸ºèµ·å§‹ç‚¹è¿›è¡Œæ’&#20540;ã€‚</strong><br><br><span style="font-size:18px">Lag Compensation<br><br></span></p><br><h2 id="å»¶è¿Ÿè¡¥å¿">å»¶è¿Ÿè¡¥å¿</h2><br>Understanding interpolation is important in designing for lag compensation because interpolation is another type of latency in a userâ€™s experience. To the extent that a player is looking at other objects that have been interpolated, then the amount of interpolation<br> must be taken into consideration in computing, on the server, whether the playerâ€™s aim was true.<br><p></p><br><p><strong>æ’&#20540;ä¹Ÿä¼šå¸¦æ¥å»¶è¿Ÿï¼Œæ‰€ä»¥è€ƒè™‘å»¶è¿Ÿè¡¥å¿çš„è¿‡ç¨‹ä¸­éœ€è¦ç†è§£æ’&#20540;è¿‡ç¨‹ã€‚ç©å®¶çœ‹åˆ°çš„åˆ«çš„ç‰©ä½“æ˜¯ç»è¿‡æ’&#20540;è®¡ç®—å‡ºæ¥çš„ï¼Œæ‰€ä»¥æ’&#20540;è¿‡ç¨‹ä¸­éœ€è¦è€ƒè™‘åœ¨æœåŠ¡å™¨ä¸Šç©å®¶çš„ç›®æ ‡æ˜¯å¦æ­£ç¡®ã€‚</strong><br><br>Lag compensation is a method of normalizing server-side the state of the world for each player as that playerâ€™s user commands are executed. You can think of lag compensation as taking a step back in time, on the server, and looking at the state of the world<br> at the exact instant that the user performed some action. The algorithm works as follows:</p><br><p><strong>å»¶è¿Ÿè¡¥å¿æ˜¯æœåŠ¡å™¨æ‰§è¡Œçš„ä¸€ç§ç­–ç•¥ï¼Œå½“æœåŠ¡å™¨æ”¶åˆ°å®¢æˆ·ç«¯å‘½ä»¤å¹¶æ‰§è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œæ ¹æ®å®¢æˆ·ç«¯çš„å…·ä½“æƒ…å†µè¿›è¡Œå½’ä¸€ã€‚å»¶è¿Ÿè¡¥å¿å¯ä»¥çœ‹åšæœåŠ¡å™¨å¤„ç†ç”¨æˆ·å‘½ä»¤çš„æ—¶å€™å›é€€ä¸€æ®µæ—¶é—´ï¼Œé€€åˆ°å®¢æˆ·ç«¯å‘é€å‘½ä»¤æ—¶å€™çš„å‡†ç¡®æ—¶é—´ã€‚ç®—æ³•æµç¨‹å¦‚ä¸‹ï¼š</strong><br><br>1.Before executing a playerâ€™s current user command, the server:</p><br><p><strong>1.æœåŠ¡å™¨æ‰§è¡Œå®¢æˆ·ç«¯å‘½ä»¤ä¹‹å‰æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š</strong><br><br>&nbsp; &nbsp; 1.Computes a fairly accurate latency for the player</p><br><p><strong>&nbsp; &nbsp; 1.ä¸ºç©å®¶è®¡ç®—ä¸€ä¸ªç›¸å½“ç²¾ç¡®çš„å»¶è¿Ÿæ—¶é—´</strong><br><br>&nbsp; &nbsp; 2.Searches the server history (for the current player) for the world update that was sent to the player and received by the player just before the player would have issued the movement command</p><br><p>&nbsp; &nbsp;&nbsp;<strong>2.å¯¹æ¯ä¸ªç©å®¶ï¼Œä»æœåŠ¡å™¨å†å²ä¿¡æ¯ä¸­æ‰¾ä¸€ä¸ªå·²å‘é€ç»™è¿™ä¸ªç©å®¶å¹¶ä¸”è¿™ä¸ªç©å®¶å·²æ”¶åˆ°çš„çš„world update, è¿™ä¸ªworld updateæ˜¯åœ¨è¿™ä¸ªç©å®¶å°†è¦æ‰§è¡Œè¿™ä¸ªmovement commandä¹‹å‰çš„world update</strong><br><br>&nbsp; &nbsp; 3.From that update (and the one following it based on the exact target time being used), for each player in the update, move the other players backwards in time to &nbsp;<span style="white-space:pre"></span>exactly &nbsp;where they were when the current playerâ€™s<br> user command was created. This moving backwards must account for both connection latency and<span style="white-space:pre"></span>the&nbsp;<span style="white-space:pre"></span>interpolation amount[8] the client was using that frame.</p><br><p><strong>&nbsp; &nbsp; 3. å¯¹äºæ¯ä¸€ä¸ªç©å®¶ï¼Œå°†å…¶ä»ä¸Šè¿°çš„world updateå¤„æ‹‰å›åˆ°è¿™ä¸ªç©å®¶ç”Ÿæˆæ­¤user commandçš„æ›´æ–°æ—¶é—´ä¸­æ‰§è¡Œç”¨æˆ·å‘½ä»¤ã€‚è¿™ä¸ªå›é€€æ—¶é—´éœ€è¦è€ƒè™‘åˆ°å‘½ä»¤æ‰§è¡Œçš„æ—¶å€™çš„ç½‘ç»œå»¶æ—¶å’Œæ’&#20540;é‡ã€8ã€‘</strong><br><br>2.Allow the user command to execute (including any weapon firing commands, etc., that will run ray casts against all of the other players in their &quot;old&quot; positions).</p><br><p><strong>2.æ‰§è¡Œç©å®¶å‘½ä»¤ï¼ˆåŒ…æ‹¬æ­¦å™¨å¼€ç«ç­‰ã€‚ï¼‰</strong><br><br>3.Move all of the moved/time-warped players back to their correct/current positions</p><br><p><strong>3.å°†æ‰€æœ‰ç§»åŠ¨çš„ã€é”™ä½çš„ç©å®¶ç§»åŠ¨åˆ°ä»–ä»¬å½“å‰æ­£ç¡®ä½ç½®ã€‚</strong></p><br><p><br><br>Note that in the step where we move the player backwards in time, this might actually require forcing additional state info backwards, too (for instance, whether the player was alive or dead or whether the player was ducking). The end result of lag compensation<br> is that each local client is able to directly aim at other players without having to worry about leading his or her target in order to score a hit. Of course, this behavior is a game design tradeoff.</p><br><p><strong>æ³¨æ„ï¼šæˆ‘ä»¬æŠŠæ—¶é—´å¾€åæ¨ç®—çš„æ—¶å€™ï¼Œéœ€è¦è€ƒè™‘é‚£ä¸ªæ—¶å€™ç©å®¶çš„çŠ¶æ€ï¼Œæ¯”å¦‚ç©å®¶æ˜¯æˆ–è€…è¿˜æ˜¯å·²ç»å·²ç»æ­»æ‰ï¼Œç©å®¶æ˜¯å¦å¤„äºèº²é¿çŠ¶æ€ã€‚æ‰§è¡Œè¿åŠ¨è¡¥å¿ä»¥åï¼Œç©å®¶å°±å¯ä»¥ç›´æ¥ç„å‡†ç›®æ ‡è¿›è¡Œè®¾è®¡ï¼Œè€Œä¸éœ€è¦è®¡ç®—ä¸€ä¸ªæå‰é‡ã€‚å½“ç„¶ï¼Œè¿™ç§æ–¹æ¡ˆæ˜¯æ¸¸æˆä¸­çš„æƒè¡¡è®¾è®¡ã€‚</strong></p><br><p><br><br><span style="font-size:18px">Game Design Implications of Lag Compensation<br><br></span></p><br><h2 id="æ¸¸æˆæ¶‰åŠä¸­å»¶è¿Ÿè¡¥å¿çš„ä½¿ç”¨">æ¸¸æˆæ¶‰åŠä¸­å»¶è¿Ÿè¡¥å¿çš„ä½¿ç”¨</h2><br>The introduction of lag compensation allows for each player to run on his or her own clock with no apparent latency. In this respect, it is important to understand that certain paradoxes or inconsistencies can occur. Of course, the old system with the authoritative<br> server and &quot;dumb&quot; or simple clients had itâ€™s own paradoxes. In the end, making this tradeoff is a game design decision. For Half-Life, we believe deciding in favor of lag compensation was a justified game design decision.<br><p></p><br><p><strong>é‡‡ç”¨å»¶è¿Ÿè¡¥å¿ä»¥åï¼Œæ¯ä¸ªç©å®¶æ¸¸æˆçš„è¿‡ç¨‹ä¸­æ„Ÿè§‰ä¸åˆ°æ˜æ˜¾å»¶è¿Ÿã€‚åœ¨è¿™é‡Œéœ€è¦ç†è§£å¯èƒ½ä¼šäº§ç”Ÿä¸€äº›çŸ›ç›¾å’Œä¸ä¸€è‡´ã€‚å½“ç„¶ï¼ŒéªŒè¯æœåŠ¡å™¨å’Œæ— é€»è¾‘çš„å®¢æˆ·ç«¯è€ç³»ç»Ÿä¹Ÿä¼šæœ‰è‡ªç›¸çŸ›ç›¾çš„æƒ…å†µã€‚æœ€åï¼Œè¿™ä¸ªè¿™ç§äº‹æ¸¸æˆè®¾è®¡å†³å®šçš„ã€‚å¯¹äºåŠæ¡å‘½ï¼Œæˆ‘ä»¬ç›¸ä¿¡é‡‡ç”¨å»¶è¿Ÿè¡¥å¿æ˜¯æ­£ç¡®çš„æ¸¸æˆå†³å®šã€‚</strong><br><br>The first problem of the old system was that you had to lead your target by some amount that was related to your latency to the server. Aiming directly at another player and pressing the fire button was almost assured to miss that player. The inconsistency<br> here is that aiming is just not realistic and that the player controls have non-predictable responsiveness.</p><br><p><strong>è€ç³»ç»Ÿçš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œç”±äºç½‘ç»œå»¶è¿Ÿï¼Œç›®æ ‡éœ€è¦æœ‰ä¸€ä¸ªæå‰é‡ã€‚ç„å‡†æ•Œäººè¿›è¡Œå°„å‡»å‡ ä¹æ€»æ˜¯ä¸èƒ½å‡»ä¸­ã€‚è¿™ç§ä¸ä¸€è‡´å¯¼è‡´å°„å‡»å¾ˆä¸çœŸå®ï¼Œå“åº”ä¹Ÿä¸å¯æ§åˆ¶ã€‚<br><br></strong>With lag compensation, the inconsistencies are different. For most players, all they have to do is acquire some aiming skill and they can become proficient (you still have to be able to aim). Lag compensation allows the player to aim directly at his<br> or her target and press the fire button (for instant hit weapons[9]). The inconsistencies that sometimes occur, however, are from the points of view of the players being fired upon.</p><br><p><strong>é‡‡ç”¨å»¶è¿Ÿè¡¥å¿ä»¥åå¸¦æ¥çš„æ˜¯å¦ä¸€ç§å½¢å¼çš„ä¸ä¸€è‡´ã€‚å¯¹äºå¤§éƒ¨åˆ†ç©å®¶ï¼Œä»–ä»¬åªéœ€è¦ä¸“æ³¨äºå¾—åˆ°æ›´å¤šçš„å°„å‡»æŠ€èƒ½æ¥æ­¦è£…ä»–ä»¬ï¼ˆå½“ç„¶ä»–ä»¬ä¹Ÿæ˜¯éœ€è¦ç„å‡†çš„ï¼‰ã€‚å»¶æ—¶è¡¥å¿ä½¿å¾—ç©å®¶åªéœ€è¦ç›´æ¥ç„å‡†ä»–çš„ç›®æ ‡å¹¶æŒ‰ä¸‹å¼€ç«æŒ‰é’®å³å¯ï¼ˆå¯¹äºå³æ—¶å‡»ä¸­æ­¦å™¨ã€9ã€‘ï¼‰ã€‚ä¸ä¸€è‡´ä¹Ÿæ—¶æœ‰å‘ç”Ÿï¼Œä½†æ˜¯æ˜¯åœ¨å‡»ä¸­ä»¥åã€‚</strong><br><br>For instance, if a highly lagged player shoots at a less lagged player and scores a hit, it can appear to the less lagged player that the lagged player has somehow &quot;shot around a corner&quot;10. In this case, the lower lag player may have darted around a corner.<br> But the lagged player is seeing everything in the past. To the lagged player, s/he has a direct line of sight to the other player. The player lines up the crosshairs and presses the fire button. In the meantime, the low lag player has run around a corner and<br> maybe even crouched behind a crate. If the high lag player is sufficiently lagged, say 500 milliseconds or so, this scenario is quite possible. Then, when the lagged playerâ€™s user command arrives at the server, the hiding player is transported backward in<br> time and is hit. This is the extreme case, and in this case, the low ping player says that s/he was shot from around the corner. However, from the lagged playerâ€™s point of view, they lined up their crosshairs on the other player and fired a direct hit. From<br> a game design point of view, the decision for us was easy: let each individual player have completely responsive interaction with the world and his or her weapons.</p><br><p><strong>ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªå»¶æ—¶æ¯”è¾ƒå¤§çš„ç©å®¶å‡»ä¸­ä¸€ä¸ªå»¶æ—¶æ¯”è¾ƒå°çš„ç©å®¶å¹¶ä¸”å¾—åˆ°ä¸€åˆ†ï¼Œä½å»¶æ—¶çš„ç©å®¶ä¼šæ„Ÿè§‰é«˜å»¶æ—¶ç©å®¶â€œåœ¨è§’è½é‡Œè¢«å‡»ä¸­â€ã€10ã€‘ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œä½å»¶è¿Ÿç©å®¶å¯èƒ½å·²ç»ä»è§’è½é‡Œå†²å‡ºï¼Œè€Œé«˜å»¶æ—¶ç©å®¶çœ‹åˆ°çš„æ˜¯è¿‡å»çš„ä¿¡æ¯ã€‚æ¯ä¸€ä¸ªæœ‰å»¶è¿Ÿçš„ç©å®¶éƒ½æœ‰ä¸€ä¸ªæœå‘åˆ«çš„ç©å®¶çš„ç›´çš„è§†çº¿ï¼Œç›´çš„è§†çº¿æŒ‡å‘ä¸€ä¸ªç„å‡†ç‚¹ç„¶åå¼€ç«ã€‚è¿™ä¸ªæ—¶å€™ï¼Œä½å»¶æ—¶çš„ç©å®¶å¯èƒ½å·²ç»è·‘åˆ°è§’è½é‡Œå¹¶ä¸”è¹²åœ¨ä¸€ä¸ªç®±å­åé¢ï¼Œå¦‚æœé«˜å»¶è¿Ÿç©å®¶å»¶è¿Ÿæ¯”è¾ƒå¤§ï¼Œæ¯”å¦‚500msï¼Œè¿™æ˜¯ç»å¸¸å‘ç”Ÿçš„ï¼›è¿™æ ·å½“é«˜å»¶æ—¶ç©å®¶çš„å‘½ä»¤ä¼ åˆ°æœåŠ¡å™¨çš„æ—¶å€™ï¼Œå·²ç»éšè—èµ·æ¥çš„ç©å®¶éœ€è¦å–ä¸€ä¸ªå†å²ä½ç½®å¹¶è®¡ç®—æ˜¯å¦å‡»ä¸­ï¼Œåœ¨è¿™ç§æç«¯æƒ…å†µä¸‹ï¼Œä½å»¶æ—¶ç©å®¶ä¼šè§‰å¾—ä»–å†è§’è½é‡Œè¢«å‡»ä¸­äº†ã€‚ç„¶è€Œï¼Œå¯¹äºé«˜å»¶æ—¶ç©å®¶æ¥è¯´ï¼Œä»–æ˜¯æ­£å¯¹ç€åˆ«çš„ç©å®¶å¼€ç«çš„ã€‚ä»æ¸¸æˆè®¾è®¡çš„è§’åº¦æ¥è®²ï¼Œæˆ‘ä»¬éœ€è¦è¿™æ ·å†³å®šï¼šè®©æ¯ä¸ªç©å®¶å³æ—¶ä¸ä¸–ç•Œäº¤äº’å¹¶å¼€ç«ã€‚</strong><br><br>In addition, the inconsistency described above is much less pronounced in normal combat situations. For first-person shooters, there are two more typical cases. First, consider two players running straight at each other pressing the fire button. In this case,<br> itâ€™s quite likely that lag compensation will just move the other player backwards along the same line as his or her movement. The person being shot will be looking straight at his attacker and no &quot;bullets bending around corners&quot; feeling will be present.</p><br><p><strong>æ­¤å¤–ï¼Œåœ¨æ­£å¸¸æˆ˜æ–—ä¸­ï¼Œä¸Šé¢æåˆ°çš„ä¸ä¸€è‡´å¹¶ä¸æ˜æ˜¾ã€‚å¯¹äºç¬¬ä¸€äººç§°å°„å‡»æ¸¸æˆï¼Œæœ‰ä¸¤ç§å…¸å‹æƒ…å†µã€‚ç¬¬ä¸€ã€è€ƒè™‘ä¸¤ä¸ªç©å®¶ç›´çº¿è·‘å‘å¯¹æ–¹å¹¶ä¸”å¼€ç«ï¼›è¿™ç§æƒ…å†µä¸‹ï¼Œå»¶æ—¶è¡¥å¿åªä¼šæŠŠç©å®¶åœ¨ç§»åŠ¨ç›´çº¿ä¸Šå¾€åæ‹‰ã€‚è¢«å‡»ä¸­çš„ç©å®¶çœ‹ä»–çš„å°„å‡»è€…åœ¨å‰æ–¹ï¼Œè¿™æ ·å°±ä¸ä¼šæœ‰â€œå­å¼¹æ‹åˆ°è§’è½é‡Œâ€çš„æƒ…å†µå‘ç”Ÿã€‚</strong><br><br>The next example is two players, one aiming at the other while the other dashes in front perpendicular to the first player. In this case, the paradox is minimized for a wholly different reason. The player who is dashing across the line of sight of the shooter<br> probably has (in first-person shooters at least) a field of view of 90 degrees or less. In essence, the runner canâ€™t see where the other player is aiming. Therefore, getting shot isnâ€™t going to be surprising or feel wrong (you get what you deserve for running<br> around in the open like a maniac). Of course, if you have a tank game, or a game where the player can run one direction, and look another, then this scenario is less clear-cut, since you might see the other player aiming in a slightly incorrect direction.</p><br><p><strong>ç¬¬äºŒç§æƒ…å†µæ˜¯ä¸¤ä¸ªç©å®¶ä¸­çš„ä¸€ä¸ªå°„å‡»ï¼Œå¦å¤–ä¸€ä¸ªç©å®¶åœ¨å‚ç›´äºç¬¬ä¸€ä¸ªç©å®¶è§†çº¿çš„æ–¹å‘å†²é”‹ã€‚è¿™ç§æƒ…å†µä¸‹çš„è§£å†³é—®é¢˜çš„åŸç†ä¸åˆšæ‰ä¸åŒã€‚åˆšæ‰æåˆ°çš„å†²é”‹çš„ç©å®¶è§†é‡å·®ä¸å¤šæ˜¯90Â°ï¼ˆè‡³å°‘ç¬¬ä¸€äººç§°å°„å‡»æ¸¸æˆæ˜¯è¿™æ ·ï¼‰ï¼Œå› æ­¤ï¼Œè¿™ä¸ªç©å®¶çœ‹ä¸åˆ°æ­£åœ¨å°„å‡»ä»–çš„é‚£ä¸ªäººã€‚å› æ­¤ä»–è¢«å‡»ä¸­ä¹Ÿä¸ä¼šæ„Ÿè§‰å¥‡æ€ªæˆ–è€…é”™è¯¯ï¼ˆè°è®©ä½ åœ¨ç©ºæ—·åŒºåŸŸç‹‚å¥”å‘¢ï¼Œæ´»è¯¥ï¼‰ã€‚å½“ç„¶ï¼Œå¦‚æœä½ å¼€å‘çš„æ˜¯ä¸€ä¸ªå¦å…‹æ¸¸æˆï¼Œæˆ–è€…åœ¨ä½ çš„æ¸¸æˆä¸­ç©å®¶æœä¸€ä¸ªæ–¹å‘è·‘çš„æ—¶å€™å¯ä»¥çœ‹åˆ°åˆ«çš„æ–¹å‘ï¼Œé”™è¯¯å¯èƒ½å°±ä¼šæ¯”è¾ƒæ˜æ˜¾ï¼Œä½ å¯èƒ½å‘ç°ç©å®¶è®¾è®¡æ–¹å‘ä¸å¯¹ã€‚</strong><br><br><span style="font-size:18px">Conclusion<br><br></span></p><br><h2 id="æ€»ç»“">æ€»ç»“</h2><br><br><br>Lag compensation is a tool to ameliorate the effects of latency on todayâ€™s action games. The decision of whether to implement such a system rests with the game designer since the decision directly changes the feel of the game. For Half-Life, Team Fortress and<br> Counter Strike, the benefits of lag compensation easily outweighed the inconsistencies noted above.<br><p></p><br><p><strong>å»¶è¿Ÿè¡¥å¿æ˜¯å½“å‰åŠ¨ä½œæ¸¸æˆæ”¹å–„å»¶è¿Ÿå½±å“çš„ä¸€ç§æ–¹æ³•ã€‚æ˜¯å¦é‡‡ç”¨è¿™ç§æ–¹æ³•å–å†³äºæ¸¸æˆè®¾è®¡è€…ï¼Œå› ä¸ºå¦‚ä½•è®¾è®¡ç›´æ¥å½±å“åˆ°æ¸¸æˆçš„ä½“éªŒã€‚å¯¹äºæŠŠé‚£æ¡å‘½ã€å†›å›¢è¦å¡ã€csè¿™æ ·çš„æ¸¸æˆï¼Œå»¶è¿Ÿè¡¥å¿æ‰€å¸¦æ¥çš„æ•ˆæœæå‡æ˜¾è‘—å¤§äºå…¶å¸¦æ¥çš„é”™è¯¯ã€‚</strong></p><br><p><br><br>Footnotes</p><br><p></p><br><h2 id="è„šæ³¨">è„šæ³¨</h2><br><br><br>[1]In the Half-Life engine, it is possible to ask the client-side prediction algorithm to account for some, but not all, of the latency in performing prediction. The user could control the amount of prediction by changing the value of the &quot;pushlatency&quot; console<br> variable to the engine. This variable is a negative number indicating the maximum number of milliseconds of prediction to perform. If the number is greater (in the negative) than the userâ€™s current latency, then full prediction up to the current time occurs.<br> In this case, the user feels zero latency in his or her movements. Based upon some erroneous superstition in the community, many users insisted that setting pushlatency to minus one-half of the current average latency was the proper setting. Of course, this<br> would still leave the playerâ€™s movements lagged (often described as if you are moving around on ice skates) by half of the userâ€™s latency. All of this confusion has brought us to the conclusion that full prediction should occur all of the time and that the<br> pushlatency variable should be removed from the Half-Life engine.&nbsp;<br><p></p><br><p><strong>ã€1ã€‘åœ¨åŠæ¡å‘½å¼•æ“ä¸­ï¼Œé¢„æµ‹çš„è¿‡ç¨‹ä¸­å…è®¸ä¸€å®šçš„å»¶è¿Ÿï¼Œä½†ä¸èƒ½å®¹å¿å®é™…ç½‘ç»œå»¶è¿Ÿè¿™ä¹ˆå¤§çš„å»¶è¿Ÿã€‚é€šè¿‡è°ƒæ•´å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æ§åˆ¶é¢„æµ‹è¿‡ç¨‹ä¸­çš„å»¶è¿Ÿï¼Œè¿™ä¸ªå‚æ•°pushlatencyæ˜¯ä¸€ä¸ªè´Ÿæ•°ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½è¡¨ç¤ºé¢„æµ‹è¿‡ç¨‹ä¸­çš„å»¶è¿Ÿã€‚å¦‚æœè¿™ä¸ª&#20540;å¤§äºï¼ˆç»å¯¹&#20540;ï¼‰å®é™…ç½‘ç»œå»¶è¿Ÿï¼Œè¿™æ—¶é¢„æµ‹å°±æ˜¯å®Œå…¨çš„é¢„æµ‹ï¼ˆè¯‘æ³¨ï¼šå®¢æˆ·ç«¯æœåŠ¡å™¨å®Œå…¨åŒæ­¥ï¼‰ã€‚è¿™ç§æƒ…å†µä¸‹ç©å®¶æ„Ÿè§‰ä¸åˆ°ä»»ä½•å»¶è¿Ÿã€‚å®é™…åº”ç”¨ä¸­ï¼Œä¸€äº›äººé”™è¯¯åœ°è®¤ä¸ºå‚æ•°pushlatencyåº”è¯¥è®¾ä¸ºå®é™…ç½‘ç»œå»¶è¿Ÿçš„ä¸€åŠï¼Œè¿™ç§æƒ…å†µä¸‹ç©å®¶ç§»åŠ¨ä»ç„¶æœ‰ç½‘ç»œå»¶è¿Ÿä¸€åŠçš„å»¶è¿Ÿï¼ˆæ„Ÿè§‰ç±»&#20284;äºå†°é¢ç§»åŠ¨ï¼‰ã€‚åŸºäºè¿™ä¸ªåŸå› ï¼Œå®é™…åº”ç”¨æ€»åº”è¯¥æ€»æ˜¯é‡‡ç”¨å®Œå…¨é¢„æµ‹ï¼Œpushlatencyè¿™ä¸ªå˜é‡åº”è¯¥ä»åŠæ¡å‘½å¼•æ“ä¸­ç§»é™¤</strong><br><br>[2]<a href="http://www.quakeforge.net/files/q1source.zip" target="_blank" rel="noopener">http://www.quakeforge.net/files/q1source.zip</a> (Return)<br><br>[3]A discussion of cheating and what developers can do to deter it is beyond the scope of this paper. (Return)</p><br><p><strong>ã€3ã€‘å…³äºä½œå¼Šå’Œåä½œå¼Šçš„é—®é¢˜è¶…å‡ºäº†æœ¬ç¯‡æ–‡ç« è®¨è®ºçš„èŒƒå›´</strong><br><br>[4]Though hybrids and corrective methods are also possible. (Return)</p><br><p><strong>ã€4ã€‘è™½ç„¶æ··åˆçº æ­£æ–¹æ³•ä¹Ÿå¯ä»¥ä½¿ç”¨</strong><br><br>[5]&quot;Jerk&quot; is a measure of how fast accelerative forces are changing. (Return)</p><br><p><strong>ã€5ã€‘â€œjerkâ€ç”¨æ¥åº¦é‡ä½¿ç©å®¶æ”¹å˜åŠ é€Ÿåº¦çš„ä½œç”¨çš„å¿«æ…¢</strong><br><br>[6]It is assumed in this paper that the client clock is directly synchronized to the server clock modulo the latency of the connection. In other words, the server sends the client, in each update, the value of the serverâ€™s clock and the client adopts that value<br> as its clock. Thus, the server and client clocks will always be matched, with the client running the same timing somewhat in the past (the amount in the past is equal to the clientâ€™s current latency). Smoothing out discrepancies in the client clock can be<br> solved in various ways. (Return)</p><br><p><strong>ã€6ã€‘æœ¬æ–‡å‡è®¾è®¡ç®—è¿æ¥å»¶æ—¶çš„æ—¶å€™å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨å®Œå…¨åŒæ­¥ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯æ¬¡æ›´æ–°çš„æ—¶å€™å®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡å™¨å‘è¿‡æ¥çš„æ—¶é—´è¢«ç›´æ¥å½“åšå®¢æˆ·ç«¯çš„æ—¶é—´ä½¿ç”¨ã€‚è¿™æ ·ï¼Œå®¢æˆ·ç«¯è·ŸæœåŠ¡å™¨å®Œå…¨åŒ¹é…ï¼Œåªæ˜¯å®¢æˆ·ç«¯ç¨å¾®æ™šä¸€ç‚¹ï¼ˆæ™šå¤šå°‘å–å†³äºå»¶æ—¶å¤šå°‘ï¼‰ã€‚å¹³æ»‘å®¢æˆ·ç«¯æ—¶é’Ÿå·®&#20540;å¯ä»¥æœ‰å¾ˆå¤šæ–¹æ³•ã€‚</strong><br><br>[7]The time spacing of these updates is not necessarily fixed. The reason why is that during high activity periods of the game (especially for users with lower bandwidth connections), itâ€™s quite possible that the game will want to send you more data than your<br> connection can accommodate. If we were on a fixed update interval, then you might have to wait an entire additional interval before the next packet would be sent to the client. However, this doesnâ€™t match available bandwidth effectively. Instead, the server,<br> after sending every packet to a player, determines when the next packet can be sent. This is a function of the userâ€™s bandwidth or &quot;rate&quot; setting and the number of updates requested per second. If the user asks for 20 updates per second, then it will be at<br> least 50 milliseconds before the next update packet can be sent. If the bandwidth choke is active (and the server is sufficiently high framerate), it could be 61, etc., milliseconds before the next packet gets sent. Thus, Half-Life packets can be somewhat<br> arbitrarily spaced. The simple move to latest goal interpolation schemes donâ€™t behave as well (think of the old anchor point for movement as being variable) under these conditions as the position history interpolation method (described below). (Return)</p><br><p><strong>ã€7ã€‘æ›´æ–°æ—¶é—´é—´éš”æ²¡å¿…è¦æ˜¯å›ºå®šçš„ã€‚å› ä¸ºå¯¹äºå‰§çƒˆè¿åŠ¨çš„æ¸¸æˆï¼Œå¦‚æœå¸¦å®½ä¸å¤Ÿï¼Œå¾ˆæœ‰å¯èƒ½å®¢æˆ·ç«¯å‘è¿‡æ¥çš„æ•°æ®è¶…è¿‡äº†å¤„ç†èƒ½åŠ›ã€‚å¦‚æœé‡‡ç”¨å›ºå®šæ›´æ–°é—´éš”ï¼Œåœ¨å‘å®Œä¸€ä¸ªæ›´æ–°åŒ…ä»¥åå°±éœ€è¦ç­‰å¾…ä¸€ä¸ªå›ºå®šæ›´æ–°å‘¨æœŸæ—¶é—´ä»¥åå†å‘ä¸‹ä¸€ä¸ªåŒ…ã€‚è¿™ç§é€»è¾‘ä¸èƒ½å¾ˆå¥½åœ°ä½¿ç”¨å¸¦å®½ã€‚å› æ­¤ï¼ŒæœåŠ¡å™¨å‘ç»™æ¯ä¸ªå®¢æˆ·ç«¯æ•°æ®åŒ…ä»¥åï¼Œåº”è¯¥è‡ªå·±å†³å®šä¸‹ä¸€ä¸ªåŒ…ä»€ä¹ˆæ—¶å€™å‘ï¼Œå†³å®šçš„ä¾æ®æ˜¯ç”¨æˆ·çš„å¸¦å®½ã€ç”¨æˆ·è®¾ç½®çš„æ¯ç§’æ›´æ–°é¢‘ç‡ã€‚å¦‚æœç”¨æˆ·è¦æ±‚æ›´æ–°20æ¬¡æ¯ç§’ï¼Œé‚£ä¹ˆéœ€è¦ç­‰å¾…50msä»¥åä¸‹ä¸ªæ›´æ–°åŒ…æ‰èƒ½å‘é€ã€‚å¦‚æœæ¿€æ´»äº†å¸¦å®½é™åˆ¶ï¼ˆè€ŒæœåŠ¡å™¨å¸§ç‡åˆè¶³å¤Ÿé«˜ï¼‰ï¼Œæˆ‘ä»¬å¯èƒ½å°±éœ€è¦ç­‰å¾…æ¯”å¦‚61msï¼ˆæˆ–å…¶ä»–&#20540;ï¼‰ä»¥åå‘é€ä¸‹ä¸€ä¸ªæ›´æ–°åŒ…ã€‚å› æ­¤ï¼ŒåŠæ¡å‘½æ¸¸æˆæ•°æ®åŒ…å‘é€é—´éš”æ˜¯éšæœºçš„ã€‚åŸºäºæœåŠ¡å™¨çš„è¿™ç§æƒ…å†µï¼Œå°†å¯åŠ¨ç‚¹ä½œä¸ºä¸€ä¸ªå˜é‡ï¼Œç§»åŠ¨åˆ°æœ€æ–°ç›®æ ‡ç‚¹è¿›è¡Œæ’&#20540;è¿™ç§æ–¹æ³•æ•ˆæœæ¬ ä½³ã€‚</strong><br><br>[8]Which Half-Life encodes in the lerp_msec field of the usercmd_t structure described previously. (Return)</p><br><p><strong>ã€8ã€‘åŠæ¡å‘½ä»£ç ä¸­usercmd_tç»“æ„ä¸­å˜é‡lerp_msecå‰é¢æè¿°è¿‡ã€‚</strong><br><br>[9]For weapons that fire projectiles, lag compensation is more problematic. For instance, if the projectile lives autonomously on the server, then what time space should the projectile live in? Does every other player need to be &quot;moved backward&quot; every time<br> the projectile is ready to be simulated and moved by the server? If so, how far backward in time should the other players be moved? These are interesting questions to consider. In Half-Life, we avoided them; we simply donâ€™t lag compensate projectile objects<br> (thatâ€™s not to say that we donâ€™t predict the sound of you firing the projectile on the client, just that the actual projectile is not lag compensated in any way). (Return)</p><br><p><strong>ã€9ã€‘å¯¹äºå‘å°„å¯¼å¼¹çš„æ­¦å™¨ï¼Œå»¶è¿Ÿè¡¥å¿æœ‰æ›´å¤šéœ€è¦è§£å†³çš„é—®é¢˜ã€‚å‡å¦‚<span style="font-weight:bold">å¯¼å¼¹æ˜¯ç”±æœåŠ¡å™¨å¤„ç†çš„ï¼Œé‚£ä¹ˆå¯¼å¼¹åº”è¯¥ä½äºå“ªä¸ªæ—¶é—´åŒºé—´ï¼Ÿæ¯æ¬¡å¯¼å¼¹å‡†å¤‡å‘å°„çš„æ—¶å€™ï¼Œæ˜¯å¦éœ€è¦æŠŠæ¯ä¸ªç©å®¶å¾€åæ‹‰ä¸€æ®µæ—¶é—´çš„ï¼Ÿå¦‚æœæ˜¯è¿™æ ·ï¼Œé‚£ä¹ˆéœ€è¦å¾€åæ‹‰å¤šå°‘ï¼Ÿè¿™äº›é—®é¢˜æ˜¯éœ€è¦è€ƒè™‘çš„ã€‚åœ¨åŠæ¡å‘½ä¸­ï¼Œä¸ºäº†é¿å…è¿™ç§é—®é¢˜ï¼Œæˆ‘ä»¬å¯¹å¯¼å¼¹ä¸è¿›è¡Œå»¶è¿Ÿè¡¥å¿ï¼ˆè¿™å¹¶ä¸æ„å‘³ç€å®¢æˆ·ç«¯ä¸è¿›è¡Œå£°éŸ³é¢„æµ‹ï¼Œåªæ˜¯å®é™…çš„å¯¼å¼¹ä¸è¿›è¡Œå»¶è¿Ÿè¡¥å¿ï¼‰ã€‚</span></strong><br><br>[10]This is the phrase our user community has adopted to describe this inconsistency. (Return)<br><br></p><br><p><strong>ã€10ã€‘ç”¨æˆ·ç¤¾åŒºé€šå¸¸é‡‡ç”¨è¿™ç§æƒ…å†µæ¥æè¿°ä¸ä¸€è‡´æ€§ã€‚</strong></p>

      


      

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Valve/" rel="tag"><i class="fa fa-tag"></i> Valve</a>
            
          </div>
        

        
        
        

        
          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/cplusplus_confused_points_two/" rel="next" title="C++å¾ˆåŸºç¡€çš„æ˜“æ··æ·†ç‚¹äºŒ">
                  <i class="fa fa-chevron-left"></i> 
                  <p class="post-nav-pre-next-title">
                    C++å¾ˆåŸºç¡€çš„æ˜“æ··æ·†ç‚¹äºŒ
                  </p> 
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/Sourceå¼•æ“å¤šäººæ¸¸æˆç½‘ç»œè®¾è®¡/" rel="prev" title="Sourceå¼•æ“å¤šäººæ¸¸æˆç½‘ç»œè®¾è®¡">
                <p class="post-nav-pre-next-title">
                    Sourceå¼•æ“å¤šäººæ¸¸æˆç½‘ç»œè®¾è®¡
                </p> 
                <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        

        
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/uploads/avatar.png" alt="Mike">
          </a>
          <p class="site-author-name" itemprop="name">Mike</p>
           
              <p class="site-description motion-element" itemprop="description">ğŸš™ ğŸš— ğŸ’¨ ğŸ’¨ If you want to create a blog like this, just follow my open-source project, "hexo-theme-neo", click the GitHub button below and check it out ^_^ . It is recommended to use Chrome, Safari, or Edge to read this blog since this blog was developed on Edge (Chromium kernel version) and tested on Safari.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">298</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">111</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">about</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/no5ix" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://open.spotify.com/user/313duq77ekebrfyak3xijqewzss4?si=e7653b829a9747bf" target="_blank" title="Spotify">
                  
                    <i class="fa fa-fw fa-spotify"></i>
                  
                    
                      Spotify
                    
                </a>
              </span>
            
          
          
          <!-- ç½‘æ˜“äº‘éŸ³ä¹ -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- ç½‘æ˜“äº‘éŸ³ä¹ -->

        </div>

        
        

        
        

        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#è‡ªæˆ‘æ€»ç»“"><span class="nav-text">è‡ªæˆ‘æ€»ç»“</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#åŸæ–‡"><span class="nav-text">åŸæ–‡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Contents"><span class="nav-text">Contents</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview"><span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic_Architecture_of_a_Client_.2F_Server_Game"><span class="nav-text">Basic Architecture of a Client / Server Game</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Contents_of_the_User_Input_messages"><span class="nav-text">Contents of the User Input messages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client_Side_Prediction"><span class="nav-text">Client Side Prediction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client-Side_Prediction_of_Weapon_Firing"><span class="nav-text">Client-Side Prediction of Weapon Firing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Umm.2C_This_is_a_Lot_of_Work"><span class="nav-text">Umm, This is a Lot of Work</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Display_of_Targets"><span class="nav-text">Display of Targets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lag_Compensation"><span class="nav-text">Lag Compensation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Game_Design_Implications_of_Lag_Compensation"><span class="nav-text">Game Design Implications of Lag Compensation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-text">Conclusion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Footnotes"><span class="nav-text">Footnotes</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ä¸­è‹±å¯¹ç…§"><span class="nav-text">ä¸­è‹±å¯¹ç…§</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ç»¼è¿°"><span class="nav-text">ç»¼è¿°</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C/Sæ¸¸æˆçš„åŸºæœ¬æ¶æ„"><span class="nav-text">C/Sæ¸¸æˆçš„åŸºæœ¬æ¶æ„</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ç”¨æˆ·æ¶ˆæ¯çš„å†…å®¹"><span class="nav-text">ç”¨æˆ·æ¶ˆæ¯çš„å†…å®¹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#å®¢æˆ·ç«¯é¢„æµ‹"><span class="nav-text">å®¢æˆ·ç«¯é¢„æµ‹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#å¼€ç«è¿‡ç¨‹ä¸­çš„å®¢æˆ·ç«¯é¢„æµ‹"><span class="nav-text">å¼€ç«è¿‡ç¨‹ä¸­çš„å®¢æˆ·ç«¯é¢„æµ‹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ä¸€äº›å·¥ä½œ"><span class="nav-text">ä¸€äº›å·¥ä½œ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ç›®æ ‡çš„æ˜¾ç¤º"><span class="nav-text">ç›®æ ‡çš„æ˜¾ç¤º</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#å»¶è¿Ÿè¡¥å¿"><span class="nav-text">å»¶è¿Ÿè¡¥å¿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#æ¸¸æˆæ¶‰åŠä¸­å»¶è¿Ÿè¡¥å¿çš„ä½¿ç”¨"><span class="nav-text">æ¸¸æˆæ¶‰åŠä¸­å»¶è¿Ÿè¡¥å¿çš„ä½¿ç”¨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#æ€»ç»“"><span class="nav-text">æ€»ç»“</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#è„šæ³¨"><span class="nav-text">è„šæ³¨</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mike</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  















  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/mediumzoom/medium-zoom.js?v=1.1.0"></script>





  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

    <script src="/js/src/local-search.js"></script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>






<script type="text/javascript" src="/js/src/headroom.js"></script>

<!-- ä»£ç å—å¤åˆ¶åŠŸèƒ½ -->
<script type="text/javascript" src="/js/src/code-highlight-modification.js"></script>

<!-- Flashcards Script -->
<script type="text/javascript" src="/js/src/flashcards.js"></script>
