<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


  <meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">

<script>
    (function(){
        if(''){
            let localStoragePasswdKey = 'Algo Tricks' + '_last_passwd';
            let tryCnt = 0;
            function checkPassword(password) {
                password = password == null ? null : password.trim();
                if (password !== '') {
                    if (password != null) {
                        // 如果用户点击了确认而且密码错误的时候, 因为当password == null的时候说明用户点了取消
                        alert('Error!');
                        if (++tryCnt < 3) {
                            password = prompt('Open Sesame');
                            checkPassword(password);
                            return;
                        }
                    }

                    // if (history.length > 1) {
                    //     alert('back!');
                    //     history.back();
                    // } else {
                        // alert('blankkkk!');
                    //     window.location.href = "about:blank";
                    // }
                    if (document.referrer) {
                        window.location.href = document.referrer;
                    } else {
                        window.location.href = "about:blank";; // fallback if no referrer
                    }

                } else {
                    localStorage.setItem(localStoragePasswdKey, password);
                }
            }

            var password_verify_on_local = false;
            const hostname = window.location.hostname;
            if (password_verify_on_local || (!(hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1" || hostname.startsWith("192")))) {
                const lspk = localStorage.getItem(localStoragePasswdKey) || "";
                if (lspk !== '') {
                    var password = prompt('Open Sesame');
                    checkPassword(password);
                }
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">





















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Algo,noodle,Java,NA,LeetCode,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="算法白话总结 参考: https://programmercarl.com/ 推荐参考本博客总结的 algo_newbie , 和本文对照着看  . . .">
<meta name="keywords" content="Algo,noodle,Java,NA,LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="Algo Tricks">
<meta property="og:url" content="https://hulinhong.com/algo_na_tricks/index.html">
<meta property="og:site_name" content="🚙">
<meta property="og:description" content="算法白话总结 参考: https://programmercarl.com/ 推荐参考本博客总结的 algo_newbie , 和本文对照着看  . . .">
<meta property="og:locale" content="en">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">
<meta property="og:updated_time" content="2025-10-15T02:49:27.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algo Tricks">
<meta name="twitter:description" content="算法白话总结 参考: https://programmercarl.com/ 推荐参考本博客总结的 algo_newbie , 和本文对照着看  . . .">
<meta name="twitter:image" content="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: false,
    mediumzoom: true,
    darkmode_js: false,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":188,"transition":{"header":"fadeIn","menu":"fadeIn","logo":"fadeIn","post_block_else":"fadeIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"fadeIn","footer":"fadeIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>Algo Tricks | 🚙</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">🚙</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">💨 💨 💨</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <div class="site-search-div">
    <button class="search-icon" id="search-button">
      <i class="fa fa-search"></i>
    </button>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">×</i>
  </div>


<script type="text/javascript" id="local.search.active">
    {/* var inputArea       = document.querySelector("#local-search-input");
    inputArea.onclick   = function(){ getSearchFile(); this.focus(); }
    inputArea.onkeydown = function(){ if(event.keyCode == 13) return false } */}
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/algo_na_tricks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mike">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="🚙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Algo Tricks</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-15T00:54:08+00:00">
                08-15-2020
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index">
                    <span itemprop="name">Algo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            <div class="post-tags">
              
                <a href="/tags/Algo/" rel="tag"><i class="fa fa-tag"></i> Algo</a>
              
                <a href="/tags/noodle/" rel="tag"><i class="fa fa-tag"></i> noodle</a>
              
                <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              
                <a href="/tags/NA/" rel="tag"><i class="fa fa-tag"></i> NA</a>
              
                <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i> LeetCode</a>
              
            </div>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/cpu_core_processor_thread_info/" rel="next" title="逻辑CPU与核心备忘">
                <i class="fa fa-chevron-left"></i> 
                <p class="post-nav-pre-next-title">
                  逻辑CPU与核心备忘
                </p> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/muduo_qa/" rel="prev" title="muduo详解之网络编程难点解读">
              <p class="post-nav-pre-next-title">
                  muduo详解之网络编程难点解读
              </p> 
              <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

      
      

      
        <h1 id="算法白话总结"><a href="#算法白话总结" class="headerlink" title="算法白话总结"></a>算法白话总结</h1><ul>
<li>参考: <a href="https://programmercarl.com/" target="_blank" rel="noopener">https://programmercarl.com/</a></li>
<li>推荐参考<strong>本博客总结</strong>的 <a href="/algo_newbie/" title="algo_newbie">algo_newbie</a> , 和本文对照着看</li>
</ul>
<p><strong>. . .</strong><a id="more"></a></p>
<h1 id="概绍"><a href="#概绍" class="headerlink" title="概绍"></a>概绍</h1><p>本群的每日刷题打卡活动, 按照 GitHub 49k star的项目 <a href="https://github.com/youngyangyang04/leetcode-master" target="_blank" rel="noopener">https://github.com/youngyangyang04/leetcode-master</a> 的刷题顺序.<br>跟着群里有个伴一起刷题或许更容易坚持达成每日一题的目标. 做完题目之后可以在群里的小程序”今日leetcode刷题打卡”里打卡. </p>
<ul>
<li>网页版: 代码随想录 <a href="https://programmercarl.com/" target="_blank" rel="noopener">https://programmercarl.com/</a></li>
<li>本博客只记录那些有明显自我疑问而&lt;&lt;代码随想录&gt;&gt;没有说明清楚的题目, 会标识出来并注释</li>
</ul>
<h1 id="北美算法面试性价比topic类型"><a href="#北美算法面试性价比topic类型" class="headerlink" title="北美算法面试性价比topic类型"></a>北美算法面试性价比topic类型</h1><ul>
<li>Binary Search</li>
<li>Binary Tree</li>
<li>BFS + Topological Sorting</li>
<li>DFS</li>
<li>Graph</li>
<li>Heap + Monotonic Stack</li>
<li>Two Pointers, Sliding window</li>
<li><a href="#Sweep-Line">Sweep Line</a> + Prefix Sum</li>
</ul>
<h1 id="本文完整参考代码"><a href="#本文完整参考代码" class="headerlink" title="本文完整参考代码"></a>本文完整参考代码</h1><p><a href="https://github.com/no5ix/no5ix.github.io/blob/source/source/code/test_algo_na.java" target="_blank" rel="noopener">https://github.com/no5ix/no5ix.github.io/blob/source/source/code/test_algo_na.java</a></p>
<h1 id="常用小技巧"><a href="#常用小技巧" class="headerlink" title="常用小技巧"></a>常用小技巧</h1><h2 id="如何求一个数字有多少位数"><a href="#如何求一个数字有多少位数" class="headerlink" title="如何求一个数字有多少位数"></a>如何求一个数字有多少位数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigitCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countDigits</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理数字为 0 的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理负数的情况，将其转换为正数</span></span><br><span class="line">        number = Math.abs(number);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            number /= <span class="number">10</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">12345</span>;</span><br><span class="line">        <span class="keyword">int</span> digitCount = countDigits(num);</span><br><span class="line">        System.out.println(<span class="string">"数字 "</span> + num + <span class="string">" 的位数是: "</span> + digitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从最高位数开始遍历一个数字"><a href="#从最高位数开始遍历一个数字" class="headerlink" title="从最高位数开始遍历一个数字"></a>从最高位数开始遍历一个数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">7893</span>;</span><br><span class="line"><span class="keyword">int</span> divisor = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (number / divisor &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    divisor *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> digit = number / divisor;  <span class="comment">// 获取当前最高位的数字</span></span><br><span class="line">    System.out.println(digit);</span><br><span class="line">    number %= divisor;  <span class="comment">// 去掉已经处理过的最高位</span></span><br><span class="line">    divisor /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从个位数开始遍历一个数字"><a href="#从个位数开始遍历一个数字" class="headerlink" title="从个位数开始遍历一个数字"></a>从个位数开始遍历一个数字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigitTraversal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">12345</span>;</span><br><span class="line">        traverseDigitsFromRight(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseDigitsFromRight</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当数字不为 0 时，继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 取当前数字的个位数</span></span><br><span class="line">            <span class="keyword">int</span> digit = number % <span class="number">10</span>;</span><br><span class="line">            System.out.println(digit);</span><br><span class="line">            <span class="comment">// 去掉当前数字的个位数</span></span><br><span class="line">            number /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Java常用接口和实现"><a href="#Java常用接口和实现" class="headerlink" title="Java常用接口和实现"></a>Java常用接口和实现</h1><h2 id="Convert-a-number-to-a-string-and-vice-versa"><a href="#Convert-a-number-to-a-string-and-vice-versa" class="headerlink" title="Convert a number to a string and vice versa"></a>Convert a number to a string and vice versa</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">String str = String.valueOf(num);  <span class="comment">// better</span></span><br><span class="line">String str = num + <span class="string">""</span>; <span class="comment">// worse, this method is simple but not efficient.</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> num = Integer.valueOf(str); <span class="comment">// Returns an Integer object but can be unboxed to int</span></span><br></pre></td></tr></table></figure>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>方法1: (推荐)</p>
<ul>
<li>nextInt() 返回的是任意整数，范围包括负数和正数。</li>
<li>nextInt(bound) 返回一个随机整数，范围是从 0 到 bound（不包括 bound）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果你想生成一个 1 到 100 之间的随机整数（包括1和100），可以这样写：</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> randomNumber = random.nextInt(<span class="number">100</span>) + <span class="number">1</span>; <span class="comment">// 加1，使得范围变为 [1, 100]</span></span><br><span class="line">System.out.println(randomNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the range [5, 10]</span></span><br><span class="line"><span class="keyword">int</span> min = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// Generate random number in the range [5, 10]</span></span><br><span class="line"><span class="keyword">int</span> randomNumber2 = random.nextInt((max - min) + <span class="number">1</span>) + min;</span><br></pre></td></tr></table></figure>
<p>方法2: (不推荐)</p>
<blockquote>
<p>To generate a random number within the range <code>[3, 6]</code>, where both 3 and 6 are inclusive, you can modify the logic slightly from the <code>[3, 6)</code> approach: <code>double randomNumber = 3 + (Math.random() * (6 - 3 + 1));</code></p>
</blockquote>
<ol>
<li><code>Math.random()</code> generates a random number in the range <code>[0.0, 1.0)</code>.</li>
<li>Multiplying it by <code>(6 - 3 + 1)</code> (which is 4) adjusts the range to <code>[0.0, 4.0)</code>.</li>
<li>Adding 3 shifts the range to <code>[3.0, 7.0)</code>.</li>
<li>Since the inclusive range is <code>[3, 6]</code>, you’ll need to truncate or floor the result if you’re generating an integer: <code>int picked = (int) ((high - low + 1) * Math.random()) + low;</code></li>
<li>Notice: remember that <code>int picked = (int) (high - low + 1) * Math.random() + low;</code> is not correct, because it will cause the error “incompatible types: possible lossy conversion from double to int”, you should always convert the multiplication result <code>((high - low + 1) * Math.random())</code> to an Integer but not <code>(high - low + 1)</code> only</li>
</ol>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><ul>
<li>记住：Java 中只有值传递！只是对于对象类型，值是对象的引用地址，这使得我们可以修改对象的内容，但不能改变对象的引用本身。</li>
<li>基本数据类型： 方法接收变量的值，修改不会影响原始变量。</li>
<li>对象类型：<ul>
<li>方法接收的是对象引用的副本，可以通过引用修改对象内容。</li>
<li>方法不能改变引用本身的指向。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	解释：在 changeReference 方法中，person 被赋值为一个新的对象，但这只是改变了方法内的 person 引用，并不影响 main 方法中 p 的引用。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceReassignment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.name = <span class="string">"Alice"</span>;</span><br><span class="line">        changeReference(p);</span><br><span class="line">        System.out.println(<span class="string">"Name after method call: "</span> + p.name); <span class="comment">// 输出 "Alice"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeReference</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person = <span class="keyword">new</span> Person(); <span class="comment">// 新建一个对象</span></span><br><span class="line">        person.name = <span class="string">"Bob"</span>;  <span class="comment">// 修改新对象的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="常用简单排序"><a href="#常用简单排序" class="headerlink" title="常用简单排序"></a>常用简单排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Arrays.sort 用于对数组进行排序（primitive 或 Object 类型）。</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(nums); <span class="comment">// 对数组排序, increase </span></span><br><span class="line"><span class="comment">// Integer[] nums = &#123;3, 1, 4, 2&#125;;</span></span><br><span class="line">Arrays.sort(nums, Comparator.reverseOrder()); <span class="comment">// decrease</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Collections.sort 用于对 List 集合进行排序（如 ArrayList、LinkedList 等）。</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">Collections.sort(list); <span class="comment">// 对 List 排序</span></span><br></pre></td></tr></table></figure>
<p>举例说明自定义数字排序规则, 使用 Comparator: </p>
<ul>
<li>Collections.sort</li>
<li>Arrays.sort</li>
</ul>
<h3 id="sort-by-primitive-type"><a href="#sort-by-primitive-type" class="headerlink" title="sort by primitive type"></a>sort by primitive type</h3><p>using lambda </p>
<figure class="highlight java"><figcaption><span>increasing order</span></figcaption><table><tr><td class="code"><pre><span class="line">(a, b) -&gt; a - b</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>decreasing order</span></figcaption><table><tr><td class="code"><pre><span class="line">(a, b) -&gt; b - a</span><br></pre></td></tr></table></figure>
<h4 id="sort-by-int"><a href="#sort-by-int" class="headerlink" title="sort by int"></a>sort by int</h4><p>以下例子的这个排序逻辑首先按列 col 排序，如果列相同，则按行 row 排序，再根据节点的值进行排序。排序优先级依次是：列、行、值<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// : List to store nodes with their column, row, and value</span></span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// nodes.add(new int[]&#123;col, row, val&#125;);</span></span><br><span class="line">nodes.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">nodes.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">nodes.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort nodes by column, row, and value</span></span><br><span class="line"><span class="comment">// 解释：</span></span><br><span class="line"><span class="comment">//     •	Collections.sort() 是 Java 中用于排序 List 的方法。它接受两个参数，第一个是需要排序的 List（在这里是 nodes），第二个是排序规则（通过 Comparator 来定义）。</span></span><br><span class="line"><span class="comment">//     •	这是一个 lambda 表达式，它实现了 Comparator&lt;int[]&gt; 接口。tuple1 和 tuple2 是 nodes 中的元素（即 int[] 类型的数组）。tuple1 和 tuple2 是用来比较的两个元素。</span></span><br><span class="line">Collections.sort(nodes, (tuple1, tuple2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 排序规则:</span></span><br><span class="line">    <span class="comment">//     1.	首先比较 tuple1[0] 和 tuple2[0]：</span></span><br><span class="line">    <span class="comment">//          如果它们不相等（即列 col 不相同），则按列进行排序。</span></span><br><span class="line">    <span class="comment">//     2.	如果列相同，则比较 tuple1[1] 和 tuple2[1]：</span></span><br><span class="line">    <span class="comment">//          如果列相同，再按照行 row 进行排序。</span></span><br><span class="line">    <span class="comment">//     3.	如果列和行都相同，则比较 tuple1[2] 和 tuple2[2]：</span></span><br><span class="line">    <span class="comment">//          最后，如果列和行都相同，则按照节点的值进行排序。</span></span><br><span class="line">    <span class="keyword">if</span> (tuple1[<span class="number">0</span>] != tuple2[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">// 这里的 tuple1[0] - tuple2[0] 是用来确定排序的方向。如果 tuple1[0] 小于 tuple2[0]，结果为负数，意味着 tuple1 排在 tuple2 前面；如果大于，结果为正数，tuple1 排在后面；如果相等，则继续比较后续条件。</span></span><br><span class="line">        <span class="keyword">return</span> tuple1[<span class="number">0</span>] - tuple2[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tuple1[<span class="number">1</span>] != tuple2[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple1[<span class="number">1</span>] - tuple2[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tuple1[<span class="number">2</span>] - tuple2[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="sort-by-char"><a href="#sort-by-char" class="headerlink" title="sort by char"></a>sort by char</h4><p>举例说明自定义字母排序规则 (比如有个 List<string> 的list, 如何按照首字母的来排序): </string></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"date"</span>, <span class="string">"grape"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照首字母排序</span></span><br><span class="line">        <span class="comment">// • [推荐]	s1.charAt(0) 和 s2.charAt(0) 获取字符串的首字母。</span></span><br><span class="line">        Collections.sort(list, (s1, s2) -&gt; &#123;  <span class="comment">// 推荐这个方法</span></span><br><span class="line">            <span class="keyword">return</span> s1.charAt(<span class="number">0</span>) - s2.charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// • [不推荐, 不好记]	Character.compare 是 Java 提供的方法，用于比较两个字符的大小。</span></span><br><span class="line">        Collections.sort(list, (s1, s2) -&gt; Character.compare(s1.charAt(<span class="number">0</span>), s2.charAt(<span class="number">0</span>))); <span class="comment">// 不推荐, 因为Character.compare不好记</span></span><br><span class="line"></span><br><span class="line">        System.out.println(list); <span class="comment">// 输出: [apple, banana, cherry, date, grape]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sort-by-wrapper-type"><a href="#sort-by-wrapper-type" class="headerlink" title="sort by wrapper type"></a>sort by wrapper type</h3><p>using lambda and <code>compareTo</code></p>
<figure class="highlight java"><figcaption><span>ascending order</span></figcaption><table><tr><td class="code"><pre><span class="line">(a, b) -&gt; &#123; <span class="keyword">return</span> a.compareTo(b); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>descending order</span></figcaption><table><tr><td class="code"><pre><span class="line">(a, b) -&gt; &#123; <span class="keyword">return</span> b.compareTo(a); &#125;</span><br></pre></td></tr></table></figure>
<p>实例:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"watermelon"</span>&#125;;</span><br><span class="line"><span class="comment">//        Arrays.sort(arr, (a, b) -&gt; a.compareTo(b));</span></span><br><span class="line">Arrays.sort(arr, (a, b) -&gt; b.compareTo(a));</span><br><span class="line"><span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>result:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watermelon</span><br><span class="line">banana</span><br><span class="line">apple</span><br></pre></td></tr></table></figure></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">map.get(<span class="number">1</span>);</span><br><span class="line">map.getOrDefault(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">map.containsKey(<span class="number">1</span>);</span><br><span class="line">map.size();</span><br><span class="line">map.isEmpty();</span><br><span class="line"><span class="comment">// 如果你需要同时遍历键和值，通常会使用 Map.Entry 或 entrySet() 方法。</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; es: map.entrySet()) &#123;</span><br><span class="line">    System.out.println(es.getKey());</span><br><span class="line">    System.out.println(es.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// keySet(): 返回 Map 中所有键的 Set 视图。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : map.keySet()) &#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// values(): 返回 Map 中所有值的 Collection 视图, 为啥不是valueSet, 因为value不是唯一的, 不是set</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : map.values()) &#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line">map.remove(<span class="number">1</span>);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.clear();</span><br></pre></td></tr></table></figure>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="number">2</span>);</span><br><span class="line">set.add(<span class="number">23</span>);</span><br><span class="line">set.add(<span class="number">231</span>);</span><br><span class="line">set.remove(<span class="number">231</span>);</span><br><span class="line">set.size();</span><br><span class="line">set.isEmpty();</span><br><span class="line">System.out.println(<span class="string">"set.contains(2) : "</span> + set.contains(<span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">"set.contains(231) : "</span> + set.contains(<span class="number">231</span>));</span><br><span class="line">System.out.println(set);</span><br><span class="line">set.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Set&lt;String&gt; 转换为 String[]</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>));</span><br><span class="line">String[] array = set.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">11</span>);</span><br><span class="line">list.add(<span class="number">23</span>);</span><br><span class="line">list.add(<span class="number">31</span>);</span><br><span class="line">list.add(<span class="number">377</span>);</span><br><span class="line">list.size();</span><br><span class="line">list.remove(<span class="number">0</span>);  <span class="comment">// 0 is index</span></span><br><span class="line">list.removeLast();</span><br><span class="line">list.get(<span class="number">0</span>);</span><br><span class="line">list.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">list.set(<span class="number">2</span>, <span class="number">33</span>);</span><br><span class="line">System.out.println(<span class="string">"list: "</span> + list);</span><br><span class="line">list.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 打印原生数组得</span></span><br><span class="line"><span class="keyword">int</span>[] ss = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">ss[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">ss[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] ssi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">ssi[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">ssi[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(ss));  <span class="comment">// 一维数组</span></span><br><span class="line">System.out.println(Arrays.deepToString(ssi));  <span class="comment">// 多维数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// slice operation</span></span><br><span class="line"><span class="keyword">int</span>[] points = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] result = Arrays.copyOfRange(points, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// result = &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; subList = list.subList(<span class="number">1</span>, <span class="number">4</span>); <span class="comment">// 切片：从索引 1 到 4（不包括 4）</span></span><br><span class="line">System.out.println(subList); <span class="comment">// 输出：[2, 3, 4]</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">///////////////////////</span></span><br><span class="line"><span class="comment">///  只要类实现了 Collection 接口，都支持 toArray() 方法。这包括：</span></span><br><span class="line"><span class="comment">//     •	List</span></span><br><span class="line"><span class="comment">//     •	Set</span></span><br><span class="line"><span class="comment">//     •	Queue</span></span><br><span class="line"><span class="comment">//     •	Deque</span></span><br><span class="line"><span class="comment">//     •	其他直接实现 Collection 的类</span></span><br><span class="line"><span class="comment">// 对于特定类型数组，推荐使用 toArray(T[] a) 方法，避免不必要的类型转换问题。</span></span><br><span class="line"><span class="comment">// List 转换为原生数组, 推荐使用这种方法，因为它直接返回指定类型的数组，避免类型转换问题。</span></span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">String[] array = list2.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]); <span class="comment">// 将集合中的元素存储到传入的数组`new String[0]`中，如果这个传入的数组容量不足(当前为0, 当然也可以写3就刚好够或者写2就不够, JVM 会自动分配合适大小的数组)，则会创建一个新数组。当然也可以直接传入合适的size (new String[list2.size()]);)</span></span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line">String[] array2 = list2.toArray(<span class="keyword">new</span> String[list2.size()]);  <span class="comment">// 当然也可以直接传入合适的size</span></span><br><span class="line"></span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();  <span class="comment">// 不要用 LinkedList(除非你要往队列里插入null, 因为ArrayDeque不准插入null, 但是LinkedList可以), ArrayDeque用circular buffer实现的, 是最高效的: https://stackoverflow.com/questions/6129805/what-is-the-fastest-java-collection-with-the-basic-functionality-of-a-queue</span></span><br><span class="line">queue.offer(<span class="number">1</span>);</span><br><span class="line">queue.offer(<span class="number">2</span>);</span><br><span class="line">queue.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : queue) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(<span class="string">"queue: "</span> + queue);</span><br><span class="line">queue.peek();</span><br><span class="line">queue.poll();</span><br><span class="line">queue.size();</span><br><span class="line">queue.clear();</span><br><span class="line">queue.isEmpty();</span><br></pre></td></tr></table></figure>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();  <span class="comment">// 不要用 LinkedList(除非你要往队列里插入null, 因为ArrayDeque不准插入null, 但是LinkedList可以), ArrayDeque用circular buffer实现的, 是最高效的: https://stackoverflow.com/questions/6129805/what-is-the-fastest-java-collection-with-the-basic-functionality-of-a-queue</span></span><br><span class="line">deque.offerFirst(<span class="number">1</span>);</span><br><span class="line">deque.offerLast(<span class="number">2</span>);</span><br><span class="line">deque.offerLast(<span class="number">23</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : deque) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(deque);</span><br><span class="line">deque.pollFirst();</span><br><span class="line"><span class="keyword">int</span> resultValue = deque.pollLast();</span><br><span class="line"><span class="keyword">int</span> headValue = deque.peekFirst();</span><br><span class="line"><span class="keyword">int</span> tailValue = deque.peekLast();</span><br><span class="line">System.out.println(resultValue);</span><br><span class="line">System.out.println(<span class="string">"deque: "</span> + deque);</span><br><span class="line">deque.clear();</span><br><span class="line">deque.size();</span><br></pre></td></tr></table></figure>
<h2 id="Stack-一般不用因为有性能问题"><a href="#Stack-一般不用因为有性能问题" class="headerlink" title="Stack(一般不用因为有性能问题)"></a>Stack(一般不用因为有性能问题)</h2><p><strong>注意!!!</strong> 在 Java 中，如果我们希望避免使用 <code>Stack</code> 类以减少同步带来的性能问题，可以使用其他不包含同步的集合类实现栈（stack）的功能，例如 <code>Deque</code>（双端队列）。<code>Deque</code> 接口的实现类如 <code>ArrayDeque</code> 都是很好的选择。<code>Deque</code>也可以直接 <code>push</code>, <code>pop</code>, <code>peek</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.peek();</span><br><span class="line">stack.pop();</span><br><span class="line">stack.isEmpty();</span><br><span class="line">stack.size();</span><br><span class="line">stack.clear();</span><br></pre></td></tr></table></figure>
<h2 id="String-and-Character"><a href="#String-and-Character" class="headerlink" title="String and Character"></a>String and Character</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Why use equals()?</span></span><br><span class="line"><span class="comment">// because == checks if the two objects are the same instance, whereas equals() compares the actual content of the strings.</span></span><br><span class="line">String testStr = <span class="string">"aa"</span>;</span><br><span class="line"><span class="keyword">if</span> (testStr.equals(<span class="string">"bb"</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"testStr is equal to 'bb'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Character API</span></span><br><span class="line"><span class="keyword">boolean</span> realDigit = Character.isDigit(<span class="string">'8'</span>);</span><br><span class="line"><span class="keyword">boolean</span> fakeDigit = Character.isDigit(<span class="string">'u'</span>);</span><br><span class="line"><span class="keyword">char</span> testDigit = <span class="string">'9'</span>;</span><br><span class="line"><span class="keyword">boolean</span> res = Character.isLetterOrDigit(testDigit);</span><br><span class="line">res = Character.toUpperCase(testDigit);</span><br><span class="line">res = Character.toLowerCase(testDigit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String API</span></span><br><span class="line"><span class="keyword">char</span>[] charArr = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">String char2String = <span class="keyword">new</span> String(charArr);</span><br><span class="line"></span><br><span class="line">String str = <span class="string">" testString  "</span>;</span><br><span class="line"><span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(charArray);</span><br><span class="line">System.out.println(<span class="string">"str.length(): "</span> + str.length());</span><br><span class="line">str.charAt(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"str.substring(1, 4) :"</span> + str.substring(<span class="number">1</span>, <span class="number">4</span>));  <span class="comment">// output:tes, 因为substring不包含最后一个4索引的char</span></span><br><span class="line">String trimedString = str.trim();</span><br><span class="line">System.out.println(<span class="string">"trimedString.substring(1, 4) :"</span> + trimedString.substring(<span class="number">1</span>, <span class="number">4</span>));  <span class="comment">// output:est</span></span><br><span class="line">str.isEmpty();</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer / StringBuilder API:</span></span><br><span class="line"><span class="comment">// StringBuffer / StringBuilder 的 append 方法被重载了，可以接受多种类型的参数，包括 int、long、float、double、char 等。注意事项：</span></span><br><span class="line"><span class="comment">// 	•	StringBuilder 是非线程安全的，但性能比 StringBuffer 更高，适用于单线程环境。</span></span><br><span class="line"><span class="comment">// 	•	如果需要线程安全的操作，应使用 StringBuffer。</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// Append</span></span><br><span class="line">sb.append(<span class="string">" World"</span>).append(<span class="number">123</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// Hello World123</span></span><br><span class="line"><span class="comment">// Insert</span></span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">","</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// Hello, World123</span></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line">sb.delete(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// Hello World123</span></span><br><span class="line"><span class="comment">// Replace</span></span><br><span class="line">sb.replace(<span class="number">6</span>, <span class="number">11</span>, <span class="string">"Java"</span>);</span><br><span class="line">System.out.println(sb); <span class="comment">// Hello Java123</span></span><br><span class="line"><span class="comment">// Reverse</span></span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb); <span class="comment">// 321avaJ olleH</span></span><br><span class="line">String newStr = sb.toString();</span><br><span class="line">System.out.println(newStr);</span><br></pre></td></tr></table></figure>
<h1 id="复杂度有啥用"><a href="#复杂度有啥用" class="headerlink" title="复杂度有啥用"></a>复杂度有啥用</h1><p>留意数据规模, 不要以为复杂度分析是专门用来难为你的，它其实是来帮你的，它是来偷偷告诉你解题思路的。<br>你应该在开始写代码之前就留意题目给的数据规模，因为复杂度分析可以避免你在错误的思路上浪费时间，有时候它甚至可以直接告诉你这道题用什么算法。<br>为啥这样说呢，因为一般题目都会告诉我们测试用例的数据规模有多大，<strong>我们可以根据这个数据规模反推这道题能够允许的时间复杂度在什么范围，进一步反推我们应该要用什么算法</strong>。<br>举例来说吧:  </p>
<ul>
<li>比如一个题目给你输入一个数组，其长度能够达到 10^6 这个量级，那么我们肯定可以知道这道题的时间复杂度大概要小于 O(N2)，得优化成 O(NlogN) 或者 O(N) 才行。因为如果你写的算法是 O(N2) 的，最大的复杂度会达到 10^12 这个量级，在大部分判题系统上都是跑不过去的。<ul>
<li>为了把复杂度控制在 O(NlogN) 或者 O(N)，我们的选择范围就缩小了，可能符合条件的做法是：对数组进行排序处理、前缀和、双指针、一维 dp 等等，从这些思路切入就比较靠谱。像嵌套 for 循环、二维 dp、回溯算法这些思路，基本可以直接排除掉了。</li>
</ul>
</li>
<li>再举个更直接的例子，如果你发现题目给的数据规模很小，比如数组长度 N 不超过 20 这样的，那么我们可以断定这道题大概率要用暴力穷举算法。<ul>
<li>因为判题平台肯定是尽可能扩大数据规模难为你，它一反常态给这么小的数据规模，肯定是因为最优解就是指数/阶乘级别的复杂度。你放心用回溯算法 招呼它就行了，不用想别的算法了。</li>
</ul>
</li>
</ul>
<p>所以说啊，很多读者看题都不看那个数据规模，上来就闷声写代码，这是不对滴。你先把题目给的所有信息都考虑进去，再写代码，这样才能少走弯路。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="诀窍"><a href="#诀窍" class="headerlink" title="诀窍"></a>诀窍</h2><p>没有思路的时候思考以下方法:  </p>
<ul>
<li>口诀: “前二, 双排, 滑倒”</li>
<li><strong>前</strong>缀和 (在涉及计算区间和的问题时非常有用！)</li>
<li><strong>二</strong>分法(当遇到的一个序列是有序的要找一个数之类的问题, 就该用二分法了)</li>
<li><strong>双</strong>指针<ul>
<li>互相靠近: 双指针大多数时候是left指针在首, right在尾, 然后互相逐渐靠近</li>
<li>快慢指针: 或者一个快一个慢, right快(去寻找合适的数)</li>
</ul>
</li>
<li>先<strong>排</strong>个序 (有些问题先排个序再处理就简单了)</li>
<li><strong>滑</strong>动窗口 (求一个<strong>子区间</strong>的<code>最大和</code>/<code>最小和</code>之类的东西)</li>
<li><strong>倒</strong>序遍历 (有些问题倒过来遍历就很简单)</li>
</ul>
<h2 id="二分法诀窍与易错点"><a href="#二分法诀窍与易错点" class="headerlink" title="二分法诀窍与易错点"></a>二分法诀窍与易错点</h2><ul>
<li>为什么要<code>int mid = left + (right - left) / 2</code> ? 答案见下方代码中的注释</li>
<li>是 <code>while (leftIndex &lt;= rightIndex)</code> 还是 <code>while (leftIndex &lt; rightIndex)</code> (<strong>推荐后者</strong>, 因为网上都是后者)? 答案见下方代码注释或者<a href="https://leetcode.cn/problems/binary-search/solutions/8337/er-fen-cha-zhao-xiang-jie-by-labuladong/" target="_blank" rel="noopener">这里</a> 的讲解</li>
<li>二分查找, <strong>如果使用 <code>while (leftIndex &lt; rightIndex)</code>, 当在数组中找不到对应的值, 循环完毕后的left和right的含义是什么?</strong><ul>
<li>如果目标值不在数组中，循环结束时满足条件：right == left，循环结束后的 left 和 right 的含义如下:<ul>
<li>因为 left一直在 <code>left = mid + 1</code>, 所以最终跳出循环时，left 会指向 第一个大于 target 的位置，或者数组末尾的下一个位置；</li>
<li>left/right 指向插入目标值的位置（满足排序要求）。</li>
<li><strong>left 是第一个大于目标值的位置（在数组中的索引）</strong>。</li>
<li>如果目标值比数组中所有元素都大，left 将等于数组的长度，即指向超出数组范围的位置。</li>
</ul>
</li>
<li>情况 1：目标值在数组范围内，但不存在<ul>
<li>数组为 [1, 3, 5, 7, 9]，目标值为 6。<ul>
<li>•    最终状态：</li>
<li>•    left = 3（第一个大于 6 的索引，值为 7）。</li>
<li>•    right = 3（第一个大于 6 的索引，值为 7）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>二分查找, <strong>如果使用 <code>while (leftIndex &lt;= rightIndex)</code>, 当在数组中找不到对应的值, 循环完毕后的left和right的含义是什么?</strong><ul>
<li>如果目标值不在数组中，循环结束时满足条件：right &lt; left，循环结束后的 left 和 right 的含义如下:</li>
<li>left 的含义: <ul>
<li>left 指向插入目标值的位置（满足排序要求）。</li>
<li><strong>left 是第一个大于目标值的位置（在数组中的索引）</strong>。</li>
<li>如果目标值比数组中所有元素都大，left 将等于数组的长度，即指向超出数组范围的位置。</li>
</ul>
</li>
<li>right 的含义:<ul>
<li>right 是目标值的前一个可能位置（如果目标值存在的话）。</li>
<li><strong>right 是最后一个小于目标值的位置（在数组中的索引）</strong>。</li>
<li>如果目标值比数组中所有元素都小，right 将等于 -1，即在数组范围之外。</li>
</ul>
</li>
<li>情况 1：目标值在数组范围内，但不存在<ul>
<li>数组为 [1, 3, 5, 7, 9]，目标值为 6。<ul>
<li>•    最终状态：</li>
<li>•    left = 3（第一个大于 6 的索引，值为 7）。</li>
<li>•    right = 2（最后一个小于 6 的索引，值为 5）。</li>
</ul>
</li>
</ul>
</li>
<li>情况 2：目标值比数组中所有元素小<ul>
<li>数组为 [3, 5, 7, 9]，目标值为 2。<ul>
<li>•    最终状态：</li>
<li>•    left = 0（第一个大于 2 的索引，值为 3）。</li>
<li>•    right = -1（数组范围之外）。</li>
</ul>
</li>
</ul>
</li>
<li>情况 3：目标值比数组中所有元素大<ul>
<li>数组为 [3, 5, 7, 9]，目标值为 10。<ul>
<li>•    最终状态：</li>
<li>•    left = 4（数组长度，超出范围）。</li>
<li>•    right = 3（最后一个索引，值为 9）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>, target 为 2，如果我想得到 target 的<strong>左侧边界</strong>，即索引 1，或者我想得到 target 的<strong>右侧边界</strong>，即索引 3, 怎么做呢? <ul>
<li>见下方代码的<code>left_bound</code>和<code>right_bound</code>, 详细讲解请参考: <a href="https://leetcode.cn/problems/binary-search/solutions/8337/er-fen-cha-zhao-xiang-jie-by-labuladong/" target="_blank" rel="noopener">https://leetcode.cn/problems/binary-search/solutions/8337/er-fen-cha-zhao-xiang-jie-by-labuladong/</a></li>
</ul>
</li>
<li><a href="https://programmercarl.com/0704.二分查找.html#二分法第一种写法" target="_blank" rel="noopener">https://programmercarl.com/0704.二分查找.html#二分法第一种写法</a></li>
<li><a href="https://leetcode.com/problems/binary-search/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-search/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> targetNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNumber &lt; numbers[<span class="number">0</span>] || targetNumber &gt; numbers[numbers.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = numbers.length;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex) &#123;  <span class="comment">// 因为我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right), 所以要使用 &lt; ，因为left == right是没有意义的</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            url: https://stackoverflow.com/questions/27167943/why-leftright-left-2-will-not-overflow</span></span><br><span class="line"><span class="comment">            Q: why left+(right-left)/2 can avoid overflow?</span></span><br><span class="line"><span class="comment">            A: </span></span><br><span class="line"><span class="comment">                Suppose (to make the example easier) the maximum integer is 100, left = 50, and right = 80. If you use the naive formula:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                int mid = (left + right)/2;</span></span><br><span class="line"><span class="comment">                the addition will result in 130, which overflows.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                If you instead do:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                int mid = left + (right - left)/2;</span></span><br><span class="line"><span class="comment">                you can't overflow in (right - left) because you're subtracting a smaller number from a larger number. That always results in an even smaller number, so it can't possibly go over the maximum. E.g. 80 - 50 = 30.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                Mikeeee said: Since (right - left) is the distance between left and right, so `left + (right - left)/2` will not be larger than the right. Furthermore, it will not be larger than the maximum integer.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">int</span> midIndex = leftIndex + ((rightIndex - leftIndex) &gt;&gt; <span class="number">1</span>);  <span class="comment">// &gt;&gt; 1 等同于 除以 2</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[midIndex] == targetNumber) &#123;</span><br><span class="line">                <span class="keyword">return</span> midIndex;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[midIndex] &lt; targetNumber) &#123;</span><br><span class="line">                leftIndex = midIndex + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightIndex = midIndex;  <span class="comment">// 因为当前 numbers[midIndex]不等于 targetNumber ，去左区间继续寻找，而寻找区间是左闭右开区间，所以 rightIndex 更新为midIndex，即：下一个查询区间不会去比较numbers[midIndex]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如说给你有序数组 `nums = [1,2,2,2,3]`, target 为 2，但是如果我想得到 target 的左侧边界，即索引 1</span></span><br><span class="line">    <span class="comment">// 怎么做呢?</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 别返回，缩小右侧边界</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 为什么返回 left 而不是 right？答：都是一样的，因为 while 终止的条件是 left == right。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如说给你有序数组 `nums = [1,2,2,2,3]`, target 为 2，我想得到 target 的右侧边界，即索引 3, </span></span><br><span class="line">    <span class="comment">// 怎么做呢?</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 别返回，缩小左侧边界</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 为什么返回 left - 1？</span></span><br><span class="line">        <span class="comment">// 当 nums[mid] == target，我们不返回，而是向右移动 left = mid + 1，想找到更右的那个；</span></span><br><span class="line">        <span class="comment">// •	最终跳出循环时，left 会指向 第一个大于 target 的位置，或者数组末尾的下一个位置；</span></span><br><span class="line">        <span class="comment">// •	所以 left - 1 才是 最后一个等于 target 的位置，也就是我们要的 right bound。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找扩展题-lc69-求平方"><a href="#二分查找扩展题-lc69-求平方" class="headerlink" title="二分查找扩展题-lc69-求平方"></a>二分查找扩展题-lc69-求平方</h3><ul>
<li><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">https://leetcode.com/problems/sqrtx/description/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>)mid * mid &gt; x) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">long</span>)mid * mid &lt; x) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为什么返回right而不是left? 因为最后是left 大于了right才退出循环的, 所以要取小的那个, 退出循环的时候right小一些</span></span><br><span class="line">        <span class="comment">// 比如 x = 8, 此时 left=1, right=8, 则 [1, 2, 3, 4, 5, 6, 7, 8], 最后一轮循环是 left=3, right=3, 然后此时mid也等于3, 3*3=9 所以 right得减一, right 就等于2 了</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和诀窍"><a href="#前缀和诀窍" class="headerlink" title="前缀和诀窍"></a>前缀和诀窍</h2><ul>
<li><a href="https://juejin.cn/post/7005057884555837476" target="_blank" rel="noopener">https://juejin.cn/post/7005057884555837476</a></li>
<li>前缀和理论基础: <a href="https://programmercarl.com/kamacoder/0058.区间和.html#思路" target="_blank" rel="noopener">https://programmercarl.com/kamacoder/0058.区间和.html#思路</a></li>
</ul>
<p>前缀和特别适合解决<strong>区间类</strong>的问题</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_ programmercarl_comments/image.png" alt="alt text"></p>
<p><code>p[5] - p[1]</code> 就是 红色部分的区间和。</p>
<p>而 p 数组是我们之前就计算好的累加和，所以后面每次求区间和的之后 我们只需要 <code>O(1)</code> 的操作。</p>
<p>特别注意： 在使用前缀和求解的时候，要特别注意 求解区间。</p>
<p>如上图，如果我们要求 区间下标 [2, 5] 的区间和，那么应该是 <code>p[5] - p[1]</code>，而不是 <code>p[5] - p[2]</code>。</p>
<p>「前缀和」 是从 nums 数组中的第  0 位置开始累加，到第 iii 位置的累加结果，我们常把这个结果保存到数组 preSum 中，记为  preSum[i]。</p>
<p>​<br>下面以 <code>[1, 12, -5, -6, 50, 3]</code> 为例，讲解一下如何求 preSum 前缀和的另一种写法(在很多题里非常有用, 比如<a href="https://leetcode.com/problems/continuous-subarray-sum/description/" target="_blank" rel="noopener">这题</a>):</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_ programmercarl_comments/image-1.png" alt="alt text"></p>
<p>在前面计算「前缀和」的代码中，计算公式为 <code>preSum[i] = preSum[i - 1] + nums[i]</code> ，为了防止当 i = 0 的时候数组越界，所以加了个 <code>if (i == 0)</code> 的判断，即 <code>i == 0</code> 时让 <code>preSum[i] = nums[i]</code>。<br>​<br>在其他常见的写法中，为了省去这个 if 判断，我们常常把「前缀和」数组 preSum 的长度定义为 原数组的长度 + 1。preSum 的第 0 个位置，相当于一个占位符，置为 0。<br>那么就可以把 preSum 的公式统一为 <code>preSum[i] = preSum[i - 1] + nums[i - 1]</code>，此时的 <code>preSum[i]</code> 表示 nums 中 iii 元素左边所有元素之和（不包含当前元素 iii）。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= gain.length; i++) &#123;</span><br><span class="line">    prefixSum[i] = prefixSum[i - <span class="number">1</span>] + gain[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gain.length; i++) &#123;</span><br><span class="line">    prefixSum[i + <span class="number">1</span>] = prefixSum[i] + gain[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lc528-前缀和-二分"><a href="#lc528-前缀和-二分" class="headerlink" title="lc528-前缀和+二分"></a>lc528-前缀和+二分</h3><ul>
<li>前缀和理论基础: <a href="https://programmercarl.com/kamacoder/0058.区间和.html#思路" target="_blank" rel="noopener">https://programmercarl.com/kamacoder/0058.区间和.html#思路</a></li>
<li><a href="https://leetcode.com/problems/random-pick-with-weight/" target="_blank" rel="noopener">https://leetcode.com/problems/random-pick-with-weight/</a></li>
<li><a href="https://leetcode.cn/problems/random-pick-with-weight/solutions/966335/cer-fen-xiang-jie-by-xiaohu9527-nsns/" target="_blank" rel="noopener">https://leetcode.cn/problems/random-pick-with-weight/solutions/966335/cer-fen-xiang-jie-by-xiaohu9527-nsns/</a></li>
</ul>
<p>lc528 Description: </p>
<p>You are given a 0-indexed array of positive integers w where <code>w[i]</code> describes the weight of the ith index.</p>
<p>You need to implement the function pickIndex(), which randomly picks an index in the range <code>[0, w.length - 1]</code> (inclusive) and returns it. The probability of picking an index i is <code>w[i]</code> / sum(w).</p>
<p>For example, if w = <code>[1, 3]</code>, the probability of picking index 0 is <code>1 / (1 + 3) = 0.25 (i.e., 25%)</code>, and the probability of picking index 1 is <code>3 / (1 + 3) = 0.75 (i.e., 75%)</code>.</p>
<p>Example 1:</p>
<ul>
<li>Input<ul>
<li><code>[&quot;Solution&quot;,&quot;pickIndex&quot;]</code></li>
<li><code>[[[1]],[]]</code></li>
</ul>
</li>
<li>Output : <code>[null,0]</code></li>
<li>Explanation:<br>  Solution solution = new Solution([1]);<br>  solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.</li>
</ul>
<p>Example 2:</p>
<ul>
<li>Input:<ul>
<li><code>[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]</code></li>
<li><code>[[[1,3]],[],[],[],[],[]]</code></li>
</ul>
</li>
<li>Output: <code>[null,1,1,1,1,0]</code></li>
<li><p>Explanation:<br>  Solution solution = new Solution([1, 3]);<br>  solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.<br>  solution.pickIndex(); // return 1<br>  solution.pickIndex(); // return 1<br>  solution.pickIndex(); // return 1<br>  solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.</p>
<p>  Since this is a randomization problem, multiple answers are allowed.<br>  All of the following outputs can be considered correct:<br>  [null,1,1,1,1,0]<br>  [null,1,1,1,1,1]<br>  [null,1,1,1,0,0]<br>  [null,1,1,1,0,1]<br>  [null,1,0,1,0,0]<br>  ……<br>  and so on.</p>
</li>
</ul>
<p>Constraints:</p>
<ul>
<li>1 &lt;= w.length &lt;= 104</li>
<li>1 &lt;= w[i] &lt;= 105</li>
<li>pickIndex will be called at most 104 times.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] wSum;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; w.length; ++i) &#123;</span><br><span class="line">            w[i] += w[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.wSum = w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.binarySearch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="keyword">this</span>.wSum.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> randNum = random.nextInt(<span class="keyword">this</span>.wSum[<span class="keyword">this</span>.wSum.length - <span class="number">1</span>]) + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (wSum[mid] == randNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wSum[mid] &lt; randNum) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wSum[mid] &gt; randNum) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Why return left??  @see ## 二分法诀窍与易错点</span></span><br><span class="line">        <span class="comment">// Example Walkthrough</span></span><br><span class="line">        <span class="comment">// Input: w = [1, 3, 6]</span></span><br><span class="line">        <span class="comment">// Cumulative weights (wSum): [1, 4, 10]</span></span><br><span class="line">        <span class="comment">// Suppose randNum = 5.</span></span><br><span class="line">        <span class="comment">//     1.	Initial pointers: left = 0, right = 2.</span></span><br><span class="line">        <span class="comment">//     2.	First iteration:</span></span><br><span class="line">        <span class="comment">//     •	mid = 1 ((0 + 2) / 2).</span></span><br><span class="line">        <span class="comment">//     •	wSum[mid] = 4, which is less than randNum.</span></span><br><span class="line">        <span class="comment">//     •	Adjust left to mid + 1 → left = 2.</span></span><br><span class="line">        <span class="comment">//     3.	Second iteration:</span></span><br><span class="line">        <span class="comment">//     •	mid = 2.</span></span><br><span class="line">        <span class="comment">//     •	wSum[mid] = 10, which is greater than randNum.</span></span><br><span class="line">        <span class="comment">//     •	Adjust right to mid - 1 → right = 1.</span></span><br><span class="line">        <span class="comment">//     4.	Exit loop: left = 2, right = 1.</span></span><br><span class="line">        <span class="comment">// Result:</span></span><br><span class="line">        <span class="comment">//     •	left = 2, which is the correct index (wSum[2] = 10 covers randNum = 5).</span></span><br><span class="line">        <span class="comment">//     •	right = 1 would be incorrect because randNum is not in the range of wSum[1].</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="双指针诀窍"><a href="#双指针诀窍" class="headerlink" title="双指针诀窍"></a>双指针诀窍</h2><p>双指针和滑动窗口的一般不同点是: </p>
<ul>
<li><strong>互相靠近</strong>: 双指针大多数时候是left指针在首, right在尾, 然后互相逐渐靠近</li>
<li><strong>快慢指针</strong>: 或者一个快一个慢, right快(去寻找合适的数), left慢的指针就处理right找到数据; <ul>
<li>数组问题中比较常见的快慢指针技巧，是让你原地修改数组。比如说看下<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">力扣第 26 题「删除有序数组中的重复项」</a>，让你在有序数组去重</li>
</ul>
</li>
<li>而滑动窗口一般也是right快left慢, 但滑动窗口为了维护一个区间窗口, 一般是用来求一个<strong>子区间</strong>的<code>最大和</code>/<code>最小和</code>之类的东西</li>
<li>理论上滑动窗口是双指针的一种, 只是比较像一个窗口而故名</li>
</ul>
<h3 id="lc27-Remove-Element"><a href="#lc27-Remove-Element" class="headerlink" title="lc27-Remove Element"></a>lc27-Remove Element</h3><ul>
<li><a href="https://programmercarl.com/0027.移除元素.html#算法公开课" target="_blank" rel="noopener">https://programmercarl.com/0027.移除元素.html#算法公开课</a></li>
<li><a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-element/description/</a></li>
</ul>
<p>双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p>
<p>定义快慢指针:    </p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p>诀窍: 应该想象成 slowIndex 之前的那些数组格子就是新的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lc977-有序数组的平方"><a href="#lc977-有序数组的平方" class="headerlink" title="lc977-有序数组的平方"></a>lc977-有序数组的平方</h3><ul>
<li><a href="https://programmercarl.com/0977.有序数组的平方.html#算法公开课" target="_blank" rel="noopener">https://programmercarl.com/0977.有序数组的平方.html#算法公开课</a></li>
<li><a href="https://leetcode.com/problems/squares-of-a-sorted-array/description/" target="_blank" rel="noopener">https://leetcode.com/problems/squares-of-a-sorted-array/description/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  <span class="comment">// lc977</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] resultArray = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endIndex = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> resultIndex = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;  <span class="comment">// 这里是 &lt;= , 因为最后相等时候的那个元素也要处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[startIndex] * nums[startIndex] &gt; nums[endIndex] * nums[endIndex]) &#123;</span><br><span class="line">                resultArray[resultIndex--] = nums[startIndex] * nums[startIndex];</span><br><span class="line">                startIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultArray[resultIndex--] = nums[endIndex] * nums[endIndex];</span><br><span class="line">                endIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] myList = &#123;-<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ret = solution.sortedSquares(myList);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.length; ++i) &#123;</span><br><span class="line">            System.out.println(ret[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lc15-3Sum"><a href="#lc15-3Sum" class="headerlink" title="lc15-3Sum"></a>lc15-3Sum</h3><ul>
<li><a href="https://programmercarl.com/0015.三数之和.html#算法公开课" target="_blank" rel="noopener">https://programmercarl.com/0015.三数之和.html#算法公开课</a></li>
<li><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></li>
</ul>
<p>其实这道题目使用哈希法并不十分合适(4sum就没办法了)，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。<br>接下来我来介绍另一个解法：双指针法(4sum也是这种思路)，这道题目使用双指针法 要比哈希法高效一些，那么来讲解一下具体实现的思路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">	    <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">	    <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="comment">// return result;  用 return不好, 用break好些, 和4sum用break统一了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;  <span class="comment">// 去重a</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">		    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    </span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lc18-4Sum"><a href="#lc18-4Sum" class="headerlink" title="lc18-4Sum"></a>lc18-4Sum</h3><ul>
<li><a href="https://programmercarl.com/0018.四数之和.html#其他语言版本" target="_blank" rel="noopener">https://programmercarl.com/0018.四数之和.html#其他语言版本</a></li>
<li><a href="https://leetcode.com/problems/4sum/description/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum/description/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] &gt;= <span class="number">0</span> &amp;&amp; nums[i] + nums[j] &gt; target) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"i:"</span> + i + <span class="string">", j:"</span> + j);</span><br><span class="line">                    <span class="comment">// return resultList; // return resultList;  // can't return here, considering [-3,-2,-1,0,0,1,2,3] , i = 1, j = 7, would lose [-1, 0, 0, 1]</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">long</span> sum = (<span class="keyword">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resultList.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left + <span class="number">1</span>] == nums[left]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right - <span class="number">1</span>] == nums[right]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int[] testArr = &#123;2, 2, 2, 2, 2&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] testArr = &#123;-<span class="number">3</span>,-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">// int[] testArr = &#123;2, 3, 1, 2, 2&#125;;</span></span><br><span class="line">        <span class="comment">// int target = 8;</span></span><br><span class="line">        <span class="comment">// int[] testArr = &#123;1,0,-1,0,-2,2&#125;;</span></span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = fourSum(testArr, target);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; arr : result) &#123;</span><br><span class="line">            System.out.println(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口模板与生动理论"><a href="#滑动窗口模板与生动理论" class="headerlink" title="滑动窗口模板与生动理论"></a>滑动窗口模板与生动理论</h2><ul>
<li>滑动窗口一般也是right快left慢, 但滑动窗口为了维护一个区间窗口, 一般是用来求一个<strong>子区间</strong>的<code>最大和</code>/<code>最小和</code>之类的东西</li>
<li>理论上滑动窗口是双指针的一种, 只是比较像一个窗口而故名</li>
<li><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/609055/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/" target="_blank" rel="noopener">https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/609055/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/</a></li>
<li>《挑战程序设计竞赛》这本书中把滑动窗口叫做<code>「虫取法」</code>，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。</li>
<li>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。<strong>右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</strong></li>
</ul>
<h3 id="滑动窗口的复杂度"><a href="#滑动窗口的复杂度" class="headerlink" title="滑动窗口的复杂度"></a>滑动窗口的复杂度</h3><ul>
<li><strong>为啥是 O(N)？</strong><ul>
<li>肯定有读者要问了，你这个滑动窗口框架不也用了一个嵌套 while 循环？为啥复杂度是 O(N) 呢？</li>
<li>简单说，指针 left, right 不会回退（它们的值只增不减），所以字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会说有某些元素多次进入和离开窗口，所以算法的时间复杂度就和字符串/数组的长度成正比。</li>
<li>反观嵌套 for 循环的暴力解法，那个 j 会回退，所以某些元素会进入和离开窗口多次，所以时间复杂度就是 O(N2) 了。</li>
<li>我在 <a href="https://labuladong.online/algo/essential-technique/complexity-analysis/" target="_blank" rel="noopener">算法时空复杂度分析实用指南</a> 有具体教大家如何从理论上估算时间空间复杂度，这里就不展开了。</li>
</ul>
</li>
<li><strong>为啥滑动窗口能在 O(N) 的时间穷举子数组？</strong><ul>
<li>这个问题本身就是错误的，滑动窗口并不能穷举出所有子串。要想穷举出所有子串，必须用那个嵌套 for 循环。</li>
<li>然而对于某些题目，并不需要穷举所有子串，就能找到题目想要的答案。滑动窗口就是这种场景下的一套算法模板，帮你对穷举过程进行剪枝优化，避免冗余计算。</li>
<li>所以在 算法的本质 中我把滑动窗口算法归为「如何聪明地穷举」一类。</li>
</ul>
</li>
</ul>
<h3 id="滑动窗口的模板"><a href="#滑动窗口的模板" class="headerlink" title="滑动窗口的模板"></a>滑动窗口的模板</h3><p>能解决大多数的滑动窗口问题：</p>
<figure class="highlight python"><figcaption><span>滑动窗口的模板</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSubArray</span><span class="params">(nums)</span>:</span></span><br><span class="line">    N = len(nums) <span class="comment"># 数组/字符串长度</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span></span><br><span class="line">    res = <span class="number">0</span> <span class="comment"># 保存最大的满足题目要求的 子数组/子串 长度</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; N: <span class="comment"># 当右边的指针没有搜索到 数组/字符串 的结尾</span></span><br><span class="line">        sums += nums[right] <span class="comment"># 增加当前右边指针的数字/字符的求和/计数</span></span><br><span class="line">        <span class="keyword">while</span> 区间[left, right]不符合题意: <span class="comment"># 此时需要一直移动左指针，直至找到一个符合题意的区间</span></span><br><span class="line">            sums -= nums[left] <span class="comment"># 移动左指针前需要从counter中减少left位置字符的求和/计数</span></span><br><span class="line">            left += <span class="number">1</span> <span class="comment"># 真正的移动左指针，注意不能跟上面一行代码写反</span></span><br><span class="line">        <span class="comment"># 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span></span><br><span class="line">        res = max(res, right - left + <span class="number">1</span>) <span class="comment"># 需要更新结果</span></span><br><span class="line">        right += <span class="number">1</span> <span class="comment"># 移动右指针，去探索新的区间</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="lc1004-Max-Consecutive-Ones-III"><a href="#lc1004-Max-Consecutive-Ones-III" class="headerlink" title="lc1004-Max Consecutive Ones III"></a>lc1004-Max Consecutive Ones III</h3><ul>
<li><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/609055/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/" target="_blank" rel="noopener">https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/609055/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/</a></li>
<li><a href="https://leetcode.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/max-consecutive-ones-iii/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zeroCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; A.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (zeroCount &gt; K) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeroCount--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="诀窍-1"><a href="#诀窍-1" class="headerlink" title="诀窍"></a>诀窍</h2><ul>
<li>没有思路的时候想想快慢指针, 能解决大部分链表问题</li>
<li>单链表弄个虚拟头结点, 可以很省事</li>
<li>双链表弄个虚拟头结点和虚拟尾结点, 刚开始就让虚拟头尾相连, 可以很省事, 参见<a href="https://leetcode.com/problems/lru-cache/description/" target="_blank" rel="noopener">LRU</a>里的那个, 如下:   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.head = <span class="keyword">new</span> DLinkedNode();  <span class="comment">// dummy</span></span><br><span class="line"><span class="keyword">this</span>.tail = <span class="keyword">new</span> DLinkedNode();  <span class="comment">// dummy</span></span><br><span class="line">head.next = tail;</span><br><span class="line">tail.pre = head;  <span class="comment">// 刚开始初始化的时候虚拟首尾节点的中间没有实际节点, 所以虚拟首尾节点是相连的.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="lc206-链表反转"><a href="#lc206-链表反转" class="headerlink" title="lc206 - 链表反转"></a>lc206 - 链表反转</h2><ul>
<li><a href="https://programmercarl.com/0206.翻转链表.html#算法公开课" target="_blank" rel="noopener">https://programmercarl.com/0206.翻转链表.html#算法公开课</a></li>
<li><p><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/description/</a></p>
</li>
<li><p>重要!!!!! 记忆口诀: 举一(head)反(反转)三(3个指针! pre! cur! temp!)</p>
</li>
<li>核心要点就是需要保存一个后面可能要用的结点就弄一个指针出来, 比如这个pre</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = cur.next;<span class="comment">// 保存下一个节点</span></span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lc24-两两交换链表中的节点"><a href="#lc24-两两交换链表中的节点" class="headerlink" title="lc24 - 两两交换链表中的节点"></a>lc24 - 两两交换链表中的节点</h2><ul>
<li><a href="https://programmercarl.com/0024.两两交换链表中的节点.html" target="_blank" rel="noopener">https://programmercarl.com/0024.两两交换链表中的节点.html</a></li>
<li><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/</a></p>
</li>
<li><p>重要!!!!! 记忆口诀(和反转链表很类似): 举一(1个dummyHead指针!)反(反转)三(3个指针! cur! node1! node2!)</p>
</li>
<li>核心要点(和反转链表很类似): 就是需要保存一个后面可能要用的结点就弄一个指针出来, 需要两个就弄两个指针, 比如这个node1, node2 !!</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将步骤 2,3 交换顺序，这样不用定义 temp 节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">    ListNode cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node1 = cur.next;<span class="comment">// 第 1 个节点</span></span><br><span class="line">        ListNode node2 = cur.next.next;<span class="comment">// 第 2 个节点</span></span><br><span class="line">        cur.next = node2; <span class="comment">// 步骤 1</span></span><br><span class="line">        node1.next = node2.next;<span class="comment">// 步骤 3</span></span><br><span class="line">        node2.next = node1;<span class="comment">// 步骤 2</span></span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lc142-链表是否有环"><a href="#lc142-链表是否有环" class="headerlink" title="lc142-链表是否有环"></a>lc142-链表是否有环</h2><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">lc142</a></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-25.png" alt="alt text"></p>
<p>设：  </p>
<ul>
<li>环外长度是 a</li>
<li>环内（环的周长）是 b</li>
<li>快指针速度是慢指针速度的 2 倍</li>
<li>x表示: 慢指针已经越过了环的入口后继续走的步数</li>
</ul>
<p>第一次相遇时，慢指针走了 <code>a + x</code>，那快指针走了 <code>(a + x)</code> 的2倍即为<code>2 * (a + x)</code>，且快指针比慢指针多走了环的整数k倍 <code>k * b</code>，即：</p>
<p><code>2(a + x) = a + x + kb</code>  （k 是整数）<br>推导得出：<code>a = kb - x</code></p>
<p>这意味着，从起点走 a 步（让慢指针重新从 0 出发），以及从相遇点走 x 步（当前快慢指针的位置, 为啥是x? 因为<code>a = kb - x</code>的<code>kb - x</code>），都会到达同一个环的入口点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="lc28-实现strStr-20240923"><a href="#lc28-实现strStr-20240923" class="headerlink" title="lc28 - 实现strStr() - 20240923"></a>lc28 - 实现strStr() - 20240923</h2><h3 id="暴力解法-掌握这个暴力解法即可"><a href="#暴力解法-掌握这个暴力解法即可" class="headerlink" title="暴力解法-掌握这个暴力解法即可"></a>暴力解法-掌握这个暴力解法即可</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hLen = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> nLen = needle.length();</span><br><span class="line">        <span class="comment">// 0, 1, 2, 3, 4, 5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + nLen &lt;= hLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nLen; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP不要求-面试基本不会出的-背代码就没意思了"><a href="#KMP不要求-面试基本不会出的-背代码就没意思了" class="headerlink" title="KMP不要求-面试基本不会出的-背代码就没意思了"></a>KMP不要求-面试基本不会出的-背代码就没意思了</h3><ul>
<li><a href="https://programmercarl.com/0028.实现strStr.html#算法公开课" target="_blank" rel="noopener">https://programmercarl.com/0028.实现strStr.html#算法公开课</a></li>
<li><a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na/KMP精讲2.gif" alt></p>
<p>看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如上动画所示：</p>
<p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。</p>
<p>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p>
<p>所以要看前一位的 前缀表的数值。</p>
<p>前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。</p>
<p>最后就在文本串中找到了和模式串匹配的子串了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前缀表（不减一）Java实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.length()];  <span class="comment">// 前缀表</span></span><br><span class="line">        getNext(next, needle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 此处 j 指向 基于模式串 needle 的 内部的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;  <span class="comment">// i 指向 基于文本串 haystack 内部的起始位置。</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) </span><br><span class="line">                j = next[j - <span class="number">1</span>];  <span class="comment">// strStr 里匹配过程里的寻找前一位来继续匹配; 不懂的话看视频 https://www.bilibili.com/video/BV1PD4y1o7nd/?vd_source=8a83b38420b65ac33aa101b7754630f6 里的 "使用前缀表的匹配过程" 环节</span></span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(j) == haystack.charAt(i)) </span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.length())  <span class="comment">// 当 j 等于needle 长度的时候, 说明 j 指向了模式串t的末尾的后面，那么就说明模式串t完全匹配文本串s里的某个子串了。</span></span><br><span class="line">                <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>[] next, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// 此处 j 是 前缀 的末尾位置, 也是前缀的长度</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;  <span class="comment">// i 是后缀的末尾位置</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i))  <span class="comment">// 此时前后缀不相等; (j要保证大于0，因为下面有取j-1作为数组下标的操作</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];  <span class="comment">// 注意这里，是要找前一位的对应的回退位置了; 为什么这里要找前一位的对应的回退位置呢? 因为和 上面 strStr 里匹配过程里的寻找前一位来继续匹配是一样一样的</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i))   <span class="comment">// 此时前后缀相等</span></span><br><span class="line">                j++;</span><br><span class="line">            next[i] = j;  <span class="comment">// 因为 j 既是前缀 的末尾位置, 又是前缀的长度, 所以此处直接在 next 表里存下 j</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lc459-重复的子字符串-暴力解法-掌握这个暴力解法即可"><a href="#lc459-重复的子字符串-暴力解法-掌握这个暴力解法即可" class="headerlink" title="lc459 - 重复的子字符串-暴力解法-掌握这个暴力解法即可"></a>lc459 - 重复的子字符串-暴力解法-掌握这个暴力解法即可</h2><ul>
<li><a href="https://programmercarl.com/0459.重复的子字符串.html#算法公开课" target="_blank" rel="noopener">https://programmercarl.com/0459.重复的子字符串.html#算法公开课</a></li>
<li><a href="https://leetcode.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">https://leetcode.com/problems/repeated-substring-pattern/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作者：力扣官方题解</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode.cn/problems/repeated-substring-pattern/solutions/386481/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;  <span class="comment">// 这个 i 并不是 字符串的index, 而是子串长度; 并且注意到一个小优化是，因为子串至少需要重复一次，所以子串长度 i 不会大于 n 的一半，</span></span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;  <span class="comment">// s 的长度一定是子串长度的倍数</span></span><br><span class="line">                <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> offset = j % i;  <span class="comment">// 子串肯定是 s 的前缀, 这里是拿字符串的子串前缀的index</span></span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(j) != s.charAt(offset)) &#123;</span><br><span class="line">                        match = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="诀窍-2"><a href="#诀窍-2" class="headerlink" title="诀窍"></a>诀窍</h2><ul>
<li>当遇到这类问题就要用栈了: <ul>
<li>栈在系统中的路径问题, 如: 简化路径 <code>cd a/b/c/../../</code></li>
<li>括号匹配问题, 如: 给定一个只包括<code>&#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39;</code>的字符串，判断字符串是否有效。</li>
<li>字符串去重问题, 如: lc1047. 删除字符串中的所有相邻重复项</li>
</ul>
</li>
<li>队列反而是在树的层序遍历里用的较多</li>
</ul>
<h2 id="单调栈-monotonic-stack"><a href="#单调栈-monotonic-stack" class="headerlink" title="单调栈-monotonic stack"></a>单调栈-monotonic stack</h2><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0739.每日温度.md" target="_blank" rel="noopener">Reference</a></p>
<p><strong>单调栈（Monotonic Stack）</strong> 是一种在栈的基础上构建的<strong>具有单调性（递增或递减）</strong>的特殊数据结构，主要用于高效解决“下一个更大元素”、“区间最大/最小值”、“柱状图最大矩形”等一类<strong>具有区间性质的单调性问题</strong>。</p>
<p>[模拟视频参考](<a href="https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/" target="_blank" rel="noopener">https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/</a></p>
<p>定义:</p>
<ul>
<li><strong>单调递增栈</strong>：栈内元素<strong>从栈底到栈顶递增</strong></li>
<li><strong>单调递减栈</strong>：栈内元素<strong>从栈底到栈顶递减</strong></li>
</ul>
<p>栈中可以存放<strong>原始值</strong>，也可以存放<strong>索引</strong>（常用于记录位置关系）</p>
<p>核心思想: 利用栈维护某种单调性，在遍历数组时边处理边维护单调结构，从而实现<strong>一次遍历内快速确定左右边界或最值的位置</strong>。</p>
<p>经典应用场景:</p>
<table>
<thead>
<tr>
<th>典型题型</th>
<th>使用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>下一个更大/小元素</td>
<td>单调递减/递增栈</td>
</tr>
<tr>
<td>栈中每个元素的左右第一个更大/小值</td>
<td>维护索引 + 单调栈</td>
</tr>
<tr>
<td>柱状图最大矩形（Leetcode 84）</td>
<td>单调递增栈，求每个柱子的左右边界</td>
</tr>
<tr>
<td>滑动窗口最大值（优化解法）</td>
<td>单调队列（与单调栈类似思想）</td>
</tr>
<tr>
<td>股票价格跨度（Leetcode 901）</td>
<td>单调递减栈维护连续上涨跨度</td>
</tr>
<tr>
<td>lc739-每日温度</td>
<td>单调栈</td>
</tr>
</tbody>
</table>
<p>例子：找每个元素右边第一个比它大的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &lt;= arr[i]) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    res[i] = stack.isEmpty() ? -<span class="number">1</span> : arr[stack.peek()];</span><br><span class="line">    stack.push(i); <span class="comment">// 注意这里入栈的是索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>含义：</p>
<ul>
<li>单调<strong>递减栈</strong>：从右往左遍历，栈中维持一个从大到小的数列</li>
<li>每个元素右边第一个比它大的元素，就是栈顶</li>
</ul>
<p>时间复杂度: 所有单调栈相关算法通常为 <strong>O(n)</strong>：每个元素最多入栈一次、出栈一次</p>
<p>总结: <strong>单调栈 = 栈 + 有序性约束</strong>，用于高效查找下一个更大/更小值、区间边界等结构性问题。是面试中非常常见的数据结构技巧之一。</p>
<h3 id="单调栈经典题-lc739-每日温度"><a href="#单调栈经典题-lc739-每日温度" class="headerlink" title="单调栈经典题-lc739-每日温度"></a>单调栈经典题-lc739-每日温度</h3><p><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="noopener">739. Daily Temperatures</a></p>
<p>Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.</p>
<p>Example 1:</p>
<ul>
<li>Input: temperatures = <code>[73,74,75,71,69,72,76,73]</code></li>
<li>Output: <code>[1,1,4,2,1,1,0,0]</code></li>
</ul>
<p>Example 2:</p>
<ul>
<li>Input: temperatures = <code>[30,40,50,60]</code></li>
<li>Output: <code>[1,1,1,0]</code></li>
</ul>
<p>Example 3:</p>
<ul>
<li>Input: temperatures = <code>[30,60,90]</code></li>
<li>Output: <code>[1,1,0]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟视频参考: https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explanation</span></span><br><span class="line">    <span class="comment">// Use a monotonic decreasing stack (stores indices of days with decreasing temperatures).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each day i, check if today’s temp is higher than the top of the stack:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If yes, pop the index from the stack and record the difference as the result.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If not, push the index onto the stack.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stack ensures we always know the last day with a higher temperature.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Time &amp; Space Complexity</span></span><br><span class="line">    <span class="comment">// Time: O(n), each index is pushed and popped at most once.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Space: O(n) for the stack and result array.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// Store indices</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// While current temp is higher than stack top</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">                res[prevIndex] = i - prevIndex; <span class="comment">// Calculate distance</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i); <span class="comment">// Push current index onto stack</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lc239-Sliding-Window-Maximum"><a href="#lc239-Sliding-Window-Maximum" class="headerlink" title="lc239 - Sliding Window Maximum"></a>lc239 - Sliding Window Maximum</h2><ul>
<li><a href="https://programmercarl.com/0239.滑动窗口最大值.html#其他语言版本" target="_blank" rel="noopener">https://programmercarl.com/0239.滑动窗口最大值.html#其他语言版本</a></li>
<li><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">https://leetcode.com/problems/sliding-window-maximum/</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用双端队列手动实现单调队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可</span></span><br><span class="line"><span class="comment"> * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span></span><br><span class="line">            <span class="comment">// 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span> ) &#123;</span><br><span class="line">                res[j++] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="诀窍-3"><a href="#诀窍-3" class="headerlink" title="诀窍"></a>诀窍</h2><ul>
<li>二叉树的算法题型主要是用来培养递归思维的，而层序遍历属于迭代遍历，也比较简单</li>
<li>一共只有三种题目: <ul>
<li>直接通过 dfs/bfs 可以计算的类型</li>
<li>路径类</li>
<li>最小祖先类</li>
</ul>
</li>
<li>二叉树最重要的是层序遍历的模板, 可以解决 <code>70%</code> 的二叉树题目</li>
<li>路径题和公共祖先题和深度高度的题一般才会用到 <code>递归</code>, 其他大多数时候都可以层序遍历 / 前中序遍历的<code>迭代法</code>解决</li>
<li><strong>仔细观察，前中后序位置的代码，能力依次增强</strong>。<ol>
<li><strong>前序</strong>位置的代码只能从函数参数中获取父节点传递来的数据。</li>
<li><strong>中序</strong>位置的代码不仅可以获取参数数据，还可以获取到左子树通过函数返回值传递回来的数据。</li>
<li><strong>后序</strong>位置的代码最强，不仅可以获取参数数据，还可以同时获取到左右子树通过函数返回值传递回来的数据。</li>
<li><strong>所以，某些情况下把代码移到后序位置效率最高；有些事情，只有后序位置的代码能做</strong></li>
</ol>
</li>
<li>二叉树递归写法诀窍, 递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：<ul>
<li>如果需要搜索<strong>整棵</strong>二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii, <a href="https://programmercarl.com/0112.路径总和.html#相关题目推荐）" target="_blank" rel="noopener">https://programmercarl.com/0112.路径总和.html#相关题目推荐）</a></li>
<li>如果需要搜索<strong>整棵</strong>二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先, <a href="https://programmercarl.com/0236.二叉树的最近公共祖先.html#算法公开课）" target="_blank" rel="noopener">https://programmercarl.com/0236.二叉树的最近公共祖先.html#算法公开课）</a></li>
<li>如果要搜索<strong>其中一条</strong>符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（这种情况符合: <a href="https://programmercarl.com/0112.路径总和.html#算法公开课）" target="_blank" rel="noopener">https://programmercarl.com/0112.路径总和.html#算法公开课）</a></li>
</ul>
</li>
</ul>
<h2 id="层序-相当重要"><a href="#层序-相当重要" class="headerlink" title="层序(相当重要)"></a>层序(相当重要)</h2><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image.png" alt="level order"><br><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na/binary_tree_level_order.gif" alt="animation process"></p>
<ul>
<li>注意 <code>while (len &gt; 0) {  }</code> 这个代码块里的就是同一层的结点处理</li>
<li>掌握了这个模板, 可以解决 70% 的二叉树题目</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// // 注意返回值是List&lt;List&lt;Integer&gt;&gt;不是单List&lt;Integer&gt;, 因为层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树, 每一层都是一个 List&lt;Integer&gt;, 所以每一层加起来组成一个大的 List&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;  </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(root);  <span class="comment">// 循环外就第一次 push了root</span></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;  <span class="comment">// 深度, 非常实用</span></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = que.size();  <span class="comment">// 注意这个len, 这里一定要使用固定大小 len，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;  <span class="comment">// 这个代码块里的就是同一层的结点处理</span></span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) &#123; que.offer(tmpNode.left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) &#123; que.offer(tmpNode.right); &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            resultList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前序-迭代法重要"><a href="#前序-迭代法重要" class="headerlink" title="前序(迭代法重要)"></a>前序(迭代法重要)</h2><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na/二叉树前序遍历（迭代法）.gif" alt></p>
<ul>
<li>普通二叉树常用</li>
<li>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</li>
<li>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</li>
<li>掌握了之后可以求 <code>路径</code> 问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);  <span class="comment">// 和中序不同: 循环外就第一次 push了root</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">// 为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123; stack.push(node.right); &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; stack.push(node.left); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序-迭代法重要"><a href="#中序-迭代法重要" class="headerlink" title="中序(迭代法重要)"></a>中序(迭代法重要)</h2><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na/二叉树中序遍历（迭代法）.gif" alt></p>
<ul>
<li>二叉搜索树BST常用, 因为 BST 的 中序遍历 出来是个有序的递增数组)</li>
<li>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</li>
<li>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;  <span class="comment">// 和前序迭代法不同: 这里多判断了cur不等于null</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);  <span class="comment">// 和前序迭代法不同: 循环内才第一次 push了root</span></span><br><span class="line">                cur = cur.left;  <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                result.add(cur.val);  <span class="comment">// 中</span></span><br><span class="line">                cur = cur.right;  <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序-迭代法不重要-但递归解法的理解很重要"><a href="#后序-迭代法不重要-但递归解法的理解很重要" class="headerlink" title="后序(迭代法不重要,但递归解法的理解很重要)"></a>后序(迭代法不重要,但递归解法的理解很重要)</h2><ul>
<li>后序<code>迭代法</code>很少用到, 会前序按照以下方法就会写后序: <ol>
<li>先序遍历是<code>中左右</code></li>
<li>调整代码左右循序</li>
<li>变成<code>中右左</code> -&gt; 反转result数组 -&gt; <code>左右中</code></li>
<li>后序遍历是<code>左右中</code></li>
</ol>
</li>
<li>后序遍历的<code>递归法</code>用得着, 那种需要从树底下往上走来统计信息的就用得到, 如 <code>公共祖先</code> 这种题就需要后序遍历递归法</li>
</ul>
<p><a href="https://labuladong.online/algo/essential-technique/binary-tree-summary/#后序位置的特殊之处" target="_blank" rel="noopener">参考</a></p>
<p>举些具体的例子来感受下它们的能力区别。现在给你一棵二叉树，我问你两个简单的问题：</p>
<ol>
<li>如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？</li>
<li>如何打印出每个节点的左右子树各有多少节点？</li>
</ol>
<p>第一个问题可以这样写代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    printf(<span class="string">"Node %s at level %d"</span>, root.val, level);</span><br><span class="line">    traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">    traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用</span></span><br><span class="line">traverse(root, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>第二个问题可以这样写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftCount = count(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightCount = count(root.right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    printf(<span class="string">"节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点"</span>,</span><br><span class="line">            root, leftCount, rightCount);</span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个问题的根本区别在于:  </p>
<p>一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；而以一个节点为根的整棵子树有多少个节点，你必须遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。</p>
<p>结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。</p>
<p>那么换句话说，<strong>一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。</strong></p>
<h2 id="路径-重要"><a href="#路径-重要" class="headerlink" title="路径(重要)"></a>路径(重要)</h2><ul>
<li><a href="https://programmercarl.com/0257.二叉树的所有路径.html#思路" target="_blank" rel="noopener">https://programmercarl.com/0257.二叉树的所有路径.html#思路</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-paths/</a></li>
<li>学会后可以解”求根到叶子节点数字之和”: <a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a></li>
<li><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum/description/</a></li>
</ul>
<p><a href="https://leetcode.com/problems/path-sum-ii/description/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/description/</a></p>
<p>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.</p>
<p>A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.</p>
<ul>
<li>要求从根节点到叶子的路径，所以需要<strong>前序遍历</strong>，这样才方便让父节点指向孩子节点，找到对应的路径。</li>
<li>注意其中的回溯, 特别是 count 的回溯注释, 方便深刻的理解回溯</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    LinkedList&lt;Integer&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum (TreeNode root,<span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        travesal(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">travesal</span><span class="params">(TreeNode root,  <span class="keyword">int</span> count)</span> </span>&#123; <span class="comment">// 这个版本最好, 最容易想得到, 符合直觉</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.offer(root.val);</span><br><span class="line">        count -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; count == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        travesal(root.left, count);</span><br><span class="line">        travesal(root.right, count);</span><br><span class="line">        path.removeLast(); <span class="comment">// 回溯</span></span><br><span class="line">        count += root.val;  <span class="comment">// 按道理说, 这一行不能注释, 这里返回上一层递归是应该要回溯的, 但是因为 count 只是个int, 不是全局变量, 不会影响上一层的 count, 所以这一行其实可以注释</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h2><ul>
<li>二叉树某个节点的 <strong>高度</strong> <code>==</code> 这个节点的深度 ：指从<code>该节点</code>到<code>叶子节点</code>的<code>最长</code>简单路径边的条数或者节点数</li>
<li>二叉树某个节点的 <strong>深度</strong> <code>==</code> 这个节点的高度 ：指从<code>该节点</code>到<code>该节点</code>的<code>最长</code>简单路径边的条数或者节点数</li>
<li>二叉树的 <strong>最大深度</strong> == <strong>根节点的高度</strong> ：指从<code>根节点</code>到<code>该节点</code>的<code>最长</code>简单路径边的条数或者节点数</li>
<li>根节点的 <strong>高度</strong> 就是二叉树的 <a href="#最大深度">最大深度</a></li>
</ul>
<figure class="highlight java"><figcaption><span>某个节点的高度代码和某个节点的深度的代码一致</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算某个节点的高度, 代码和求某个节点的深度的代码一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归计算左子树和右子树的高度</span></span><br><span class="line">    <span class="keyword">int</span> leftHeight = height(node.left);</span><br><span class="line">    <span class="keyword">int</span> rightHeight = height(node.right);</span><br><span class="line">    <span class="comment">// 节点的高度为左右子树高度的最大值加 1</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h2><ul>
<li>求深度用<code>层序遍历</code>是最适合的最直观容易理解</li>
<li>二叉树的深度: 根节点到最远叶子节点的最长路径上的节点数。</li>
<li>叶子节点: 是指没有子节点的节点。</li>
</ul>
<figure class="highlight java"><figcaption><span>某个节点的高度代码和某个节点的深度的代码一致</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算某个节点的高度, 代码和求某个节点的深度的代码一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归计算左子树和右子树的高度</span></span><br><span class="line">    <span class="keyword">int</span> leftHeight = height(node.left);</span><br><span class="line">    <span class="keyword">int</span> rightHeight = height(node.right);</span><br><span class="line">    <span class="comment">// 节点的高度为左右子树高度的最大值加 1</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h3><ul>
<li><a href="https://programmercarl.com/0104.二叉树的最大深度.html" target="_blank" rel="noopener">https://programmercarl.com/0104.二叉树的最大深度.html</a></li>
<li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></li>
</ul>
<p>使用迭代法的话，<strong>使用层序遍历是最为合适的</strong>，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。<br>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，</p>
<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><p>层序遍历:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) &#123; que.offer(tmpNode.left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) &#123; que.offer(tmpNode.right); &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归法1-回溯-重要"><a href="#递归法1-回溯-重要" class="headerlink" title="递归法1-回溯(重要)"></a>递归法1-回溯(重要)</h4><ul>
<li>掌握后可以解树的最小深度, lc111: <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-depth-of-binary-tree/description/</a></li>
<li>这个递归法中的 <code>depth</code>的计算写法 对于很多用到深度信息的二叉树的递归解都很有帮助, 算是个模板套路</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> maxNum = <span class="number">0</span>; <span class="comment">// 定义最大深度 </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归解法1: </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ans</span><span class="params">(TreeNode tr, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 递归开始，深度增加</span></span><br><span class="line">        depth++;</span><br><span class="line">        maxNum = maxNum &lt; depth ? depth : maxNum;</span><br><span class="line">        ans(tr.left, depth);</span><br><span class="line">        ans(tr.right, depth);</span><br><span class="line">        <span class="comment">// 递归结束, 得回溯，深度减少</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归解法2: </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ans</span><span class="params">(TreeNode tr, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        maxNum = maxNum &lt; depth + <span class="number">1</span> ? depth + <span class="number">1</span> : maxNum;</span><br><span class="line">        ans(tr.left, depth + <span class="number">1</span>);  <span class="comment">// 隐含了回溯, 因为depth实际上自身没有变, 这里并不是</span></span><br><span class="line">        ans(tr.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归法2"><a href="#递归法2" class="headerlink" title="递归法2"></a>递归法2</h4><p>后序遍历, 掌握后可以解 树的最大直径 lc543: <a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/diameter-of-binary-tree/description/</a>):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;  <span class="comment">// 这个 +1 的 1 是指当前层自己本身这个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h3><ul>
<li><a href="https://programmercarl.com/0111.二叉树的最小深度.html#算法公开课" target="_blank" rel="noopener">https://programmercarl.com/0111.二叉树的最小深度.html#算法公开课</a></li>
<li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-depth-of-binary-tree/description/</a></li>
</ul>
<p>最小深度: 是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><p>层序遍历:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left == <span class="keyword">null</span> &amp;&amp; tmpNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span></span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="keyword">null</span>) &#123; que.offer(tmpNode.left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="keyword">null</span>) &#123; que.offer(tmpNode.right); &#125;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归法-回溯"><a href="#递归法-回溯" class="headerlink" title="递归法-回溯"></a>递归法-回溯</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法（思路来自二叉树最大深度的递归法）</span></span><br><span class="line"><span class="comment">     * 该题求最小深度，最小深度为根节点到叶子节点的深度，所以在迭代到每个叶子节点时更新最小值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义最小深度，初始化最大值</span></span><br><span class="line">    <span class="keyword">int</span> minDepth = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dep(root);</span><br><span class="line">        <span class="keyword">return</span> minDepth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dep</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 递归开始，深度增加</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="comment">// 该位置表示递归到叶子节点了，需要更新最小深度minDepth.( 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。注意是叶子节点。什么是叶子节点，左右孩子都为空的节点才是叶子节点！)</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            minDepth = Math.min(minDepth , depth);</span><br><span class="line">        dep(root.left);</span><br><span class="line">        dep(root.right);</span><br><span class="line">        <span class="comment">// 递归结束，深度减小</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最近公共祖先-重要"><a href="#最近公共祖先-重要" class="headerlink" title="最近公共祖先(重要)"></a>最近公共祖先(重要)</h2><ul>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode-236</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0236.二叉树的最近公共祖先.md" target="_blank" rel="noopener">Reference</a></li>
<li>自底向上查找就好了，这样就可以找到公共祖先了。那么二叉树如何可以自底向上查找呢？回溯啊，二叉树回溯的过程就是从低到上。<code>后序遍历</code>（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。</li>
<li>如何判断一个节点是节点q和节点p的公共祖先呢? 判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。</li>
<li>为什么left为空，right不为空，目标节点通过right返回呢？如图：<ul>
<li><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-30.png" alt="alt text"></li>
<li>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</li>
</ul>
</li>
</ul>
<p>总流程图: </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-28.png" alt="总流程图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// 递归结束条件: found nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;  <span class="comment">// // 递归结束条件 found p or q</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// post order traverse</span></span><br><span class="line">        TreeNode leftResult = lowestCommonAncestor(root.left, p, q);  <span class="comment">// search left subtree</span></span><br><span class="line">        TreeNode rightResult = lowestCommonAncestor(root.right, p, q);  <span class="comment">// search right subtree</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (leftResult != <span class="keyword">null</span> &amp;&amp; rightResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root; <span class="comment">// Found both p and q in the left subtree and the right subtree.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftResult != <span class="keyword">null</span> &amp;&amp; rightResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftResult; <span class="comment">// Found p or q int the left subtree</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftResult == <span class="keyword">null</span> &amp;&amp; rightResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightResult; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// found nothing in left subtree and right subtree</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树-诀窍-重要"><a href="#二叉搜索树-诀窍-重要" class="headerlink" title="二叉搜索树-诀窍(重要)"></a>二叉搜索树-诀窍(重要)</h2><ul>
<li>二叉搜索树的中序遍历是个递增有序数组, 利用好这一点非常方便解题</li>
<li>二叉搜索树的迭代遍历很好写, 大多数时候用不到递归方式来解题</li>
<li>空二叉树是二叉搜索树</li>
<li><a href="https://labuladong.online/algo/data-structure/bst-part2/#一、判断-bst-的合法性" target="_blank" rel="noopener">https://labuladong.online/algo/data-structure/bst-part2/#一、判断-bst-的合法性</a></li>
</ul>
<p><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/</a></p>
<p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p>
<figure class="highlight java"><figcaption><span>错误代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// root 的左边应该更小</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.val &gt;= root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// root 的右边应该更大</span></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.right.val &lt;= root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left)</span><br><span class="line">        &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，<br>错误的原因在于，对于每一个节点 root，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，root 的整个左子树都要小于 root.val，整个右子树都要大于 root.val。</p>
<p>问题是，对于某一个节点 root，他只能管得了自己的左右子节点，怎么把 root 的约束传递给左右子树呢？请看正确的代码：</p>
<figure class="highlight java"><figcaption><span>正确代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://labuladong.online/algo/data-structure/bst-part2/#一、判断-bst-的合法性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：该函数返回 root 为根的子树的所有节点是否满足 max.val &gt; root.val &gt; min.val</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">_isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 根据定义，限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">        <span class="keyword">return</span> _isValidBST(root.left, min, root) </span><br><span class="line">            &amp;&amp; _isValidBST(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧。</p>
<h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><p>前序和中序可以唯一确定一棵二叉树。后序和中序可以唯一确定一棵二叉树。那么前序和后序可不可以唯一确定一棵二叉树呢？</p>
<p>前序和后序不能唯一确定一棵二叉树！，因为没有中序遍历无法确定左右部分，也就是无法分割。</p>
<p>举一个例子：<br><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-13.png" alt="alt text"></p>
<p>106.从中序与后序遍历序列构造二叉树2</p>
<p>tree1 的前序遍历是<code>[1 2 3]</code>， 后序遍历是<code>[3 2 1]</code>。</p>
<p>tree2 的前序遍历是<code>[1 2 3]</code>， 后序遍历是<code>[3 2 1]</code>。</p>
<p>那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！</p>
<p>所以前序和后序不能唯一确定一棵二叉树！</p>
<h3 id="根据前中序构造二叉树"><a href="#根据前中序构造二叉树" class="headerlink" title="根据前中序构造二叉树"></a>根据前中序构造二叉树</h3><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=problem-list-v2&amp;envId=rab78cw1" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal</a></p>
<p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>
<ul>
<li>代码, 参考: <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/" target="_blank" rel="noopener">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/</a></li>
<li>图, 参考: <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2361558/105-cong-qian-xu-yu-zhong-xu-bian-li-xu-4lvkz/" target="_blank" rel="noopener">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2361558/105-cong-qian-xu-yu-zhong-xu-bian-li-xu-4lvkz/</a></li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-12.png" alt="alt text"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">        root.left = myBuildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">        <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据中后序构造二叉树"><a href="#根据中后序构造二叉树" class="headerlink" title="根据中后序构造二叉树"></a>根据中后序构造二叉树</h3><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/</a></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-15.png" alt="alt text"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码, 参考: https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/</span></span><br><span class="line"><span class="comment">// 图, 参考: https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0106.从中序与后序遍历序列构造二叉树.md#java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> postorder_left, <span class="keyword">int</span> postorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder_left &gt; postorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历中的最后一个节点就是根节点</span></span><br><span class="line">        <span class="keyword">int</span> postorder_root = postorder_right;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = indexMap.get(postorder[postorder_root]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder_root]);</span><br><span class="line">        <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 后序遍历中「从 左边界 开始的 size_left_subtree - 1」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">        root.left = myBuildTree(postorder, inorder, postorder_left, postorder_left + size_left_subtree - <span class="number">1</span>, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+左子树节点数目 开始到 右边界 - 1」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">        root.right = myBuildTree(postorder, inorder, postorder_left + size_left_subtree, postorder_right - <span class="number">1</span>, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = postorder.length;</span><br><span class="line">        <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(postorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="诀窍与模板"><a href="#诀窍与模板" class="headerlink" title="诀窍与模板"></a>诀窍与模板</h2><ul>
<li>回溯本质是dfs, 所以回溯的模板和图论的dfs模板极为类似</li>
<li><a href="https://programmercarl.com/回溯算法理论基础.html#理论基础" target="_blank" rel="noopener">https://programmercarl.com/回溯算法理论基础.html#理论基础</a></li>
<li>起名: 在回溯算法中，我的习惯是函数起名字为backtrack，这个起名大家随意。</li>
<li>返回值: 回溯算法中函数返回值一般为void。</li>
<li>参数: 因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DFS 算法把「做选择」「撤销选择」的逻辑放在 for 循环外面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    print(<span class="string">"enter node %s"</span>, root);</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;  <span class="comment">// 多叉树 dfs</span></span><br><span class="line">        dfs(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    print(<span class="string">"leave node %s"</span>, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯算法把「做选择」「撤销选择」的逻辑放在 for 循环里面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        print(<span class="string">"I'm on the branch from %s to %s"</span>, root, child);</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        print(<span class="string">"I'll leave the branch from %s to %s"</span>, child, root);</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧，你回溯算法必须把「做选择」和「撤销选择」的逻辑放在 for 循环里面，否则怎么拿到「树枝」的两个端点？</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><table>
<thead>
<tr>
<th>回溯问题类型</th>
<th>时间复杂度趋势</th>
</tr>
</thead>
<tbody>
<tr>
<td>子集/切分/选或不选类</td>
<td><code>O(2^n)</code> 或 <code>O(n*2^n)</code></td>
</tr>
<tr>
<td>全排列类（n个元素全打乱）</td>
<td><code>O(n!)</code></td>
</tr>
<tr>
<td>八皇后/数独等网格剪枝类</td>
<td>根据剪枝强弱决定，常见 <code>O(k^n)</code> 或更优</td>
</tr>
</tbody>
</table>
<p>为何全排列是 <code>O(n!)</code>?  比如 Leetcode 46 (Permutations)：每一层要遍历剩下的所有元素，分支数是递减的：</p>
<ul>
<li>第一层 n 个分支</li>
<li>第二层 n-1 个分支</li>
<li>…</li>
<li>总共是 <code>O(n!)</code></li>
</ul>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><ul>
<li><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode.com/problems/combinations/</a></li>
<li>参考1: <a href="https://programmercarl.com/0077.组合.html#算法公开课" target="_blank" rel="noopener">https://programmercarl.com/0077.组合.html#算法公开课</a></li>
<li>参考2: <a href="https://github.com/no5ix/leetcode-master/blob/master/problems/0077.组合.md" target="_blank" rel="noopener">https://github.com/no5ix/leetcode-master/blob/master/problems/0077.组合.md</a></li>
</ul>
<p>给定两个整数 n 和 k，返回 <code>1 ... n</code> 中所有可能的 k 个数的组合。</p>
<p>示例: 输入: n = 4, k = 2 输出: <code>[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</code></p>
<h3 id="没有剪枝的版本"><a href="#没有剪枝的版本" class="headerlink" title="没有剪枝的版本"></a>没有剪枝的版本</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na/20201123195242899.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resultArr = new ArrayList&lt;&gt;();和    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resultArr = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();有啥区别? </span></span><br><span class="line">    <span class="comment">// 完全等价的, `ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resultArr = new ArrayList&lt;&gt;();`</span></span><br><span class="line">    <span class="comment">// - 这是Java 7引入的“钻石操作符”的用法。</span></span><br><span class="line">    <span class="comment">// - 使用钻石操作符可以简化泛型类型的实例化，特别是当构造函数右侧的类型已经由变量声明时。</span></span><br><span class="line">    <span class="comment">// - 它允许编译器自动推断出泛型类型参数，从而使代码更简洁、易读。</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resultArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> resultArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            resultArr.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n; ++i) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n, k, i+<span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剪枝的版本"><a href="#剪枝的版本" class="headerlink" title="剪枝的版本"></a>剪枝的版本</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na/20210130194335207-20230310134409532.png" alt></p>
<p>图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。(因为如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。)</p>
<p>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。</p>
<p>注意代码中i，就是for循环里选择的起始位置。</p>
<p><code>for (int i = startIndex; i &lt;= n; i++) {</code></p>
<p>接下来看一下优化过程如下：</p>
<ul>
<li>已经选择的元素个数：<code>path.size();</code></li>
<li>还需要的元素个数为:<code>k - path.size();</code></li>
<li>在集合n中i最大可以从该起始位置开始遍历 : <code>n - (k - path.size()) + 1</code> (备注: <code>n - (k - path.size())</code> 就是表示从已经最大的数n往回退几个数再开始搜索遍历, 退几个数呢? 退 <code>k - path.size()</code> 个数, 后面多出来的那个 <code>+1</code>是因为要包括起始位置，我们要是一个左闭的集合)</li>
</ul>
<p>那为什么 <code>n - (k - path.size()) + 1</code> 有个+1呢? 因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，<code>n = 4，k = 3</code>， 目前已经选取的元素为0个（即path.size()为0），<code>n - (k - 0) + 1</code> 即 <code>4 - ( 3 - 0) + 1 = 2</code>。</p>
<p>从2开始搜索都是合理的，可以是组合<code>[2, 3, 4]</code>。从”3”开始就不合理了, 因为只能<code>[3, 4, ?]</code>, “4”后面没有了, 只有2个数字”3”和”4”能用.</p>
<p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p>
<p>所以优化之后的for循环是：</p>
<p><code>for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置</code></p>
<p>优化后整体代码 diff 如下：</p>
<figure class="highlight diff"><figcaption><span>java</span></figcaption><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resultArr = new ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        backTracking(n, k, 1);</span><br><span class="line">        return resultArr;</span><br><span class="line">    &#125;</span><br><span class="line">    void backTracking(int n, int k, int startIndex) &#123;</span><br><span class="line">        if (path.size() == k) &#123;</span><br><span class="line">            resultArr.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="deletion">-       for (int i = startIndex; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="addition">+       for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; ++i) &#123;</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n, k, i+1);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><ul>
<li><a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noopener">力扣题目链接</a></li>
<li>参考: <a href="https://github.com/no5ix/leetcode-master/blob/master/problems/0078.子集.md" target="_blank" rel="noopener">https://github.com/no5ix/leetcode-master/blob/master/problems/0078.子集.md</a></li>
</ul>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:<br>输入: <code>nums = [1,2,3]</code><br>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-11.png" alt="alt text"></p>
<p>求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        subsetsHelper(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subsetsHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));<span class="comment">//「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」。</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.length)&#123; <span class="comment">//终止条件可不加</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            subsetsHelper(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><ul>
<li><a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noopener">力扣题目链接</a></li>
<li>参考: <a href="https://github.com/no5ix/leetcode-master/blob/master/problems/0046.全排列.md" target="_blank" rel="noopener">https://github.com/no5ix/leetcode-master/blob/master/problems/0046.全排列.md</a></li>
</ul>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<ul>
<li>输入: <code>[1,2,3]</code></li>
<li>输出:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-9.png" alt="alt text"></p>
<p>首先排列是有序的，也就是说 <code>[1,2]</code> 和 <code>[2,1]</code> 是两个集合，这和之前分析的子集以及组合所不同的地方。</p>
<p>可以看出元素1在 <code>[1,2]</code>中已经使用过了，但是在 <code>[2,1]</code> 中还要在使用一次1，所以处理排列问题就不用使用 <code>startIndex</code> 了。</p>
<p>但排列问题需要一个 <code>used</code> 数组，标记已经选择的元素，如 <code>used: [0, 1, 0]</code> 表示第2个元素已经别用过了, 如图橘黄色部分所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="keyword">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        permuteHelper(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permuteHelper</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            permuteHelper(nums);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>二维坐标中，两点可以连成线，多个点连成的线就构成了图。</p>
<p>当然图也可以就一个节点，甚至没有节点（空图）</p>
<h3 id="图的种类"><a href="#图的种类" class="headerlink" title="图的种类"></a>图的种类</h3><p>整体上一般分为 有向图 和 无向图。 </p>
<p>有向图是指 图中边是有方向的： </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-16.png" alt="alt text"></p>
<p>无向图是指 图中边没有方向： </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-17.png" alt="alt text"></p>
<p>加权有向图，就是图中边是有权值的，例如： </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-18.png" alt="alt text"></p>
<p>加权无向图也是同理。 </p>
<h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><p>无向图中有几条边连接该节点，该节点就有几度。 </p>
<p>例如，该无向图中，节点4的度为5，节点6的度为3。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-19.png" alt="alt text"></p>
<p>在有向图中，每个节点有出度和入度。 </p>
<p>出度：从该节点出发的边的个数。</p>
<p>入度：指向该节点边的个数。 </p>
<p>例如，该有向图中，节点3的入度为2，出度为1，节点1的入度为0，出度为2。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-20.png" alt="alt text"></p>
<h2 id="图的构造"><a href="#图的构造" class="headerlink" title="图的构造"></a>图的构造</h2><p>我们如何用代码来表示一个图呢？ </p>
<p>一般使用邻接表、邻接矩阵 或者用类来表示。 </p>
<p>主要是 朴素存储、邻接表和邻接矩阵。 </p>
<p>关于朴素存储，这是我自创的名字，因为这种存储方式，就是将所有边存下来。 </p>
<p>例如图：  </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-21.png" alt="alt text"></p>
<p>图中有8条边，我们就定义 8 <em> 2的数组，即有n条边就申请n </em> 2，这么大的数组： </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-22.png" alt="alt text"></p>
<p>数组第一行：6 7，就表示节点6 指向 节点7，以此类推。 </p>
<p>当然可以不用数组，用map，或者用 类 到可以表示出 这种边的关系。</p>
<p>这种表示方式的好处就是直观，把节点与节点之间关系很容易展现出来。</p>
<p>但如果我们想知道 节点1 和 节点6 是否相连，我们就需要把存储空间都枚举一遍才行。</p>
<p>这是明显的缺点，同时，我们在深搜和广搜的时候，都不会使用这种存储方式。</p>
<p>因为 搜索中，需要知道 节点与其他节点的链接情况，而这种朴素存储，都需要全部枚举才知道链接情况。 </p>
<p>在图论章节的后面文章讲解中，我会举例说明的。大家先有个印象。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。</p>
<p>例如： grid[2][5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。</p>
<p>如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。</p>
<p>如图： </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-23.png" alt="alt text"></p>
<p>在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间。</p>
<p>图中有一条双向边，即：grid[2][5] = 6，grid[5][2] = 6</p>
<p>这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。 </p>
<p>而且在寻找节点连接情况的时候，需要遍历整个矩阵，即 n * n 的时间复杂度，同样造成时间浪费。 </p>
<p>邻接矩阵的优点： </p>
<ul>
<li>表达方式简单，易于理解</li>
<li>检查任意两个顶点间是否存在边的操作非常快</li>
<li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。 </li>
</ul>
<p>缺点： </p>
<ul>
<li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费 </li>
</ul>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。 </p>
<p>邻接表的构造如图： </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-24.png" alt="alt text"></p>
<p>这里表达的图是： </p>
<ul>
<li>节点1 指向 节点3 和 节点5 </li>
<li>节点2 指向 节点4、节点3、节点5 </li>
<li>节点3 指向 节点4 </li>
<li>节点4指向节点1 </li>
</ul>
<p>有多少边 邻接表才会申请多少个对应的链表节点。 </p>
<p>从图中可以直观看出 使用 数组 + 链表 来表达 边的连接情况 。 </p>
<p>邻接表的优点： </p>
<ul>
<li>对于稀疏图的存储，只需要存储边，空间利用率高 </li>
<li>遍历节点连接情况相对容易</li>
</ul>
<p>缺点： </p>
<ul>
<li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。</li>
<li>实现相对复杂，不易理解 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// final 修饰 adjList，表示这个引用变量本身不能再指向别的对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点及其邻居</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 adjList 中已经有 from 这个 key，就直接返回它对应的 List。</span></span><br><span class="line">	    <span class="comment">// 如果没有，就执行后面的 k -&gt; new ArrayList&lt;&gt;()，新建一个 ArrayList，并自动 put 进去。</span></span><br><span class="line">        adjList.computeIfAbsent(from, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;()).add(to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印图的邻接表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : adjList.entrySet()) &#123;</span><br><span class="line">            System.out.print(entry.getKey() + <span class="string">" -&gt; "</span>);</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按你要求添加边</span></span><br><span class="line">        graph.addEdge(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        graph.addEdge(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        graph.addEdge(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        graph.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        graph.addEdge(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        graph.addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        graph.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印邻接表</span></span><br><span class="line">        graph.printGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dfs-bfs诀窍"><a href="#dfs-bfs诀窍" class="headerlink" title="dfs/bfs诀窍"></a>dfs/bfs诀窍</h2><ul>
<li><p>dfs一般用来解决 <code>求所有可达路径</code> 问题</p>
<ul>
<li>代码框架很类似回溯的代码框架, 因为回溯其实就是在做dfs  <figure class="highlight cpp"><figcaption><span>图论dfs框架</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        dfs(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>bfs一般用来解决 <code>求最短路径</code> 问题</p>
<ul>
<li>只要BFS只要搜到终点一定是一条最短路径, 因为是一层一层一圈一圈来搜的, 搜到的就一定是最短的</li>
<li>代码框架很类似二叉树的bfs, 如下:   <figure class="highlight java"><figcaption><span>图论bfs框架</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义四个方向</span></span><br><span class="line">    <span class="keyword">int</span>[][] dir = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">    <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 定义队列</span></span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="keyword">true</span>; <span class="comment">// 标记为访问过</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = queue.poll(); <span class="comment">// 取出当前节点</span></span><br><span class="line">        <span class="keyword">int</span> curx = cur[<span class="number">0</span>], cury = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 遍历四个方向</span></span><br><span class="line">            <span class="keyword">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nexty = cury + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= rows || nexty &lt; <span class="number">0</span> || nexty &gt;= cols) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 该节点未访问</span></span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextx, nexty&#125;); <span class="comment">// 入队列</span></span><br><span class="line">                visited[nextx][nexty] = <span class="keyword">true</span>; <span class="comment">// 标记访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序是经典的图论问题。</p>
<p>先说说 拓扑排序的应用场景。</p>
<p>大学排课，例如 先上A课，才能上B课，上了B课才能上C课，上了A课才能上D课，等等一系列这样的依赖顺序。 问给规划出一条 完整的上课顺序。</p>
<p>拓扑排序在文件处理上也有应用，我们在做项目安装文件包的时候，经常发现 复杂的文件依赖关系， A依赖B，B依赖C，B依赖D，C依赖E 等等。</p>
<p><strong>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。</strong></p>
<p>当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。</p>
<p>所以拓扑排序也是图论中<strong>判断有向无环图</strong>的常用方法。</p>
<p>实现拓扑排序的算法有两种：卡恩算法（BFS）和DFS</p>
<p>卡恩1962年提出这种解决拓扑排序的思路<br>一般来说我们<strong>只需要掌握 BFS</strong> （广度优先搜索）就可以了</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-26.png" alt="alt text"></p>
<p>做拓扑排序的话，如果肉眼去找开头的节点，一定能找到 节点0 吧，都知道要从节点0 开始。 </p>
<p>但为什么我们能找到 节点0呢，因为我们肉眼看着 这个图就是从 节点0出发的。 </p>
<p>作为出发节点，它有什么特征？ </p>
<p>你看节点0 的入度 为0 出度为2， 也就是 没有边指向它，而它有两条边是指出去的。</p>
<blockquote>
<p>节点的入度表示 有多少条边指向它，节点的出度表示有多少条边 从该节点出发。 </p>
</blockquote>
<p>所以当我们做拓扑排序的时候，应该优先找 入度为 0 的节点，只有入度为0，它才是出发节点。<br><strong>理解以上内容很重要</strong>！  </p>
<p>接下来我给出 拓扑排序的过程，其实就两步： </p>
<ol>
<li>找到入度为0 的节点，加入结果集</li>
<li>将该节点从图中移除  </li>
</ol>
<p>循环以上两步，直到 所有节点都在图中被移除了。 </p>
<p>结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一） </p>
<p>模拟如下:<br><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-27.png" alt="alt text"><br><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-29.png" alt="alt text"><br><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-31.png" alt="alt text"></p>
<p>后面的过程一样的，节点3 和 节点4，入度都为0，选哪个都行。</p>
<p>最后结果集为： 0 1 2 3 4 。当然结果不唯一的。</p>
<h3 id="判断有环"><a href="#判断有环" class="headerlink" title="判断有环"></a>判断有环</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-32.png" alt="alt text"></p>
<p>这个图，我们只能将入度为0 的节点0 接入结果集。</p>
<p>之后，节点1、2、3、4 形成了环，找不到入度为0 的节点了，所以此时结果集里只有一个元素。</p>
<p>那么如果我们发现结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环！</p>
<p>这也是拓扑排序判断有向环的方法。</p>
<p>通过以上过程的模拟大家会发现这个拓扑排序好像不难，还有点简单。</p>
<h3 id="BFS实现的拓扑排序代码"><a href="#BFS实现的拓扑排序代码" class="headerlink" title="BFS实现的拓扑排序代码"></a>BFS实现的拓扑排序代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologicalSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">topoSort</span><span class="params">(<span class="keyword">int</span> n, List&lt;<span class="keyword">int</span>[]&gt; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 初始化邻接表和入度表</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">// 假设节点编号是从1到n</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">0</span>], to = edge[<span class="number">1</span>];</span><br><span class="line">            graph.get(from).add(to);</span><br><span class="line">            inDegree[to]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 把所有入度为0的点先放进队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 正式进行拓扑排序</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = queue.poll();</span><br><span class="line">            result.add(curr);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(curr)) &#123;</span><br><span class="line">                inDegree[neighbor]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 检查是否存在环</span></span><br><span class="line">        <span class="keyword">if</span> (result.size() != n) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Graph has a cycle, no valid topological ordering!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 示例：有4个点，边为：(1-&gt;2), (1-&gt;3), (3-&gt;4), (2-&gt;4)</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; edges = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">        );</span><br><span class="line">        List&lt;Integer&gt; ordering = topoSort(<span class="number">4</span>, edges);</span><br><span class="line">        System.out.println(ordering); <span class="comment">// 输出: [1, 2, 3, 4] 或 [1, 3, 2, 4]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lc210-拓扑排序实战"><a href="#lc210-拓扑排序实战" class="headerlink" title="lc210-拓扑排序实战"></a>lc210-拓扑排序实战</h3><ul>
<li><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">lc210-course schedule2</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/kamacoder/0117.软件构建.md" target="_blank" rel="noopener">Reference1</a></li>
<li><a href="https://leetcode.cn/problems/course-schedule-ii/solutions/8431/tuo-bu-pai-xu-shen-du-you-xian-bian-li-python-dai-/" target="_blank" rel="noopener">Reference2</a></li>
</ul>
<p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where <code>prerequisites[i] = [ai, bi]</code> indicates that you must take course bi first if you want to take course ai.</p>
<p>For example, the pair <code>[0, 1]</code>, indicates that to take course 0 you have to first take course 1.<br>Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:</p>
<ul>
<li>Input: numCourses = 2, prerequisites = <code>[[1,0]]</code></li>
<li>Output: <code>[0,1]</code></li>
<li>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</li>
</ul>
<p>Example 2:</p>
<ul>
<li>Input: numCourses = 4, prerequisites = <code>[[1,0],[2,0],[3,1],[3,2]]</code></li>
<li>Output: <code>[0,2,1,3]</code></li>
<li>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is <code>[0,2,1,3]</code>.</li>
</ul>
<p>Example 3:</p>
<ul>
<li>Input: numCourses = 1, prerequisites = []</li>
<li>Output: [0]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作者：liweiwei1419</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode.cn/problems/course-schedule-ii/solutions/8431/tuo-bu-pai-xu-shen-du-you-xian-bian-li-python-dai-/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numCourses &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt;[] adj = <span class="keyword">new</span> HashSet[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [1,0] 0 -&gt; 1</span></span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">            adj[p[<span class="number">1</span>]].add(p[<span class="number">0</span>]);</span><br><span class="line">            inDegree[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 当前结果集列表里的元素个数，正好可以作为下标</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 当前入度为 0 的结点</span></span><br><span class="line">            Integer head = queue.poll();</span><br><span class="line">            res[count] = head;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            Set&lt;Integer&gt; successors = adj[head];</span><br><span class="line">            <span class="keyword">for</span> (Integer nextCourse : successors) &#123;</span><br><span class="line">                inDegree[nextCourse]--;</span><br><span class="line">                <span class="comment">// 马上检测该结点的入度是否为 0，如果为 0，马上加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (inDegree[nextCourse] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(nextCourse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果结果集中的数量不等于结点的数量，就不能完成课程任务，这一点是拓扑排序的结论</span></span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Union-Find并查集"><a href="#Union-Find并查集" class="headerlink" title="Union-Find并查集"></a>Union-Find并查集</h2><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/kamacoder/图论并查集理论基础.md" target="_blank" rel="noopener">Reference</a></p>
<p>首先要知道并查集可以解决什么问题呢？</p>
<p>并查集常用来解决连通性问题。</p>
<p>大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。</p>
<p>并查集主要有两个功能：</p>
<ul>
<li>将两个元素添加到一个集合中。</li>
<li>判断两个元素在不在同一个集合</li>
</ul>
<p>接下来围绕并查集的这两个功能来展开讲解。</p>
<h3 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h3><p>从代码层面，我们如何将两个元素添加到同一个集合中呢。</p>
<p>此时有录友会想到：可以把他放到同一个数组里或者set 或者 map 中，这样就表述两个元素在同一个集合。</p>
<p>那么问题来了，对这些元素分门别类，可不止一个集合，可能是很多集合，成百上千，那么要定义这么多个数组吗？</p>
<p>有录友想，那可以定义一个二维数组。</p>
<p>但如果我们要判断两个元素是否在同一个集合里的时候 我们又能怎么办？ 只能把而二维数组都遍历一遍。</p>
<p>而且每当想添加一个元素到某集合的时候，依然需要把把二维数组都遍历一遍，才知道要放在哪个集合里。</p>
<p>这仅仅是一个粗略的思路，如果沿着这个思路去实现代码，非常复杂，因为管理集合还需要很多逻辑。</p>
<p>那么我们来换一个思路来看看。</p>
<p>我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是将三个元素连通在一起，如何连通呢。</p>
<p>只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将v，u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = find(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能有录友想，这样我可以知道 A 连通 B，因为 A 是索引下标，根据 father[A]的数值就知道 A 连通 B。那怎么知道 B 连通 A呢？</p>
<p>我们的目的是判断这三个元素是否在同一个集合里，知道 A 连通 B 就已经足够了。</p>
<p>这里要讲到寻根思路，只要 A ，B，C 在同一个根下就是同一个集合。</p>
<p>给出A元素，就可以通过 father[A] = B，father[B] = C，找到根为 C。</p>
<p>给出B元素，就可以通过 father[B] = C，找到根也为为 C，说明 A 和 B 是在同一个集合里。<br>大家会想第一段代码里find函数是如何实现的呢？其实就是通过数组下标找到数组元素，一层一层寻根过程，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u])</span><br><span class="line">        <span class="keyword">return</span> u; <span class="comment">// 如果根就是自己，直接返回</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> find(father[u]); <span class="comment">// 如果根不是自己，就根据数组下标一层一层向下找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何表示 C 也在同一个元素里呢？ 我们需要 father[C] = C，即C的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。</p>
<p>所以father数组初始化的时候要 father[i] = i，默认自己指向自己。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们如何判断两个元素是否在同一个集合里，如果通过 find函数 找到 两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。</p>
<p>搜索过程像是一个多叉树中从叶子到根节点的过程，如图：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-33.png" alt="alt text"></p>
<p>如果这棵多叉树高度很深的话，每次find函数 去寻找根的过程就要递归很多次。</p>
<p>我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="../img/algo_na_tricks/image-34.png" alt="alt text"></p>
<p>除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，</p>
<p>如果我们想达到这样的效果，就需要 <strong>路径压缩</strong>，将非根节点的所有节点直接指向根节点。<br>那么在代码层面如何实现呢？</p>
<p>我们只需要在递归的过程中，让 <code>father[u]</code> 接住 递归函数  find(<code>father[u]</code>) 的返回结果。</p>
<p>因为 find 函数向上寻找根节点，<code>father[u]</code> 表述 u 的父节点，那么让 <code>father[u]</code> 直接获取 find函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。</p>
<p>代码如下，注意看注释，路径压缩就一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u])</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> father[u] = find(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信不少录友在学习并查集的时候，对上面这三行代码实现的 find函数 很熟悉，但理解上却不够深入，仅仅知道这行代码很好用，不知道这里藏着路径压缩的过程。</p>
<p>所以对于算法初学者来说，直接看精简代码学习是不太友好的，往往忽略了很多细节。</p>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>那么此时并查集的模板就出来了， 整体模板C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u])</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> father[u] = find(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = find(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过模板，我们可以知道，并查集主要有三个功能。</p>
<ol>
<li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li>
<li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li>
<li>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</li>
</ol>
<h3 id="经典题-lc721-Accounts-Merge"><a href="#经典题-lc721-Accounts-Merge" class="headerlink" title="经典题-lc721-Accounts Merge"></a>经典题-lc721-Accounts Merge</h3><p>Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.</p>
<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>
<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p>
<p>Example 1:</p>
<p>Input: <code>accounts</code> = <code>[[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john_newyork@mail.com&quot;],[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john00@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]</code><br>Output: <code>[[&quot;John&quot;,&quot;john00@mail.com&quot;,&quot;john_newyork@mail.com&quot;,&quot;johnsmith@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]</code><br>Explanation:<br>The first and second John’s are the same person as they have the common email <code>&quot;johnsmith@mail.com&quot;</code>.<br>The third John and Mary are different people as none of their email addresses are used by other accounts.<br>We could return these lists in any order, for example the answer <code>[[&#39;Mary&#39;, &#39;mary@mail.com&#39;], [&#39;John&#39;, &#39;johnnybravo@mail.com&#39;], [&#39;John&#39;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;]]</code> would still be accepted.</p>
<p>Example 2:</p>
<p>Input: <code>accounts</code> = <code>[[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe3@m.co&quot;,&quot;Gabe1@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;,&quot;Kevin0@m.co&quot;],[&quot;Ethan&quot;,&quot;Ethan5@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan0@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo3@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo0@m.co&quot;],[&quot;Fern&quot;,&quot;Fern5@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern0@m.co&quot;]]</code><br>Output: <code>[[&quot;Ethan&quot;,&quot;Ethan0@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan5@m.co&quot;],[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe1@m.co&quot;,&quot;Gabe3@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo0@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo3@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin0@m.co&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;],[&quot;Fern&quot;,&quot;Fern0@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern5@m.co&quot;]]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本质是 图论中的连通分量问题。邮箱是节点，有边就表示两个邮箱属于同一人。</span></span><br><span class="line"><span class="comment">// 我们用 并查集（Union-Find） 来解决。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集处理邮箱之间的连接关系；</span></span><br><span class="line"><span class="comment">// 最终以代表邮箱为 key，聚合所有属于同一组的邮箱。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">        <span class="comment">// parent 映射：记录每个邮箱的根邮箱（并查集用）</span></span><br><span class="line">        Map&lt;String, String&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// emailToName 映射：记录每个邮箱对应的用户名</span></span><br><span class="line">        Map&lt;String, String&gt; emailToName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个账户</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</span><br><span class="line">            String name = account.get(<span class="number">0</span>); <span class="comment">// 第一个元素是用户名</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); i++) &#123;</span><br><span class="line">                String email = account.get(i); <span class="comment">// 获取邮箱</span></span><br><span class="line">                parent.putIfAbsent(email, email); <span class="comment">// 初始化：邮箱的父节点是它自己</span></span><br><span class="line">                emailToName.put(email, name); <span class="comment">// 记录邮箱对应的用户名</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将当前邮箱与前一个邮箱 union（表示它们属于同一个用户）</span></span><br><span class="line">                    union(parent, email, account.get(i - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建每个根节点邮箱对应的一组邮箱集合（同一个人）</span></span><br><span class="line">        Map&lt;String, TreeSet&lt;String&gt;&gt; unions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String email : parent.keySet()) &#123;</span><br><span class="line">            String root = find(parent, email); <span class="comment">// 找到该邮箱最终归属的根节点</span></span><br><span class="line">            <span class="comment">// 加入该根节点代表的邮箱组</span></span><br><span class="line">            unions.computeIfAbsent(root, x -&gt; <span class="keyword">new</span> TreeSet&lt;&gt;()).add(email); <span class="comment">// TreeSet自动去重和排序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建最终结果列表</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, TreeSet&lt;String&gt;&gt; entry : unions.entrySet()) &#123;</span><br><span class="line">            List&lt;String&gt; merged = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String name = emailToName.get(entry.getKey()); <span class="comment">// 获取用户名</span></span><br><span class="line">            merged.add(name); <span class="comment">// 添加用户名</span></span><br><span class="line">            merged.addAll(entry.getValue()); <span class="comment">// 添加排序后的邮箱列表</span></span><br><span class="line">            res.add(merged); <span class="comment">// 添加到结果中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回最终合并后的账户列表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集的查找函数，带路径压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">find</span><span class="params">(Map&lt;String, String&gt; parent, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.equals(parent.get(s))) &#123;</span><br><span class="line">            parent.put(s, find(parent, parent.get(s))); <span class="comment">// 路径压缩：更新 s 的父节点为根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.get(s); <span class="comment">// 返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集的合并函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Map&lt;String, String&gt; parent, String s1, String s2)</span> </span>&#123;</span><br><span class="line">        String root1 = find(parent, s1); <span class="comment">// 找 s1 的根节点</span></span><br><span class="line">        String root2 = find(parent, s2); <span class="comment">// 找 s2 的根节点</span></span><br><span class="line">        <span class="keyword">if</span> (!root1.equals(root2)) &#123;</span><br><span class="line">            parent.put(root1, root2); <span class="comment">// 合并两个集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Quick-Select"><a href="#Quick-Select" class="headerlink" title="Quick Select"></a>Quick Select</h1><h2 id="模板与诀窍"><a href="#模板与诀窍" class="headerlink" title="模板与诀窍"></a>模板与诀窍</h2><ul>
<li>适合解决 Top K 问题, 因为最快</li>
<li>快速选择平均情况下，时间复杂度为 O(N)。</li>
<li>空间复杂度：O(N)。哈希表的大小为 O(N)，用于排序的数组的大小也为 O(N)，快速排序的空间复杂度最好情况为 O(logN)，最坏情况为 O(N)。</li>
<li>参考 <a href="/algo_newbie/" title="algo_newbie">algo_newbie</a> ##普通快排 里的代码, 及其动画演示(safari可能播放不了视频), 帮助理解</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-14.png" alt="alt text"></p>
<figure class="highlight java"><figcaption><span>QuickSelect模板</span></figcaption><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topK(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> partitionIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> targetIndex = nums.length - k;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = pairLen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        partitionIndex = quickSelect(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (partitionIndex == targetIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (partitionIndex &gt; targetIndex) &#123;</span><br><span class="line">            right = partitionIndex - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = partitionIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int randIndex = (int) (Math.random() * (right - left + 1)) + left;</span></span><br><span class="line">    <span class="keyword">int</span> randIndex = random.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">    swap(randIndex, left)</span><br><span class="line"></span><br><span class="line">    Pair pivot = nums[left];</span><br><span class="line">    <span class="keyword">int</span> partitionIndex = left;  <span class="comment">// 参考 algo_newbie.md ##普通快排 里的代码, 及其动画演示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">            swap(partitionIndex + <span class="number">1</span>, i)</span><br><span class="line">            partitionIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(left, partitionIndex);</span><br><span class="line">    <span class="keyword">return</span> partitionIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lc347-Top-K-Frequent-Elements"><a href="#lc347-Top-K-Frequent-Elements" class="headerlink" title="lc347 - Top K Frequent Elements"></a>lc347 - Top K Frequent Elements</h2><ul>
<li><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">https://leetcode.com/problems/top-k-frequent-elements/description/</a></li>
<li><a href="https://programmercarl.com/0347.前K个高频元素.html#其他语言版本" target="_blank" rel="noopener">https://programmercarl.com/0347.前K个高频元素.html#其他语言版本</a></li>
<li>Similar problem: <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></li>
</ul>
<p>We should solve this kind of top-level problem using the “Quick Select” approach (it’s very similar to Quick Sort). Because its time complexity of O(n) is lower, this method is more efficient than the Heap-based approach with a time complexity of O(nlogn).</p>
<p>Referenced this: <a href="https://www.bilibili.com/video/BV1Bz4y117Fr/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Bz4y117Fr/</a></p>
<ul>
<li>时间复杂度：O(N)，其中 N 为数组的长度。<br>设处理长度为 N 的数组的时间复杂度为 f(N)。由于处理的过程包括一次遍历和一次子分支的递归，最好情况下，有 f(N)=O(N)+f(N/2)，根据 主定理，能够得到 f(N)=O(N)。</li>
<li>最坏情况下，每次取的中枢数组的元素都位于数组的两端，时间复杂度退化为 O(N)。但由于我们在每次递归的开始会先随机选取中枢元素，故出现最坏情况的概率很低。</li>
<li>平均情况下，时间复杂度为 O(N)。</li>
<li>空间复杂度：O(N)。哈希表的大小为 O(N)，用于排序的数组的大小也为 O(N)，快速排序的空间复杂度最好情况为 O(logN)，最坏情况为 O(N)。</li>
</ul>
<p>链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements/solutions/402568/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode.cn/problems/top-k-frequent-elements/solutions/402568/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int[] array = &#123;10, 7, 8, 9, 1, 5&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = topKFrequent(array, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// int[] array = &#123;1&#125;;</span></span><br><span class="line">        <span class="comment">// int[] res = topKFrequent(array, 1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : res) &#123;</span><br><span class="line">            System.out.print(<span class="string">"num: "</span> + num + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Pair[] pairs = <span class="keyword">new</span> Pair[map.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            pairs[index++] = <span class="keyword">new</span> Pair(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> partitionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pairLen = pairs.length;</span><br><span class="line">        <span class="keyword">int</span> targetIndex = pairLen - k;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = pairLen - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// System.out.println(high);</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            partitionIndex = quickSelect(pairs, low, high);</span><br><span class="line">            <span class="keyword">if</span> (partitionIndex == targetIndex) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                    res[i] = pairs[--pairLen].num;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (partitionIndex &gt; targetIndex) &#123;</span><br><span class="line">                high = partitionIndex - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = partitionIndex + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(Pair[] pairs, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(low);</span></span><br><span class="line">        <span class="comment">// System.out.println(high);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// To generate a random number within the range [3, 6], where both 3 and 6 are inclusive, you can modify the logic slightly from the [3, 6) approach:</span></span><br><span class="line">        <span class="comment">// double randomNumber = 3 + (Math.random() * (6 - 3 + 1));</span></span><br><span class="line">        <span class="comment">// 1.	Math.random() generates a random number in the range [0.0, 1.0).</span></span><br><span class="line">        <span class="comment">// 2.	Multiplying it by (6 - 3 + 1) (which is 4) adjusts the range to [0.0, 4.0).</span></span><br><span class="line">        <span class="comment">// 3.	Adding 3 shifts the range to [3.0, 7.0).</span></span><br><span class="line">        <span class="comment">// 4.	Since the inclusive range is [3, 6], you’ll need to truncate or floor the result if you’re generating an integer.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> picked = (<span class="keyword">int</span>) (Math.random() * (high - low + <span class="number">1</span>)) + low;</span><br><span class="line">        Pair tempPair = pairs[low];</span><br><span class="line">        pairs[low] = pairs[picked];</span><br><span class="line">        pairs[picked] = tempPair;</span><br><span class="line"></span><br><span class="line">        Pair pivot = pairs[low];</span><br><span class="line">        <span class="keyword">int</span> partitionIndex = low;  <span class="comment">// 参考 algo_newbie.md ##普通快排 里的代码, 及其动画演示</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt;= high; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs[i].freq &lt; pivot.freq) &#123;</span><br><span class="line">                Pair temp = pairs[i];</span><br><span class="line">                pairs[i] = pairs[partitionIndex + <span class="number">1</span>];</span><br><span class="line">                pairs[partitionIndex + <span class="number">1</span>] = temp;</span><br><span class="line">                partitionIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pairs[low] = pairs[partitionIndex];</span><br><span class="line">        pairs[partitionIndex] = pivot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> partitionIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">int</span> freq;</span><br><span class="line">        Pair(<span class="keyword">int</span> number, <span class="keyword">int</span> frequency) &#123;</span><br><span class="line">            num = number;</span><br><span class="line">            freq = frequency;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h1><p><a href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-" target="_blank" rel="noopener">Reference</a></p>
<p>在 LeetCode 中，「岛屿问题」是一个系列系列问题，比如：</p>
<ul>
<li><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">L200. 岛屿数量 （Easy）</a></li>
<li><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿的周长 （Easy）</a></li>
<li><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">岛屿的最大面积 （Medium）</a></li>
<li><a href="https://leetcode.com/problems/making-a-large-island/" target="_blank" rel="noopener">最大人工岛 （Hard）</a></li>
</ul>
<p>我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「网格」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。</p>
<p>本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。</p>
<h2 id="网格类问题的-DFS-遍历方法"><a href="#网格类问题的-DFS-遍历方法" class="headerlink" title="网格类问题的 DFS 遍历方法"></a>网格类问题的 DFS 遍历方法</h2><h3 id="网格问题的基本概念"><a href="#网格问题的基本概念" class="headerlink" title="网格问题的基本概念"></a>网格问题的基本概念</h3><p>我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。</p>
<p>网格问题是由 m×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p>
<p>岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-1.png" alt="alt text"></p>
<p>岛屿问题示例</p>
<p>在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。</p>
<h4 id="DFS-的基本结构"><a href="#DFS-的基本结构" class="headerlink" title="DFS 的基本结构"></a>DFS 的基本结构</h4><p>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问两个相邻结点：左子结点、右子结点</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，二叉树的 DFS 有两个要素：「访问相邻结点」和「判断 base case」。</p>
<ul>
<li><p><strong>第一个要素</strong>是访问相邻结点。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。</p>
</li>
<li><p><strong>第二个要素</strong>是 判断 base case。一般来说，二叉树遍历的 base case 是 root == null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 root == null 的时候及时返回，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。</p>
</li>
</ul>
<p>对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：</p>
<p>首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 <code>(r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)</code>。换句话说，网格结构是「四叉」的。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-2.png" alt="alt text"></p>
<p>网格结构中四个相邻的格子</p>
<p>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、<code>grid[r][c]</code> 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-3.png" alt="alt text"></p>
<p>网格 DFS 的 base case</p>
<p>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 <code>root == null</code> 再返回。</p>
<p>这样，我们得到了网格 DFS 遍历的框架代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何避免重复遍历"><a href="#如何避免重复遍历" class="headerlink" title="如何避免重复遍历"></a>如何避免重复遍历</h4><p>网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。</p>
<p>这时候，DFS 可能会不停地「兜圈子」，永远停不下来，如下图所示：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-4.gif" alt="alt text"></p>
<p>DFS 遍历可能会兜圈子（动图）</p>
<p>如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：</p>
<ul>
<li>0 —— 海洋格子</li>
<li>1 —— 陆地格子（未遍历过）</li>
<li>2 —— 陆地格子（已遍历过）<br>我们在框架代码中加入避免重复遍历的语句：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-5.gif" alt="alt text"></p>
<p>标记已遍历的格子</p>
<p>这样，我们就得到了一个岛屿问题、乃至各种网格问题的通用 DFS 遍历方法。以下所讲的几个例题，其实都只需要在 DFS 遍历框架上稍加修改而已。</p>
<p>小贴士：</p>
<p>在一些题解中，可能会把「已遍历过的陆地格子」标记为和海洋格子一样的 0，美其名曰「陆地沉没方法」，即遍历完一个陆地格子就让陆地「沉没」为海洋。这种方法看似很巧妙，但实际上有很大隐患，因为这样我们就无法区分「海洋格子」和「已遍历过的陆地格子」了。如果题目更复杂一点，这很容易出 bug。</p>
<h3 id="岛屿问题的解法"><a href="#岛屿问题的解法" class="headerlink" title="岛屿问题的解法"></a>岛屿问题的解法</h3><p>理解了网格结构的 DFS 遍历方法以后，岛屿问题就不难解决了。下面我们分别看看三个题目该如何用 DFS 遍历来求解。</p>
<h4 id="例题-0-岛屿数量"><a href="#例题-0-岛屿数量" class="headerlink" title="例题 0: 岛屿数量"></a>例题 0: 岛屿数量</h4><p><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">LeetCode 200. Number of islands （Medium）</a></p>
<p>Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands.</p>
<p>An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>solution</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; grid[<span class="number">0</span>].length)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题-1：岛屿的最大面积"><a href="#例题-1：岛屿的最大面积" class="headerlink" title="例题 1：岛屿的最大面积"></a>例题 1：岛屿的最大面积</h4><p><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">LeetCode 695. Max Area of Island （Medium）</a></p>
<p>Example 1: </p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-10.png" alt="alt text"></p>
<ul>
<li>Input: grid = <code>[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]</code></li>
<li>Output: 6</li>
<li>Explanation: The answer is not 11, because the island must be connected 4-directionally.</li>
</ul>
<p>Example 2:</p>
<ul>
<li>Input: grid = <code>[[0,0,0,0,0,0,0,0]]</code></li>
<li>Output: 0</li>
</ul>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid，一个岛屿是一组相邻的 1（代表陆地），这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表海洋）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>
<p>这道题目只需要对每个岛屿做 DFS 遍历，求出每个岛屿的面积就可以了。求岛屿面积的方法也很简单，代码如下，每遍历到一个格子，就把面积加一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        + area(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + area(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + area(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + area(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们得到的完整题解代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; grid.length; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = area(grid, r, c);</span><br><span class="line">                res = Math.max(res, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        + area(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + area(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + area(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + area(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题-2：填海造陆问题"><a href="#例题-2：填海造陆问题" class="headerlink" title="例题 2：填海造陆问题"></a>例题 2：填海造陆问题</h4><p><a href="https://leetcode.com/problems/making-a-large-island/" target="_blank" rel="noopener">LeetCode 827. Making A Large Island （Hard）</a></p>
<p>在二维地图上， 0 代表海洋，1代表陆地，我们最多只能将一格 0 （海洋）变成 1 （陆地）。进行填海之后，地图上最大的岛屿面积是多少？</p>
<p>这道题是岛屿最大面积问题的升级版。现在我们有填海造陆的能力，可以把一个海洋格子变成陆地格子，进而让两块岛屿连成一块。那么填海造陆之后，最大可能构造出多大的岛屿呢？</p>
<p>大致的思路我们不难想到，我们先计算出所有岛屿的面积，在所有的格子上标记出岛屿的面积。然后搜索哪个海洋格子相邻的两个岛屿面积最大。例如下图中红色方框内的海洋格子，上边、左边都与岛屿相邻，我们可以计算出它变成陆地之后可以连接成的岛屿面积为 <code>7+1+2=10</code>。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-4.png" alt="alt text"></p>
<p>一个海洋格子连接起两个岛屿</p>
<p>然而，这种做法可能遇到一个问题。如下图中红色方框内的海洋格子，它的上边、左边都与岛屿相邻，这时候连接成的岛屿面积难道是 <code>7+1+7</code> ？显然不是。这两个 7 来自同一个岛屿，所以填海造陆之后得到的岛屿面积应该只有 <code>7+1=8</code>。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-5.png" alt="alt text"></p>
<p>一个海洋格子与同一个岛屿有两个边相邻</p>
<p>可以看到，要让算法正确，我们得能区分一个海洋格子相邻的两个 7 是不是来自同一个岛屿。那么，我们不能在方格中标记岛屿的面积，而应该标记岛屿的索引（下标），另外用一个数组记录每个岛屿的面积，如下图所示。这样我们就可以发现红色方框内的海洋格子，它的「两个」相邻的岛屿实际上是同一个。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-6.png" alt="alt text"></p>
<p>标记每个岛屿的索引（下标）</p>
<p>可以看到，这道题实际上是对网格做了两遍 DFS：第一遍 DFS 遍历陆地格子，计算每个岛屿的面积并标记岛屿；第二遍 DFS 遍历海洋格子，观察每个海洋格子相邻的陆地格子。</p>
<p>这道题的基本思路就是这样，具体的代码还有一些需要注意的细节，但和本文的主题已经联系不大。各位可以自己思考一下如何把上述思路转化为代码。</p>
<h4 id="例题-3：岛屿的周长"><a href="#例题-3：岛屿的周长" class="headerlink" title="例题 3：岛屿的周长"></a>例题 3：岛屿的周长</h4><p><a href="https://leetcode.com/problems/island-perimeter/" target="_blank" rel="noopener">LeetCode 463. Island Perimeter （Easy）</a></p>
<p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地，0 表示海洋。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（一个或多个表示陆地的格子相连组成岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。计算这个岛屿的周长。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-7.png" alt="alt text"></p>
<p>题目示例</p>
<p>实话说，这道题用 DFS 来解并不是最优的方法。对于岛屿，直接用数学的方法求周长会更容易。不过这道题是一个很好的理解 DFS 遍历过程的例题，不信你跟着我往下看。</p>
<p>我们再回顾一下 网格 DFS 遍历的基本框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，dfs 函数直接返回有这几种情况：</p>
<p><code>!inArea(grid, r, c)</code>，即坐标 <code>(r, c)</code> 超出了网格的范围，也就是我所说的「先污染后治理」的情况<br><code>grid[r][c] != 1</code>，即当前格子不是岛屿格子，这又分为两种情况：<br><code>grid[r][c] == 0</code>，当前格子是海洋格子<br><code>grid[r][c] == 2</code>，当前格子是已遍历的陆地格子<br>那么这些和我们岛屿的周长有什么关系呢？实际上，岛屿的周长是计算岛屿全部的「边缘」，而这些边缘就是我们在 DFS 遍历中，dfs 函数返回的位置。观察题目示例，我们可以将岛屿的周长中的边分为两类，如下图所示。黄色的边是与网格边界相邻的周长，而蓝色的边是与海洋格子相邻的周长。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/img/algo_na_tricks/image-8.png" alt="alt text"></p>
<p>将岛屿周长中的边分为两类</p>
<p>当我们的 dfs 函数因为「坐标 <code>(r, c)</code> 超出网格范围」返回的时候，实际上就经过了一条黄色的边；而当函数因为「当前格子是海洋格子」返回的时候，实际上就经过了一条蓝色的边。这样，我们就把岛屿的周长跟 DFS 遍历联系起来了，我们的题解代码也呼之欲出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; grid.length; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 题目限制只有一个岛屿，计算一个即可</span></span><br><span class="line">                <span class="keyword">return</span> dfs(grid, r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数因为「坐标 (r, c) 超出网格范围」返回，对应一条黄色的边</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数因为「当前格子是海洋格子」返回，对应一条蓝色的边</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数因为「当前格子是已遍历的陆地格子」返回，和周长没关系</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结,<br>对比完三个例题的题解代码，你会发现网格问题的代码真的都非常相似。其实这一类问题属于「会了不难」类型。了解树、图的基本遍历方法，再学会一点小技巧，掌握网格 DFS 遍历就一点也不难了。</p>
<h1 id="Sweep-Line"><a href="#Sweep-Line" class="headerlink" title="Sweep Line"></a>Sweep Line</h1><p>扫描线算法</p>
<p>leetcode-253. Meeting Rooms II 🔒</p>
<p>Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.</p>
<p>Example 1:</p>
<ul>
<li>Input: intervals = <code>[[0,30],[5,10],[15,20]]</code></li>
<li>Output: 2</li>
</ul>
<p>Example 2:</p>
<ul>
<li>Input: intervals = <code>[[7,10],[2,4]]</code></li>
<li>Output: 1</li>
</ul>
<p>Constraints:</p>
<ul>
<li>1 &lt;= intervals.length &lt;= 104</li>
<li>0 &lt;= starti &lt; endi &lt;= 106</li>
</ul>
<p>Oral summary of solution:</p>
<p>To solve this problem, I think we can use a sweep line approach. We can use a TreeMap to simulate the sweep line, where the key is the time point and the value represents the change in meeting room count.</p>
<p>Then, we iterate through the given array. For each interval, we add the start time to the TreeMap with a value of +1 to indicate a meeting starting, and the end time with a value of -1 to indicate a meeting ending.</p>
<p>After building the TreeMap, we iterate through its values. We maintain a variable to track the ongoing number of meetings, and another variable to record the maximum count during the iteration.</p>
<p>Finally, the maximum count will be the minimum number of meeting rooms required.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeetingRoomsII_SweepLine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们用一个有序 map（TreeMap）来模拟“时间线”，</span></span><br><span class="line">        <span class="comment">// key 是时间点，value 是“这个时间点上会议数量的变化”：</span></span><br><span class="line">        <span class="comment">// +1 表示开始一个会议，-1 表示结束一个会议。</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; timeline = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把每个开始时间 +1，每个结束时间 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="comment">// 在会议开始的时间点上 +1，表示某个会议在这里开始。</span></span><br><span class="line">            timeline.put(interval[<span class="number">0</span>], timeline.getOrDefault(interval[<span class="number">0</span>], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 在会议结束的时间点上 -1，表示会议在这里结束了。</span></span><br><span class="line">            timeline.put(interval[<span class="number">1</span>], timeline.getOrDefault(interval[<span class="number">1</span>], <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ongoing = <span class="number">0</span>;  <span class="comment">// 当前正在进行的会议数量</span></span><br><span class="line">        <span class="keyword">int</span> maxRooms = <span class="number">0</span>; <span class="comment">// 最大会议室数量需求</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count : timeline.values()) &#123;</span><br><span class="line">            <span class="comment">// 每个时间点，根据 +1/-1 累加当前活跃的会议数量。</span></span><br><span class="line">            ongoing += count;</span><br><span class="line">            <span class="comment">// 每次更新最大并发会议数量，也就是需要的会议室数。</span></span><br><span class="line">            maxRooms = Math.max(maxRooms, ongoing);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxRooms;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 TreeMap 扫描线解法之所以正确，是因为它严格模拟了一个<strong>按时间推进的“会议并发数统计”过程</strong>，用<strong>事件驱动模型</strong>捕捉“会议什么时候开始”、“什么时候结束”，并实时维护“正在进行的会议数量”。</p>
<p>举个例子直观说明</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0, 30], [5, 10], [15, 20]]</span><br></pre></td></tr></table></figure>
<p>事件点拆解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0  → +1</span><br><span class="line">5  → +1</span><br><span class="line">10 → -1</span><br><span class="line">15 → +1</span><br><span class="line">20 → -1</span><br><span class="line">30 → -1</span><br></pre></td></tr></table></figure>
<p>扫描过程：</p>
<ul>
<li>time = 0 → ongoing = 1</li>
<li>time = 5 → ongoing = 2</li>
<li>time = 10 → ongoing = 1</li>
<li>time = 15 → ongoing = 2</li>
<li>time = 20 → ongoing = 1</li>
<li>time = 30 → ongoing = 0</li>
</ul>
<p>最大值是 <strong>2</strong> → 就是需要两个会议室。</p>
<hr>
<p>为什么这个方法是完全正确的？</p>
<p>它基于如下数学逻辑：</p>
<ul>
<li>任意时刻需要多少会议室，等于“当前正在开的会议数量”；</li>
<li>通过事件模型精准统计每个时间点“增加/减少”的会议数量；</li>
<li>最大同时进行的会议数量，就是你所需要的最少会议室数量。</li>
</ul>
<p>方法的优势：可靠、精确、通用</p>
<ul>
<li>它不依赖会议顺序、不会出错于边界（比如两个会议在某一时刻交叉）；</li>
<li>可以处理大规模事件（10^4 级别），性能良好；</li>
<li>是许多高级面试题的基础，比如<strong>区间重叠、矩形扫描、处理冲突事件</strong>等。</li>
</ul>

      


      

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Algo/" rel="tag"><i class="fa fa-tag"></i> Algo</a>
            
              <a href="/tags/noodle/" rel="tag"><i class="fa fa-tag"></i> noodle</a>
            
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
            
              <a href="/tags/NA/" rel="tag"><i class="fa fa-tag"></i> NA</a>
            
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i> LeetCode</a>
            
          </div>
        

        
        
        

        
          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/cpu_core_processor_thread_info/" rel="next" title="逻辑CPU与核心备忘">
                  <i class="fa fa-chevron-left"></i> 
                  <p class="post-nav-pre-next-title">
                    逻辑CPU与核心备忘
                  </p> 
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/muduo_qa/" rel="prev" title="muduo详解之网络编程难点解读">
                <p class="post-nav-pre-next-title">
                    muduo详解之网络编程难点解读
                </p> 
                <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        

        
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA4MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0zNSAyNUg0NVYzNUgzNVYyNVoiIGZpbGw9IiNEREREREQiLz4KPC9zdmc+" data-src="/uploads/avatar.png" alt="Mike">
          </a>
          <p class="site-author-name" itemprop="name">Mike</p>
           
              <p class="site-description motion-element" itemprop="description">🚙 🚗 💨 💨 If you want to create a blog like this, just follow my open-source project, "hexo-theme-neo", click the GitHub button below and check it out ^_^ . It is recommended to use Chrome, Safari, or Edge to read this blog since this blog was developed on Edge (Chromium kernel version) and tested on Safari.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">296</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">111</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">about</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/no5ix" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://open.spotify.com/user/313duq77ekebrfyak3xijqewzss4?si=e7653b829a9747bf" target="_blank" title="Spotify">
                  
                    <i class="fa fa-fw fa-spotify"></i>
                  
                    
                      Spotify
                    
                </a>
              </span>
            
          
          
          <!-- 网易云音乐 -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- 网易云音乐 -->

        </div>

        
        

        
        

        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#算法白话总结"><span class="nav-text">算法白话总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#概绍"><span class="nav-text">概绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#北美算法面试性价比topic类型"><span class="nav-text">北美算法面试性价比topic类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本文完整参考代码"><span class="nav-text">本文完整参考代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用小技巧"><span class="nav-text">常用小技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何求一个数字有多少位数"><span class="nav-text">如何求一个数字有多少位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从最高位数开始遍历一个数字"><span class="nav-text">从最高位数开始遍历一个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从个位数开始遍历一个数字"><span class="nav-text">从个位数开始遍历一个数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java常用接口和实现"><span class="nav-text">Java常用接口和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Convert-a-number-to-a-string-and-vice-versa"><span class="nav-text">Convert a number to a string and vice versa</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机数"><span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#值传递"><span class="nav-text">值传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用简单排序"><span class="nav-text">常用简单排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-by-primitive-type"><span class="nav-text">sort by primitive type</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sort-by-int"><span class="nav-text">sort by int</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort-by-char"><span class="nav-text">sort by char</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-by-wrapper-type"><span class="nav-text">sort by wrapper type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-text">Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-text">List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue"><span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deque"><span class="nav-text">Deque</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack-一般不用因为有性能问题"><span class="nav-text">Stack(一般不用因为有性能问题)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-and-Character"><span class="nav-text">String and Character</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#复杂度有啥用"><span class="nav-text">复杂度有啥用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#诀窍"><span class="nav-text">诀窍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分法诀窍与易错点"><span class="nav-text">二分法诀窍与易错点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找扩展题-lc69-求平方"><span class="nav-text">二分查找扩展题-lc69-求平方</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前缀和诀窍"><span class="nav-text">前缀和诀窍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lc528-前缀和-二分"><span class="nav-text">lc528-前缀和+二分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双指针诀窍"><span class="nav-text">双指针诀窍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lc27-Remove-Element"><span class="nav-text">lc27-Remove Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc977-有序数组的平方"><span class="nav-text">lc977-有序数组的平方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc15-3Sum"><span class="nav-text">lc15-3Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc18-4Sum"><span class="nav-text">lc18-4Sum</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动窗口模板与生动理论"><span class="nav-text">滑动窗口模板与生动理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口的复杂度"><span class="nav-text">滑动窗口的复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口的模板"><span class="nav-text">滑动窗口的模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc1004-Max-Consecutive-Ones-III"><span class="nav-text">lc1004-Max Consecutive Ones III</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表"><span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#诀窍-1"><span class="nav-text">诀窍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lc206-链表反转"><span class="nav-text">lc206 - 链表反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lc24-两两交换链表中的节点"><span class="nav-text">lc24 - 两两交换链表中的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lc142-链表是否有环"><span class="nav-text">lc142-链表是否有环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lc28-实现strStr-20240923"><span class="nav-text">lc28 - 实现strStr() - 20240923</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#暴力解法-掌握这个暴力解法即可"><span class="nav-text">暴力解法-掌握这个暴力解法即可</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP不要求-面试基本不会出的-背代码就没意思了"><span class="nav-text">KMP不要求-面试基本不会出的-背代码就没意思了</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lc459-重复的子字符串-暴力解法-掌握这个暴力解法即可"><span class="nav-text">lc459 - 重复的子字符串-暴力解法-掌握这个暴力解法即可</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈与队列"><span class="nav-text">栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#诀窍-2"><span class="nav-text">诀窍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单调栈-monotonic-stack"><span class="nav-text">单调栈-monotonic stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单调栈经典题-lc739-每日温度"><span class="nav-text">单调栈经典题-lc739-每日温度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lc239-Sliding-Window-Maximum"><span class="nav-text">lc239 - Sliding Window Maximum</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树"><span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#诀窍-3"><span class="nav-text">诀窍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#层序-相当重要"><span class="nav-text">层序(相当重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前序-迭代法重要"><span class="nav-text">前序(迭代法重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中序-迭代法重要"><span class="nav-text">中序(迭代法重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后序-迭代法不重要-但递归解法的理解很重要"><span class="nav-text">后序(迭代法不重要,但递归解法的理解很重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径-重要"><span class="nav-text">路径(重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高度"><span class="nav-text">高度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深度"><span class="nav-text">深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最大深度"><span class="nav-text">最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代法"><span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归法1-回溯-重要"><span class="nav-text">递归法1-回溯(重要)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归法2"><span class="nav-text">递归法2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小深度"><span class="nav-text">最小深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代法-1"><span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归法-回溯"><span class="nav-text">递归法-回溯</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最近公共祖先-重要"><span class="nav-text">最近公共祖先(重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树-诀窍-重要"><span class="nav-text">二叉搜索树-诀窍(重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造二叉树"><span class="nav-text">构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#根据前中序构造二叉树"><span class="nav-text">根据前中序构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据中后序构造二叉树"><span class="nav-text">根据中后序构造二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回溯"><span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#诀窍与模板"><span class="nav-text">诀窍与模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂度"><span class="nav-text">复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合"><span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#没有剪枝的版本"><span class="nav-text">没有剪枝的版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剪枝的版本"><span class="nav-text">剪枝的版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子集"><span class="nav-text">子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全排列"><span class="nav-text">全排列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图论"><span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图的基本概念"><span class="nav-text">图的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的种类"><span class="nav-text">图的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#度"><span class="nav-text">度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的构造"><span class="nav-text">图的构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#邻接矩阵"><span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#邻接表"><span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dfs-bfs诀窍"><span class="nav-text">dfs/bfs诀窍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑排序"><span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判断有环"><span class="nav-text">判断有环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS实现的拓扑排序代码"><span class="nav-text">BFS实现的拓扑排序代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc210-拓扑排序实战"><span class="nav-text">lc210-拓扑排序实战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Union-Find并查集"><span class="nav-text">Union-Find并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理讲解"><span class="nav-text">原理讲解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路径压缩"><span class="nav-text">路径压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码模板"><span class="nav-text">代码模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经典题-lc721-Accounts-Merge"><span class="nav-text">经典题-lc721-Accounts Merge</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Quick-Select"><span class="nav-text">Quick Select</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模板与诀窍"><span class="nav-text">模板与诀窍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lc347-Top-K-Frequent-Elements"><span class="nav-text">lc347 - Top K Frequent Elements</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#岛屿问题"><span class="nav-text">岛屿问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网格类问题的-DFS-遍历方法"><span class="nav-text">网格类问题的 DFS 遍历方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网格问题的基本概念"><span class="nav-text">网格问题的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS-的基本结构"><span class="nav-text">DFS 的基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何避免重复遍历"><span class="nav-text">如何避免重复遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#岛屿问题的解法"><span class="nav-text">岛屿问题的解法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例题-0-岛屿数量"><span class="nav-text">例题 0: 岛屿数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题-1：岛屿的最大面积"><span class="nav-text">例题 1：岛屿的最大面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题-2：填海造陆问题"><span class="nav-text">例题 2：填海造陆问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题-3：岛屿的周长"><span class="nav-text">例题 3：岛屿的周长</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sweep-Line"><span class="nav-text">Sweep Line</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mike</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  















  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/mediumzoom/medium-zoom.js?v=1.1.0"></script>





  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

    <script src="/js/src/local-search.js"></script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>






<script type="text/javascript" src="/js/src/headroom.js"></script>

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/code-highlight-modification.js"></script>

<!-- Flashcards Script -->
<script type="text/javascript" src="/js/src/flashcards.js"></script>
